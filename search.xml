<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[侯捷c++STL体系结构与内核分析]]></title>
    <url>%2Fposts%2FhoujieC%2B%2BSTL%2F</url>
    <content type="text"><![CDATA[Aboutvideos;课件，密码kr24;认识headers、版本、重要资源以STL为目标探讨泛型编程。使用一个东西，却不明白它的道理，不高明！level 0: 使用C++标准库；level 1: 认识C++标准库（胸中自有丘壑，体系结构应当建立起来）；level 2: 良好使用C++标准库；level 3: 扩充C++标准库；Standard Template Library (6大部件：Container(容器) 各种基本数据结构；Adapter(适配器) 可改变containers、Iterators或Function object接口的一种组件；Algorithm(算法) 各种基本算法如sort、search…等；Iterator(迭代器) 连接containers和algorithms；Function object(函数对象)；Allocator(分配器)) 加上其他一些零碎的东西构成了C++ Standard Library.STL体系结构基础介绍STL六大部件（component）：数据在容器（内存的事情我们不必管，由分配器支持），处理数据在算法，连接之间的桥梁是迭代器（泛化的指针）。仿函数可以处理类之间的一些操作，适配器转换。123456789101112131415int stl_component()&#123; int ia[6] = &#123;27, 210, 12, 47, 109, 83&#125;; //用到了容器和分配器定义一个vector vector &lt;int, allocator&lt;int&gt; &gt; vi(ia, ia+6); //用到了算法，迭代器，函数适配器，函数对象 // vi.begin()和vi.end()迭代指向vi中的元素 // not1是negator，否定less的作用，变成了大于等于40的数 // bind2nd绑定了less比较的第二个对象，固定在40 cout &lt;&lt; count_if(vi.begin(), vi.end(), not1(bind2nd(less&lt;int&gt;(), 40))) &lt;&lt; endl; return 0; &#125;简单提及时间复杂度。“前闭后开”曲间，标准库规定容器迭代器的最后一个元素取不到，即[iter.begin(), iter.end() )，此外容器也不一定是连续空间，比如链表。123456789Container&lt;T&gt; c;...Container&lt;T&gt;::iterator ite = c.begin();// for语句的语法规定，括号里面一定要有两个分号，分开三个句子。//第一个句子是初始化用的，如果没有初始化的必要，就视为空语句，加上分号；//第二个句子作为判断条件，如果没有判断条件，也视为空语句，后加一个分号。这种情况，会无限循环，相当于while(1)。如果for的执行部分，就是&#123;&#125;之间有专break语句，可以退出；//第三个句子是执行部分执行完毕再执行的语句；无则视为属空语句；此时不用再加分号for (; ite != ite.end(); ++ite) ...建议使用range-based for statement (since c++11):123for (decl:coll)&#123;statement&#125;123for (int i : &#123;2,3,5,7,9,13&#125;) &#123; std::cout&lt;&lt;i&lt;&lt;std::endl;&#125;容器与分类之各种测试（1）容器-结构与分类1.sequence containers 序列式：array（不可扩充）, vector（分配器动态扩容）, deque（前后快速插入）, list（双向循环链表）, forward-list（单向链表）；2.associative containers 关联式，便于查找：set/multiset, map/multimap, 两者编译器所带标准库都用红黑树实现。set只带key，map带有key和value，两者意思与python的set和dict类似。multiset/multimap代表key是可以重复的。3.unordered containers (since c++11)：不定序，hash table，其实也可以属于一种associative containers.内部采用链表法解决哈希冲突。使用容器array示例：array必须指定固定大小，不能是变量大小；array.data()首地址；clock()得到的是ms；snprintf()是c标注库函数，在这里是将数字转成字符串，具体可参考此；容器与分类之各种测试（2）侯捷老师给的一些建议：1.通过给每个测试定义不同的namespace，使得每一部分都是独立的，方便测试。2.用到变量的时候去定义，然后缩排方便寻找。使用容器vector：vector.push_back()把元素放到尾巴；vector 2倍扩容增长空间；vecotr.size()元素个数；vector.capacity()容器容量，一般比size的结果大；try, catch目的是了解当前是否可以抓取到指定的内存大小；::find中双冒号代表全局的，find()是模板函数（循序查找），返回的是iterator;容器与分类之各种测试（3）1.使用容器list:容器的第二个参数是分配器，一般我们不写使用默认的默认器分配内容；list.max_size()list.size()list.front()list.back()list.sort()对其进行排序2.使用容器forward_list:forward_list.push_front只提供单向的放数据forward_list.max_size()forward_list.front()没有forward_list.back()和forward_list.szie()3.使用容器slist:非C++11标准库；#include&lt;ext\list&gt;头文件包含。4.使用容器deque:双向开口，可进可出。分段连续的buffer构成的，但是给使用者感觉是连续的，内部其实不是，分段连续，buffer内部连续。每次扩充一个buffer.vector扩充方便，但是容易浪费，list每次扩充一个节点，但是查找麻烦，deque每次一个buffer,相对折衷。deque.size()deque.front()deque.back()deque.max_size()没有自己的sort()函数5.使用容器stack:stack.pop()stack.push()stack.size()stack.top()6.使用容器queue:queue.push()queue.pop()queue.front()queue.back()queue.size()stack和queue用的deque，因此在技术上称容器的adapter, 不提供iterator容器之分类与各种测试（4）关联式容器1.使用容器multiset:key就是value, 可插入相同元素，内部红黑树组织数据multiset.insert()multiset.size()multiset.max_size()multiset.find()容器自带find()函数2.使用容器multimap:，内部使用红黑树，key可以重复，指定key和value的数据类型，multimap&lt;long, string&gt; c;multimap.insert(), c.insert(pair&lt;long,string&gt;(i,buff))，利用pair插入和取出multimap.find()3.使用容器unordered_multiset:内部使用hash_table, 链表法解决哈希冲突，一个篮子bucket后续可以挂链表load_facotr载重因子4.使用容器unordered_multimap:5.使用容器set:内部用红黑树实现，元素不允许相同6.使用容器map:内部用红黑树实现，key不允许相同c[i] = string(buf)，与之前的multimap插入元素不同，可以用这种特殊写法，在内部会合成pair7.使用容器unordered_set:内部用hash_table8.使用容器unordered_map:内部用hash_table分配器测试使用分配器：不使用标准库自带的std::allocator, 调用GNU c++编译器的allocatorOOP vs. GPobject-oriented programming and generic programming, 面对对象编程与泛型编程OOP企图将data和methods放在一起，GP却将data和methods分开来算法通过迭代器操作容器数据操作符重载和模板（泛化，全特化，偏特化）再次强调和复习operator overloading，templates（类模板，成员模板，函数模板；模板的泛化，全特化和偏特化）。1.操作符重载的情况主要是为了满足用户自己定义类的一些操作，可以在相关网站查询，并不是每个操作符都可以重载。2.模板Allocator不建议你单独使用分配器。operator new()和底层的内存分配函数malloc()malloc()分配给申请内存大小的空间时会额外给一些空间放必要的东西，有一些额外的开销cookie，free释放内存。但是一般使用时，由于申请的size不大，所以这些额外的空间占所有的比例比较大，所以是个缺陷。P11总结一下，allocator就是用来分配内存的，最重要的两个函数是allocate和deallocate，就是用来申请内存和回收内存的，外部（一般指容器）调用的时候只需要知道这些就够了。内部实现，目前的所有编译器都是直接调用的::operator new()和::operator delete()，说白了就是和直接使用new运算符的效果是一样的，所以老师说它们都没做任何特殊处理。G2.9里的那个更好的allocator，在老师的另一门课《C++内存管理》里讲得特别细，大概从P23开始讲细节，更早的几P也有使用用例。容器之间的实现关系与分类深度探索list（上）最具代表性的容器，双向循环列表，优先介绍。定义自己的迭代器iterator， 其中要有typedef和operator reloading（操作符重载）深度探索list（下）迭代器的设计原则和Iterator Traits的作用与设计容器用域存储数据，算法用以处理数据，而迭代器iterator就是沟通容器和算法的桥梁。上一讲提到，容器需要自己定义iterator，并且写出五个规定的typedef，这个就是为了算法询问iterator，得出这样的特性然后进行定制的数据操作。但是如果iterator不是类，无法写出typedef的时候，就需要traits这样的中间变量来让算法得出迭代器的特性。除了iterator traits之外，还有各式的traits, 包括type traits, char traits, pointer traits等等。Vector深度探索array, forward_list深度探索把array包装成容器，然后利用指针当iterator进行操作。deque, queue和stack深度探索（上）双向队列deque在上层调用时表现是连续的，但是底层实现是用分段连续的buffer来实现的，通过迭代器和操作符重载来营造连续插入或弹出的假象。deque, queue和stack深度探索（下）deque内部通过iterator操作符重载并做一些处理来进行表面上连续空间的模拟。RB-Tree深度探索关联式查找容器的底层支撑结构。Set, Multiset深度探索set和multiset底层利用Rb_tree实现，所以基本上它们的事内部都是交给红黑树去完成，所以又被叫成container adapter. 其中需要注意的是它们中的key和value是一样的，所以不能被改变，否则key就会变化。Map, Multimap深度探索related blogHash Table深度探索另一个关联式容器哈希表，或散列表，是一种常用的存储较多数据的数据结构（减少查找时间），其中难点在于hasd function的选择和对对哈希碰撞的处理（一般是开放式寻址法或者链表法）。Unordered容器概念利用hash table实现unordered_set, unordered_multiset, unordered_map, unordered_multimap容器。算法的形式算法通过迭代器联通容器，进行数据处理和函数运行。从语言层面上讲，容器是class template, 而算法是function template, 其中有些算法还可传入你定制的准则criterion, 比如sort函数的比较函数。迭代器的分类STL容器中总共会用到三种种类，分别是random_access_iterator_tag (array, vector, deque), bidirectional_iterator_tag(list, rb_tree), forward_iterator_tag(forward_list, hashtable可能是) 这三种。多出来的两种input_iterator_tag和output_iterator_tag属于istream和ostream. 五种之间是继承关系，同时用这种tag的方式，非简单的12345.迭代器类别对算法的影响STL算法内部会利用迭代器的类别开辟出不同的处理分支，想尽方法达到最快的处理速度。算法源码剖析（几个例子）举了几个C++标准库中的例子。表明与迭代器结合很紧密。仿函数和函数对象在前面一些的算法的使用中，已经见识到了函数对象/仿函数传入其中进行特殊的操作。在C++的STL中有三大类functors，分别是算术类，逻辑运算类和相对关系类。他们都继承了某个适当者，这样是为了后续利用适配器进行改造，而前提就是像algorithm对iterator一样利用traits询问问题，继承的作用就是为了融入STL，利用被继承者的typedef来回答问题。此外，GNU中也会有一些仿函数供用户使用，比如前面提到的Identity和Select1st存在多种适配器适配器可以认为具有一个桥梁作用：把某个底层B包装下做成A交给用户使用，但是内部仍然是调用B来运作。在C++中，适配器采用复合的方式获得某种功能，非继承。容器适配器方面，典型的是stack和queue，它们内部都是内含了deque作为其底层容器，然后改造成具有自己特性和接口的容器。Binder2nd/not1/bind介绍了前面使用过的一个计数语句cout &lt;&lt; count_if(vi.begin(), vi.end(), not1(bind2nd(less&lt;int&gt;, 40)))，其中用到了算法，函数适配器和函数对象。bind2nd和not1都是函数适配器，用以修饰后面的函数并将其包装。bind2nd绑定第二实参，限制less函数调用时保持第二参数为40不变。修饰后的函数继续被not1修饰，将结果取反，也就是不小于40的数计数。bind2nd内部使用binder2nd函数，目的是为了简化用户使用难度，自动帮你推导operation模板参数。侯老师提到binder1st, binder2nd这些函数后来都被bind函数取代，但是旧的函数依旧可以使用。在C++2.0版本中，bind函数取代了bind2nd，可以用来绑定函数/函数对象/成员函数和数据成员，同时可以指定绑定哪个参数，哪个参数不用绑定，利用诸如_1这样下划线加数字的形式（palceholder，占位符）代表第几个参数可以被后续调用再指明。bind可以指定一个模板参数，代表返回类型。更多的例子和示意见下面的图片。迭代器适配器reverse_iterator/inserterAdapter在容器，仿函数和迭代器上都有使用。侯老师在这里举了两个例子，一个是前面用到过的reverse_iterator，逆序迭代器遍历方向，另一个是inserter，用来插入数据。在这里侯老师再次强调，adapter是把所有需要的东西系起来，打包好，然后供日后再用，起到一种修饰改造作用。copy函数内部已经把流程写死了，就是按照指定的result迭代器，一步步搬移前面两个迭代器指定范围内的数据，后续的一些adapter改造操作，通过利用操作符重载各自解读，来实现自己定制的特性。X适配器ostream_iterator/istream_iteratorostream和istream是两个特殊的迭代器，他们不属于一般的迭代器适配器，容器适配器和仿函数适配器中的任何一个，因此侯老师称之为X适配器，X代表一种未知。一个万用的Hash Functionhash function的制定可以没有任何规律，但是效果是一定要够乱，尽量减少碰撞。这里侯老师先以一个比较简单的customerhash函数开场，说明这样虽然简单，但是hash code比较容易重复。之后引出了C++标准库中的一个“万用的hash function”, 其中的重点是variadic templates, 这个是C++ 2.0中比较重要的新特性，大意就是可变的模板参数，常用…表示，比如下图中的序号1表示的函数，其中的template&lt;typename...Types&gt;就表示可以接受任意数量的模板参数。Tuple用例Tuple是可以将几个不同的数据结构的变量绑在一起的类型，使用上利用直接声明tuple&lt;&gt;创建，也可以利用make_tuple()实现，或者tie函数快速对变量进行赋值，如下图所示。其中可以对&lt;和=这样的操作符进行重载实现特性上的适配。type traitstype traits主要是为了给用户自己写的类提供一些特征信息，用户自己不需要对其进行偏特化处理就可以自动获取，节省代码工作量，广泛用于C++泛型编程。这些特征信息通过询问的方式进行获取，指导该类后续的相应操作。上图出现的Plain Old Data (POD)是一个类型（比如class或者struct），但是没有构造函数，析构函数，虚函数等成分。维基百科_)的解释是：POD类类型就是指class、struct、union，且不具有用户定义的构造函数、析构函数、拷贝算子、赋值算子；不具有继承关系，因此没有基类；不具有虚函数，所以就没有虚表；非静态数据成员没有私有或保护属性的、没有引用类型的、没有非POD类类型的（即嵌套类都必须是POD）、没有指针到成员类型的（因为这个类型内含了this指针）。stackoverflow有也相关问题：In short, it is all built-in data types (e.g. int, char, float, long, unsigned char, double, etc.) and all aggregation of POD data. Yes, it’s a recursive definition. ;)To be more clear, a POD is what we call “a struct”: a unit or a group of units that just store data.一个类如果没有没有涉及到指针，就可以不必写析构函数，使用编译器分配的默认的即可。像string内部带了指针，就必须写析构函数。此外，如果不是父类base，没有覆写的虚函数，也不必写virtual destructor.type traits通过模板实现，对类型进行操作，比如下面的例子，利用泛化，偏特化，传回真假值。此外有些type traits实现的特性未曾出现于C++源码标准库。侯老师说这种情况可能就是编译器编译的时候来回答支持，不以源代码的方式呈现。traits的理解type traits 理解cout的操作符重载cout为何可以接收各式各样的object？因为其内部对各类型都做了操作符重载。注意其返回类型为ostream&amp;，为了可以继续接收，非void返回类型。movable的使用move是C++2.0一个比较重要的特性，其内部就是拷贝指针，属于浅拷贝，在type traits中见到的&amp;&amp;符号就代表move功能，而拷贝构造则是深拷贝。move的速度很快，侯捷老师也在课程中比较了加不加move功能对容器元素拷贝速度的影响，同时也给出了一些测试例子，但是在使用move时需要自己对元素的使用有清晰的认识，因为move是拷贝指针，等于是两个指针指向同一个位置，这个是危险的，C++内部会在move时做一些处理去规避这个行为带来的危险情况，所以move完之后的原始对象就最好不要再用了。C++的左值和右值]]></content>
      <categories>
        <category>课程记录</category>
      </categories>
      <tags>
        <tag>侯捷</tag>
        <tag>c++11</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yolo系列论文阅读笔记]]></title>
    <url>%2Fposts%2Fyolopaperreading%2F</url>
    <content type="text"><![CDATA[AboutYOLO系列是one-stage目标检测种的重要成果，兼具速度与精度，同时包含了很多与时俱进的tricks，是理论与工程实践完美结合的产物。虽然Andrew Ng说YOLO论文比较难读，但是为了更好的梳理检测这一模块，理解实践这项工作必须要进行下去。Pytorch YOLO项目推荐。YOLO v1paper;参考博客：1, 2, 3回归问题，输出$7 \times 7 \times 30$的tensorCNN的空间位置不变性，原图$224 \times 224$ resize到$448 \times 448$，downstream 下采样到划分$7 \times 7$的grid栅格，每个栅格预测2个bounding box，预测变量为$(x, y, w, h, p)$，$p = p_{object} * IoU$除了最后一层，其他层用leakly ReLU激活函数，loss函数，分配权重。\begin{array}{l} \lambda_{\text {coord }} \sum_{i=0}^{S^{2}} \sum_{j=0}^{B} \mathbb{1}_{i j}^{\text {obj }}\left[\left(x_{i}-\hat{x}_{i}\right)^{2}+\left(y_{i}-\hat{y}_{i}\right)^{2}\right] \\ \quad+\lambda_{\text {coord }} \sum_{i=0}^{S^{2}} \sum_{j=0}^{B} \mathbb{1}_{i j}^{\text {obj }}\left[(\sqrt{w_{i}}-\sqrt{\hat{w}_{i}})^{2}+(\sqrt{h_{i}}-\sqrt{\hat{h}_{i}})^{2}\right] \\ \quad+\sum_{i=0}^{S^{2}} \sum_{j=0}^{B} \mathbb{1}_{i j}^{\mathrm{obj}}\left(C_{i}-\hat{C}_{i}\right)^{2}+\lambda_{\mathrm{noobj}} \sum_{i=0}^{S^{2}} \sum_{j=0}^{B} \mathbb{1}_{i j}^{\mathrm{noobj}}\left(C_{i}-\hat{C}_{i}\right)^{2}\\ \quad+\sum_{i=0}^{S^{2}} \mathbb{1}_{i}^{\mathrm{obj}} \sum_{c \in \text { classes }}\left(p_{i}(c)-\hat{p}_{i}(c)\right)^{2} \end{array}$\lambda_{coord}=5,\lambda_{noobj}=0.5$，利用平方根宽高是为了让小物体框对尺寸变化更加敏感。YOLO predicts multiple bounding boxes per grid cell. At training time we only want one bounding box predictor to be responsible for each object. We assign one predictor to be “responsible” for predicting an object based on which prediction has the highest current IOU with the ground truth. This leads to specialization between the bounding box predictors. Each predictor gets better at predicting certain sizes, aspect ratios, or classes of object, improving overall recall.Note that the loss function only penalizes classification error if an object is present in that grid cell (hence the conditional class probability discussed earlier). It also only penalizes bounding box coordinate error if that predictor is “responsible” for the ground truth box (i.e. has the highest IOU of any predictor in that grid cell).trick: warm up, drop out fc, dataset random scaling、translations (up to 20%), adjust exposure and saturation (factor 1.5) in HSV color space.普适性的架构，在artwork数据集上检测效果也不错，不局限于自然图像一个grid cell只检测一个物体，如果是重合的多个物体只能检测一个，精度不高，但是由于是统一的架构，在一个网络上检测，信息比faster rcnn的region proposal充分，所以误检率低预测部分：输出结果，置信度低于阈值置0，NMS之后输出根据类别NMS，还是全部NMSYOLO v2paper;参考博客：1, 2, 3, 4reorganization, 跨层连接，自己构建的网络Darknet-19，reorg layer/passthrough全卷积，多尺度加入anchors，提高recallanchor尺度聚类代替手工设定，如何实现聚类位置预测变量loss函数\begin{array}{rl} \operatorname{loss}_{t}=\sum_{i=0}^{W} \sum_{j=0}^{H} \sum_{k=0}^{A} & 1_{\text {Max } 100]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>computer vision</tag>
        <tag>deep learning</tag>
        <tag>object detection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[侯捷C++面向对象程序设计]]></title>
    <url>%2Fposts%2FhoujieC%2B%2B%2F</url>
    <content type="text"><![CDATA[About侯捷手把手教学C++video-part1；video-part2;课件与代码；1.简介编写规范的class代码（object based，单一class)；学习class之间的关系（object oriented，多个class）—-继承/复合/委托；主要学习c++ 98/c++11，以c++ 98为主；同时关注C++ 语言和C++标准库；推荐书籍：C++ Primer, The C++ Programming Language (C++11), Effective C++ 11, The C++ Standard Library, STL源码剖析；2.头文件与类声明数据和函数包在一起打包成class，与struct有一些差别。C++代码的基本形式:.h(header files, class声明)；.cpp(#include, #include “own_file.h”, 标准库和自己的引用方式不同)；.h(标准库)；头文件防卫式声明（任意include头文件，不会重复include）：123456789#ifndef __COMPLEX__#define __COMPLEX__.....前置声明类-声明类-定义.....#endif类声明：class head, class body；class template(用的时候再指定，比如数据类型)；template&lt;typename T&gt;3.构造函数inline函数，在class内部定义完成，比较快，但是是否成为inline函数由编译器决定；数据指定为private，只给函数内部使用，用的时候利用class内部函数传递，不能直接调用；函数大部分可指定为public，允许给外部使用，也可指定private，class内部使用；constructor（ctor，构造函数），创建对象，程序自动调用；123complex c1(2,1);complex c2; //默认值complex* p = new complex(4); //指针变量的初始化和赋值是两个阶段，能初始化的不要放在赋值，效率差一些；不带指针的函数多半不用析构函数；: re (r), im(i)构造函数可以有很多个，overloading重载，也就是说同一名的函数可能不止一个，但是编译器会对其作出区分，实际名称并不相同。但是写的时候要注意，可能会造成冲突，导致编译器不知道调用哪个。4.参数传递与返回举例Singleton，说明确实有类中的函数是private的。const关键字，代表函数不会改变数据内容：double real() const {return re;}，如果考虑到函数不改变data，一定要加上，避免编译时错误。const也可以用在对象面前，代表这个对象的指定的值是不可以改变的，const complex c1(2,1);参数传递：pass by value / pass by reference (to const)，最好参数传递都用引用，如果害怕会引用的值会改变，可以to const，const complex&amp; param，约定引用的值不要改变，否则编译出错。返回值传递：return by value / return by reference (to const)，返回值也尽量传reference。friend （友元）：friend关键字指定的函数可以取private中的data，比从class内部函数拿会快些。相同class的各个object互为friend。设计类注意：数据放在private，函数尽量放public，可被外部调用；参数尽可能传reference，看状况加const；返回值尽可能传reference；class body中需要加const就去加；构造函数的特殊用法，init初始值尽可能去用它；return by reference不能使用的一种情况，class body外的各种定义，应该是局部的变量，local variable去返回的时候不要用引用，因为程序一结束，这个空间就释放出去了。操作符重载与临时对象1.operator overloading(操作符重载，成员函数)，this:不能在参数列写this（成员函数都有this pointer），但是函数里面可以用，操作符传递的时候会自动给this传指针。比如c2 += c1中，+=这个操作符重载了，传递的时候c2自动给了this，你设计的时候不需要人为指定传给谁，只需要指定c1给谁就行了。连续赋值，c3+=c2+=c1，关注一下返回值，ppt中举这个例子提醒我们操作符+=重载函数返回类型是complex&amp;，非代表无返回值的void，因此支持了从右到左连续赋值操作。2.操作符重载，非成员函数，无this:ppt举例为了应对几种可能用法，写出几种函数方式。temp object —typename(); 同时表明返回的是局部变量，return by value，而不是reference: return complex(x + real(y), imag(y))，这里的complex()就代表一个临时对象。举例关于正负号+, -和运算符+, -编译器通过参数个数区分。对于特殊的操作符只能写成全局的非成员函数，比如cout &lt;&lt;中的&lt;&lt;，输出操作符。当然侯捷老师举例说你也可以用成员函数代替，但是这样就变成了c1 &lt;&lt; cout，c1放前面用this指针读取，cout是操作符重载函数的输入参数，虽然不会有啥错误，但是不符合常规习惯。这里讲了cout的返回值不是void，因为可能会连续输出，返回值为ostream&amp;，再一次强调好的程序设计思想。再一次总结：初始化值；const；参数传递尽量考虑pass by reference；return考虑value或者reference；数据尽量放在private，函数一般放在public中。复习Complex类的实现过程防卫式常数定义；class head + class body；private写数据，public写函数（返回值方式，参数传递方式，初值列，成员函数（前面加class名称），考虑是否加const，利用友元关键字获取private数据）；inline函数（是否成为看编译器），传引用时注意变量是否为local variable；可用临时对象返回；1234567891011121314151617#ifndef __COMPLEX__#define __COMPLEX__class complex&#123;public:complex (double r = 0, double i = 0): re (r), im (i)&#123; &#125;complex&amp; operator += (const complex&amp;);double real () const &#123; return re; &#125;double imag () const &#123; return im; &#125;private:double re, im;friend complex&amp; __doapl (complex*,const complex&amp;);&#125;;#endif123456789101112inline complex&amp;__doapl(complex* ths, const complex&amp; r)&#123;ths-&gt;re += r.re; //ths是代表类的指针，所以用-&gt;访问成员ths-&gt;im += r.im;return *ths;&#125;inline complex&amp;complex::operator += (const complex&amp; r)&#123;return __doapl (this, r);&#125;12345678910111213141516inline complexoperator + (const complex&amp; x, const complex&amp; y)&#123;return complex ( real (x) + real (y),imag (x) + imag (y) );&#125;inline complexoperator + (const complex&amp; x, double y)&#123;return complex (real (x) + y, imag (x));&#125;inline complexoperator + (double x, const complex&amp; y)&#123;return complex (x + real (y), imag (y));&#125;12345678#include &lt;iostream.h&gt;ostream&amp;operator &lt;&lt; (ostream&amp; os,const complex&amp; x)&#123;return os &lt;&lt; &apos;(&apos; &lt;&lt; real (x) &lt;&lt; &apos;,&apos;&lt;&lt; imag (x) &lt;&lt; &apos;)&apos;;&#125;三大函数：拷贝构造，拷贝赋值，析构解析string类，带point numbers指针；big three，三个特殊函数；1234567891011class String&#123;public:String(const char* cstr = 0);String(const String&amp; str); //拷贝构造String&amp; operator=(const String&amp; str); //拷贝赋值~String(); //析构函数，离开作用域，进行清楚cleanchar* get_c_str() const &#123; return m_data; &#125; //成员函数，inline functionprivate:char* m_data; //指定指针，动态分配，未指定大小&#125;;class with pointer members必须有copy ctor(拷贝构造)和copy op=(拷贝赋值)，浅拷贝与深拷贝的问题。拷贝赋值：检测自我赋值，先清空，再开辟，然后复制过来。1234567891011121314151617181920212223242526// 析构inlineString::~String()&#123;delete[] m_data;&#125;// 拷贝构造inlineString::String(const String&amp; str)&#123;m_data = new char[ strlen(str.m_data) + 1 ];strcpy(m_data, str.m_data);&#125;// 拷贝赋值inlineString&amp; String::operator=(const String&amp; str)&#123;if (this == &amp;str) return *this;delete[] m_data;m_data = new char[ strlen(str.m_data) + 1 ];strcpy(m_data, str.m_data);return *this;&#125;堆，栈与内存管理stack，是存在于某作用域scope的一块内存空间。比如函数本身就会形成一个stack。heap堆，由操作系统提供的一块global内存空间，程序可动态分配，比如new关键字，需要自己释放。stack(auto) / static / global object注意写法，防止内存泄漏；new: 先分配memory, 再调用ctor（拷贝构造）；delete: 先调用dtor（析构），再释放memory；独家讲解VC编译器动态分配（new）的内存块和分配所得的array，进一步指出array new 一定要搭配 array delete；C++中::的作用；C++中的数据类型；char(unsigned), short, int(unsigned), long(unsigned), bool, float(单精度，保留到小数点后7位), double(双精度，保留到小数点后16位)。复习string类的实现过程防卫式声明；动态分配，利用指针（32位系统4个byte）；构造函数，拷贝构造，拷贝赋值，析构函数（把自己清干净，clean）；123456789101112// 类声明class String&#123;public:String(const char* cstr = 0);String(const String&amp; str);String&amp; operator=(const String&amp; str);~String();char* get_c_str() const &#123; return m_data; &#125;private:char* m_data;&#125;;1234567891011121314151617181920// ctor构造函数inline// ::声明作用域，类外写函类的数String::String(const char* cstr = 0)&#123;if (cstr) &#123;m_data = new char[strlen(cstr)+1];strcpy(m_data, cstr);&#125;else &#123; // 未指定初值m_data = new char[1];*m_data = &apos;\0&apos;;&#125;&#125;//析构函数inlineString::~String()&#123;delete[] m_data;&#125;1234567// copy ctor 拷贝构造函数inlineString::String(const String&amp; str)&#123;m_data = new char[ strlen(str.m_data) + 1 ];strcpy(m_data, str.m_data);&#125;12345678910111213141516// copy assignment operator拷贝赋值函数inline// string后面的&amp;放在typename后面，代表referenceString&amp; String::operator=(const String&amp; str)&#123;// str前面的&amp;代表放在object前面，取出地址// this是指针if (this == &amp;str)return *this;delete[] m_data;m_data = new char[ strlen(str.m_data) + 1 ];strcpy(m_data, str.m_data);// 这里用了return，不用void，不做返回值处理与之前的打印cout使用的&lt;&lt;类似，是为了连续赋值的情况出现，否则连续赋值没有对象// 这里*this代表传回的是this指向的值，至于具体传出去什么由函数前的声明Sting&amp;决定，两者没有绝对关系，这里实际应该传出去了引用return *this;&#125;C++中*和&amp;扩展补充：类模板，函数模板及其他static关键字，定义静态变量。静态局部变量保存在全局数据区（在函数内定义，多次调用函数只会初始化一次，但是只受此函数控制），而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。静态全局变量可以实现文件隔离，静态全局变量不能被其它文件所用 (全局变量可以)，其它文件中可以定义相同名字的变量，不会发生冲突。（见此）singleton，某个类在整个系统中只能有一个实例对象可被获取和使用的代码模式？（见此）类模板，函数模板；namespace std 封装到单元，将库名称封起来，防止冲突。两种用法，一种是using directive: using namespace std;, 另一种是using declaration: using std::cout;, 一般一个文件代码如果不长，只有几百来行，可以直接用第一种。（见此）123456789// using directive方法#include &lt;iostream.h&gt;using namespace std;int main()&#123;cin &lt;&lt; ...;cout &lt;&lt; ...;return 0;&#125;123456789101112131415161718// using declaration#include &lt;iostream.h&gt;using std::cout;int main()&#123;std::cin &lt;&lt; ...;cout &lt;&lt; ...;return 0;&#125;// 或者#include &lt;iostream.h&gt;int main()&#123;std::cin &lt;&lt; ;std::cout &lt;&lt; ...;return 0;&#125;组合和继承object oriented programming, object oriented desugn (OOP, OOD).继承（inheritance），复合（composition），委托（delegation）.1.复合：has-a, 意思是说一个类具有比较强大的功能，可以将其某些性能改造包装成一个新的类，adapter. （container—-&gt; component）复合下的构造和析构：构造由内而外（打地基），析构由外而内（剥洋葱）。2.委托：composition by reference, pimpl: pointer to implementation.(handle/body, 编译防火墙)共享，reference counting，当其中某个人想要改变共享的内容，那么会单独拿出一份copy来给他改，不影响原先的共享内容。3.继承: is-a, : public _List_node_base，属于哪一类继承下的构造与析构，基类与派生类。父类是子类的一种组成成分，类似复合，因此构造由内而外，析构由外而内（父类的析构函数必须是virtual的，否则会出现undefined behavior）。虚函数与多态inheritance with virtual functions.non-virtual函数：不希望子类重新定义（override，覆写）它；virtual函数：你希望子类重新定义（override覆写）它，且你对它已有默认定义；pure virtual函数：你希望子类一定要定义它，你对它没有默认定义；12345678910111213class Shape&#123;public: virtual void draw() const=0; # pure virtual // impure virtual virtual void error(const std::string&amp; msg); // non-virtual int objectID() const; ...&#125;;class Rectangle:public Shape&#123;...&#125;;class Epllipse: public Shape&#123;...&#125;;举例application framework中的template method（指的某一个函数），不是之前的C++模板（通过this调用子类覆写的虚函数）。inheritance+composition关系下的构造和析构，子类既有继承又有component part（子类先构造父类的default构造函数，然后在调用component的default构造函数），或者子类是继承，父类有component part（先复合，再继承）；委托相关设计delegation+inheritance:讲设计模式，并推荐Design Patterns Explained Simplyfile system, 文件系统；prototype, 原型；复习：0.防卫式声明。1.inline关键字line的使用是有所限制的，inline只适合函数体内代码简单的函数使用，不能包含复杂的结构控制语句例如while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。定义在类中的成员函数缺省都是内联的，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的。（只是给编译器的建议）2.函数构造函数初始化，比赋值快。3.const关键字加在为改变数据值的表达式前面，限定为只读属性。4.尽量返回引用，但是局部临时变量或者函数结束对象就死亡的不能返回其引用。5.友元friend，相同类的各个实例对象互为friend，可以通过彼此的内部方法调用传入参数的内部私有成员变量。6.this指针，操作符重载函数，成员函数，编译器自动读取，设计者不可自己指定作为声明，但是可以在函数中显式使用。7.构造，拷贝构造，拷贝赋值，其中拷贝赋值记得检测自我赋值，否则内存出错。8.new关键字，先分配足够的memory，再进行构造。delete关键字，先调用析构函数，然后释放内存。用了new array，也要注意用相应的delete array.9.多类关系，复合，委托，继承，以及继承中的虚函数。Part2-导读part1是面向对象编程，part2是兼谈对象模型。保持良好编程风格和素养基础上，探讨更多技巧；泛型编程（generic programming）和面对对象编程（object-oriented programming)虽然分属不同思维，但它们正是C++的技术主线，所以本课程也讨论模板（template）；深入探索面向对象之继承关系所形成的对象模型（object model)，包括隐藏于底层的this指针，vptr虚指针，vbtl虚表，virtual mechanism虚机制，以及virtual function虚函数造成的polymorphism多态效果；讲解C++11中的三个特性，更多的特性在侯捷老师另一个C++ 2.0教学视频中提及。variadic template;auto;range-based for loop;转换函数 conversion function大意就是类型之间的转换，比如把自定义的类类型转换成内建类型（比如double），后者向相反的方向转。（类转出去，或者把其他东西转换成类）。只要设计者认为合理，就可以在一个类中写好几个转换函数。转换函数的形式：operator typeName()转换函数必须是类的成员函数；转换函数不能指定返回类型，但是有返回值；转换函数没有参数；12345678910111213141516class Fraction&#123;public: Fraction(int num, int den=1) :m_numerator(num), m_denominator(den)&#123;&#125; // 转换函数，讲分数转成double类型，返回类型已经由operator关键字后面得double()指定 operator double() const&#123; return (double) (m_numerator / m_denominator); &#125;private: int m_numerator; //分子 int m_denominator; //分母&#125;；// 例子// Fraction f(3,5);double d=4+f; //调用operator double()将f转为0.6non-explicit one argument constructorexplict关键字，用在构造函数前面，让编译器不去隐式调用变量类型转换，避免在用户不需要类型转换时就自动进行转换。具体解释示例见此博客。pointer-like classes1.关于智能指针。举例shared_ptr，实际上还有unique_ptr, auto_ptr(c++ 98, 但也可继续使用), weak_ptr等。为了更加容易（更加安全）的使用动态内存，引入了智能指针的概念。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。标准库提供的两种智能指针的区别在于管理底层指针的方法不同，shared_ptr允许多个指针指向同一个对象，unique_ptr则“独占”所指向的对象。标准库还定义了一种名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象，这三种智能指针都定义在memory头文件中。必须写操作符重载operator*()和operator-&gt;()其中箭头符号-&gt;会继续作用下去。关于C++11中四种典型的智能指针讲解，见此。2.关于迭代器。容器，容器一定带迭代器也是智能指针，但是略有不同，操作符重载多了几个，operator*(),operator-&gt;(), operator++(), operator--()，因为指针要移动。迭代器是为了表示容器中某个元素位置这个概念而产生的，是一种检查容器内元素并遍历元素的数据类型。C++更趋向于使用迭代器而非下标进行操作，因为标准库（STL）为每一种标准容器定义了一种迭代器类型，而只有少数容器支持下标操作访问容器元素。c++中的容器和迭代器。function-like classes仿函数，functor。operator (), 重载小括号仿函数（Functor）又称为函数对象（Function Object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载 operator() 运算符。因为调用仿函数，实际上就是通过类对象调用重载后的 operator() 运算符。在stl中提供了大量有用的仿函数，比如plus，minus，multiplies，divides，modulus，equal_to，not_equal_to，greater…很多很多，根据传入的参数的个数我们可以分为只需要接受一个参数的仿函数（unary_function）和需要接收两个参数的仿函数（binary_function）。为什么需要仿函数，这里给出了一个解释。仿函数的一些应用见此。namespace经验谈包住你的函数，防止和项目中其他开发者导致类，函数冲突。using namespace std;namespace jj01(自己取得空间名称)调用函数时，加上空间名，比如：jj01::test_member_template()template 模板class template，在part1中已经讲过，比如声明类的时候可以指定数据类型。function template，与类模板不同的是，函数模板在使用是不需要显式地声明传入参数类型，编译器将自动推导类型（编译器会对function template进行实参推导）。member template，成员模板。一个类(无论是普通类还是类模板)可以包含本身是模板的成员函数。这种函数称为成员模板。注意！成员模板不能是虚函数。该语言特性往往被用来支持class template内的成员之间的自动类型转换。specialization模板的泛化与特化。还有一种partial specialization, 偏特化——个数上的偏特化，范围上的偏特化。模板为什么要特化，因为编译器认为，对于特定的类型，如果你对某一功能有更好地实现，那么就该听你的。模板分为类模板与函数模板，特化分为全特化与偏特化。全特化就是限定死模板实现的具体类型，偏特化就是模板如果有多个类型，那么就只限定为其中的一部分，其实特化细分为范围上的偏特化与个数上的偏特化。(C++模板全特化之后已经失去了Template的属性了)模板的泛化：是指用的时候指定类型。优先级：全特化&gt;偏特化&gt;主版本模板类。具体解释可参考1和2。template template parameter模板参数本身也是模板。容器需要好几个模板参数。函数模板不支持模板的模板参数。1234567891011template&lt;typename T, template &lt;typename T&gt; class Container //class不能被typename代替 &gt;class XCls&#123;private: Container&lt;T&gt; c;public: .....&#125;注意，模板的模板参数中，class 不能被替换成typename。在模板中，如果不能区分的哪应该使用typename和class，可以全部都用class替代，typename和class的作用基本相同，而typename出现得比较晚。同时它也支持缺省值（参考此博客）。关于C++标准库侯捷老师建议全部上手调用一遍，实验一遍。可参考侯捷老师的C++标准库STL讲解视频。三个主题1.variadic templates (since c++11)，数量不定的模板参数。template &lt;typename T, typename... Types&gt;…就是一个所谓的pack包，sizeof...(args)可以看出几个arguments.2.auto (since c++11)让编译器帮忙推导type类型，但是频繁使用会使代码阅读性变差。另外有些情况不适合用auto，因为编译器可能无法判断类型。3.range-based for (since c++11)123for (decl : coll)&#123; statement&#125;123for (int i: &#123;2,3,5,7,9,13,17,19&#125;) &#123; cout&lt;&lt;i&lt;&lt;endl;&#125;123456789vector&lt;double&gt; vec;...for (auto elem:vec)&#123; cout&lt;&lt;elem&lt;&lt;endl; //pass by value，对值操作不改变原先的值&#125;for (auto&amp; elem:vec)&#123; elem *= 3 //pass by reference,对原先的数值造成影响&#125;更多的C++11特性讲解见侯捷老师的这个视频。reference一种漂亮的pointer，多半用在参数传递上面。指针*指向变量的地址，引用&amp;可以理解为变量的另一个名称，代表的就是这个变量，虽然内部依旧是指针实现的。复合&amp;继承关系下的构造和析构复习前面的类与类的关系。继承：构造由内而外，析构由外而内。复合：拥有关系，构造由内而外，析构由外而内。继承+复合：base&lt;——derived——-&gt;component, 具体怎么排base和component看编译器。关于vptr和vtblobject model对象模型，virtual pointer(vptr)和virtual table(vtbl).多个虚函数只有一个指针。动态绑定（指针调用，向上转型，调用虚函数），非静态绑定，虚机制，多态（面向对象继承多态的本质）。可参考此博客。关于this除了上面的那个多态，虚函数的另一种用法，template method。此例子在part1也举过，放在这里由于之前解释了虚函数和动态绑定的用法，所以复习之后进一步加深这个设计理念。后面简单从编译后的汇编码看静态绑定和动态绑定。谈谈const侯捷老师强调const关键字在设计时非常重要，一定要注意，该加的一定要记得加上。const放在成员函数后头，可修饰成员函数。下面PPT的例子中，有两个operator[]函数，由于const也算是函数签名，所以并不会构成ambiguity. 其中前者是针对常量字符串，不必考虑COW(copy on write)，后者需考虑COW，在这里，函数是从一个字符串中取出某个值，可能对其进行变动，返回是reference也预示了这个情况。侯捷老师在这里举例了前面的共享内存的例子，可能多个指针变量指向同一块内存，如果其中某一个需要修改所指的变量值，那么就是单独copy出来一份给他改。关于const关键字的简单总结可参考此博客。关于New, Delete1.复习new先分配memory，再调用ctor.delete先调用dtor，再释放memory.array new一点更要搭配array delete.即new()搭配delete()，new[]搭配delete[].2.重载operator new, operator delete, operator new[], operator delete[]从内存分配上看，new[]里面还加了一个counter，4个字节大小，存储你new了几个元素，这样便于delete时销毁。如果写上了global scope operator ::，那么调用new和delete会绕过前述所有的overload functions，强迫使用global version.C++语言内置默认实现了一套全局new和delete的运算符函数以及placement new/delete运算符函数。不管是类还是内置类型都可以通过new/delete来进行堆内存对象的分配和释放的。对于一个类来说，当我们使用new来进行构建对象时，首先会检查这个类是否重载了new运算符，如果这个类重载了new运算符那么就会调用类提供的new运算符来进行内存分配，而如果没有提供new运算符时就使用系统提供的全局new运算符来进行内存分配。内置类型则总是使用系统提供的全局new运算符来进行内存的分配。对象的内存销毁流程也是和分配一致的。new和delete运算符既支持全局的重载又支持类级别的函数重载。下面是这种运算符的定义的格式：123456789101112&gt; //全局运算符定义格式&gt; void * operator new(size_t size [, param1, param2,....]);&gt; void operator delete(void *p [, param1, param2, ...]);&gt; &gt; //类内运算符定义格式&gt; class CA&gt; &#123;&gt; void * operator new(size_t size [, param1, param2,....]);&gt; void operator delete(void *p [, param1, param2, ...]);&gt; &#125;;&gt; &gt;对于new/delete运算符重载我们总有如何下规则：new和delete运算符重载必须成对出现。new运算符的第一个参数必须是size_t类型的，也就是指定分配内存的size尺寸；delete运算符的第一个参数必须是要销毁释放的内存对象。其他参数可以任意定义。系统默认实现了new/delete、new[]/delete[]、 placement new / delete 6个运算符函数。它们都有特定的意义。你可以重写默认实现的全局运算符，比如你想对内存的分配策略进行自定义管理或者你想监测堆内存的分配情况或者你想做堆内存的内存泄露监控等。但是你重写的全局运算符一定要满足默认的规则定义。如果你想对某个类的堆内存分配的对象做特殊处理，那么你可以重载这个类的new/delete运算符。当重载这两个运算符时虽然没有带static属性，但是不管如何对类的new/delete运算符的重载总是被认为是静态成员函数。当delete运算符的参数&gt;=2个时，就需要自己负责对象析构函数的调用，并且以运算符函数的形式来调用delete运算符。更多详解可参考此博客。]]></content>
      <categories>
        <category>课程记录</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>侯捷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图搜无向定长环]]></title>
    <url>%2Fposts%2FloopdetectioninBipartitegraph%2F</url>
    <content type="text"><![CDATA[About这个问题来源于中兴举办的2020优招算法比赛“傅里叶派”，要求是对提供的数据进行二分图建模，然后找出4，6，8，10，12，14的无向图的总数量，同时有时间和禁止多线程操作要求。起先，我是把数据当成随机生成的普通数据，然后利用DFS（B站上有个up主讲的DFS和BFS系列非常浅显易懂，链接）和拼接单链组合成环，最后利用python的set哈希去重的方法来实现的，在一阶段数据上（（256+640，256+640）大小的邻接矩阵）大概可以进1分钟至1分半钟。后面，随着第二阶段数据的增大（（1344+1344，1344+1344）大小的邻接矩阵），运行时间急剧增加，大概到了30分钟。实际上，算法的主要瓶颈在去重时间上（去重数据达到亿级别的字符串），为了降低去重时间，我花了不少时间去Google，包括数据库的一些去重，或者使用bitmap位图等，考虑到硬件限制，试了一下bloom filter，但是由于hash碰撞等原因，可能出现一些误判，而且随着查重数量的增大，占用的内存也会增大。最后的测试时间上与set相比没有什么优势。最后跟朋友交流，发现数据的一些规律得以解决。原来主办方给的数据是精心设计过的，整个数据中存在固定长度的固定数量sections，每个section中若$A_{i}B_{j}=1$，那么$A_{i+1}B_{j+1}=1$，存在这么一种递推关系，这样就会大大减少了搜索量和查重量。根据固定的节点修改代码，最后运行时间从半个小时降到了50s左右。最后的数据规律是快要接近deadline知道的，虽然分析数据也应当是一个基本的素养，但是面对这种题目，我个人感觉还是追求通用性解决方案更有意义一些。比如真正面对庞大的数据量的时候，关系图是不确定的，没有这种很强的先验知识，那么应该设计系统去尽可能快速地查找和统计环的数量。我自己没有进一步深究了，目前的几个naive想法是可以考虑多线程找环查重在一起合并查重，查重获取可以采用一些数据库的技术，比如针对业务建一个服务器专门用来进行通用性查重，代码中直接调API即可。具体题目要求，两阶段数据和代码见github仓库算法设计在阶段一中，没有对数据分布进行分析，而是单纯以普通的二分图找环问题进行算法设计：首先读入csv文件数据，将A, B之间关系采用邻接表的形式分别存储，并赋给A, B中每个人以独有的id（A的id为0-A总人数减一，B的id为0加A总人数-B总人数减一加A总人数），然后利用深度优先搜索思想，按id从小到大的顺利，以每个A为起点，不断递归往下深入图，找出符合长度的环，并将其存储，遍历去重，得到属于每个A的环结果。由于每个A都是往下搜索下一个A，所以搜出的环不会与前面的结果重复，最后直接相加每个A搜索出的结果即为最后的答案。由于图的尺寸比较大，纯搜索环（以本题为例，尤其环的长度超过8以后搜索时间会迅速增加）和遍历去重比较耗时，为此需要进行优化。a). 由于是搜索二分图中的无向环，因此环的长度只能是偶数，为了减少整体搜索时间，将10，12，14长度的环分别切成两条长度相等的单链（长度分别为6，7，8），仅头和尾节点相同的单链可以组合成以上述长度的环，4，6，8长度的环可以在搜索单链时分别反向回溯下一节点得到环的数量；b). 遍历去重问题是个人算法设计中最为耗时的一部分，实验发现如果仅按照a)中的思想搜索环而不去重，可以较快得到答案。一种直接的去重方法是以list存放环的组成id，并升序排好嵌入另一个大list中，之后拼出的环在其中遍历比较，不相等即计数加一并将其append进大list中，但是随着环长度的增加，遍历比较的时间爆炸增长，几乎无法很好完成去重任务。因此后续考虑将已升好序的环的id转成字符串进行编码存入set()中，通过内部hash去重，来极大降低去重开销；在阶段二中，若直接采用阶段一的思路来处理阶段二的数据，程序运行时间会从95s左右增加到1600s左右，时间复杂度太高。对这种普适性找环算法在题目限制下优化几乎不太可能，于是将目光转移到数据上。通过分析发现，整体数据可以分成好几个sections，在每个sections内部，A点的朋友关系是递增的，即若$A_{i}B_{j}$是朋友，那么$A_{i+1}B_{j+1}$也是朋友，这种相似性结构会导致sections内部每个点A的环组成也是相似的，且数量相同，类似于动态规划中的重叠子问题。因此，只需要计算每个sections内中开头点的环数量，然后乘以该section的长度，最后相加所有的sections即可。另外，由于是无向环，因此最后还需要将累加得出的每个固定长度环的数量除以A的节点数，去除重复搜索的影响。由于两阶段的数据都存在这样的规律，因此可以大大简化搜索算法，只需指定不同section的开头节点和长度便可将其合并。代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195import csvimport timefrom collections import deque&quot;&quot;&quot;数据之间存在规律：如果A_&#123;i&#125;B_&#123;j&#125;之间是朋友关系，那么A_&#123;i+1&#125;B_&#123;j+1&#125;也是朋友关系每行数据之间和上一行存在递归关系，这些关系存在于每份数据固定长度的段落中，因此可以简化搜索点，每个段落只需搜索起始点即可，后面的环数量都相同1.通过深度优先搜索DFS在A和B之间反复往下找，直到固定长度或者无法深入为止；2.由于环的长度越大纯搜索就越耗时，所以利用一半长度加1的单链然后组合拼接；3.拼接过后的无向环存在重复，利用字符串编码环信息和集合set()加速遍历去重；&quot;&quot;&quot;class Solutions(): def __init__(self, input_file, output_file): self.input_file = input_file #输入的csv文件名 self.output_file = output_file #输出的文件名 self.A_num = 0 #存储A部落人数 self.B_num = 0 # 存储B部落人数 self.graphAB = &#123;&#125; # 存储A与B的好友关系 #存储长度为6,7,8的单链，后续组合元素到10,12,14的环 self.lines = &#123;6:deque([]), 7:deque([]), 8:deque([])&#125; #存储搜索到的长度为4，6，8, 10, 12, 14的环 self.circles = &#123;4:set(), 6:set(), 8:set(), 10:set(), 12:set(), 14:set()&#125; self.count = &#123;4:0, 6:0, 8:0, 10:0, 12:0, 14:0&#125; #存储最终答案 self.sections_len = 0 # 存储给定数据中设定的固定段落数长度# 读取CSV文件创建字典表示关系图 def load(self): with open(self.input_file, &apos;r&apos;) as f_in: lines = list(csv.reader(f_in)) self.A_num = len(lines) # A部落人数 self.B_num = len(lines[0]) # B部落人数 for m in range(self.A_num + self.B_num): self.graphAB[m] = deque([]) for i in range(self.A_num): for j in range(self.B_num): if lines[i][j] == &apos;1&apos;: # A的id：0 ~ self.A_num - 1 # B的id：self.A_num ~ self.A_num + self.B_num - 1 self.graphAB[i].append(j + self.A_num) self.graphAB[j + self.A_num].append(i) # 深度优先遍历搜索小于等于8的路径 def DFS(self, s,A_head,path): &quot;&quot;&quot; 根据好友关系搜索环，直到深度小于8或没有为止 并根据对应关系存入4，6，8的环和6，7，8的单链 s: 搜索起始点 A_head: 最开始的起点A path: 搜索出的路径 &quot;&quot;&quot; # 计算路径的长度 path_len = len(path) # 4，6，8的路径的下一个朋友是起点，成4，6，8的环 if (path_len &gt; 2) and (A_head in self.graphAB[s]) : path_ = path[1:] #深拷贝当前path，丢掉开头 path_.sort() #升序排列 # 进行字符串编码 path_s = &apos;&apos;.join(p for p in map(str, path_)) # 利用set()和内置hash函数去重 if path_s not in self.circles[path_len]: self.circles[path_len].add(path_s) self.count[path_len] += 1 # 6，7，8的路径塞进存储中，后续组合配对成环 if (path_len &gt; 5) and (path_len &lt; 9): self.lines[path_len].append(path[1:]) # 深度优先搜索，长度只搜到8 if path_len &lt; 8: for f_next in self.graphAB[s]: # 如果一个一个搜，可以这样写，每个环只往下搜避免重复 # if (f_next not in path) and (f_next &gt; A_head): if (f_next not in path): path.append(f_next) self.DFS(f_next, A_head, path) path.pop() #将找到固定长度的单链两两组合成环并去重 def lines2circles(self): &quot;&quot;&quot; 把以某个A为起点搜索出的固定长度的单链进行比较 找出除起终点相同任意元素都不同的单链两两配对成环 lines: 指定长度的单链集合列表，每个单链开头的元素相同，都是以A中某人为起点 &quot;&quot;&quot; # 依次拼接长度为6，7，8的单链 # 初始化访问标志位，便于确立是否可以拼接两条单链 visited = [0] * (self.A_num + self.B_num) for k,v in zip(self.lines.keys(),self.lines.values()): len_lines = len(v) #单链的数量 # 以某个A为起点的固定长度单链可能没有或只有一个， # 这个时候无法成环，不用继续运行 if (len_lines == 0) or (len_lines == 1): return # 开始找环 len_circle = 2 * k - 2 # 将lines按照最后一个元素进行升序，降低循环次数 v = sorted(v,key=lambda k:k[-1]) for t in range(len_lines - 1): line1 = v[t] for s in line1: visited[s] = 1 for k in range(t+1, len_lines): #确保只在起终点相同的line中组合，第二个没有后面一定没有 if line1[-1] != v[k][-1]: break #找出两个中相同的元素 line2 = v[k][:-1] SAME = 0 # 合并双链判断标志 # 除了开头和末尾还有其他元素相同，无法配对成环 for s in line2: if visited[s] == 1: SAME = 1 break if SAME == 0: #去掉相同的头和尾元素，成环并升序 circle = line1 + line2 circle.sort() # 字符串编码环存入set() circle_ = &apos;&apos;.join(c for c in map(str, circle)) if circle_ not in self.circles[len_circle]: self.circles[len_circle].add(circle_) self.count[len_circle] += 1 for s in line1: visited[s] = 0 # 以每个A为起点搜索所有指定长度的不重复无向环 def search_circles(self): &quot;&quot;&quot; 以每个A为起点找环； 由于数据存在规律，可以简化搜索点； 否则，如果是随机生成朋友关系， 需要一个一个点去搜 &quot;&quot;&quot; # 第一阶段数据各段落开头节点 if self.A_num == 256: nodes = [0, 64, 128, 192] self.sections_len = 64 # 第二阶段数据各段落开头节点 elif self.A_num == 1344: nodes = [0, 192, 384, 576, 768, 960, 1152] self.sections_len = 192 # 如果数据是随机生成的 else: nodes = range(self.A_num) for i in nodes: path = [i] #找4，6，8长度环和6，7，8长度单链 self.DFS(i,i,path) # 拼接10，12，14长度环 self.lines2circles() # 清空，下一次找环做准备 self.lines = &#123;6:deque([]), 7:deque([]), 8:deque([])&#125; self.circles = &#123;4:set(), 6:set(), 8:set(), 10:set(), 12:set(), 14:set()&#125; # 简单打印程序进度 if self.sections_len != 0: print(&apos;progress:：%d / %d&apos;%(i+self.sections_len, self.A_num), end=&apos;\r&apos;) else: print(&apos;progress:：%d / %d&apos;%(i+1, self.A_num), end=&apos;\r&apos;) # 写入答案到txt文件 def output_ans(self): &quot;&quot;&quot; 把最终的答案写到result.txt文件中 并打印至终端 &quot;&quot;&quot; with open(self.output_file, &apos;w&apos;) as f_out: for k,v in zip(self.count.keys(), self.count.values()): # 每个A节点会被重复遍历，因此需要除以环中包含的A节点数 # 如果是一个一个搜，改一下DFS最后的if代码，此处不再需要 # 这里是为了统一数据规律的情况做了折中处理 v = v * self.sections_len // (k // 2) f_out.write(&apos;木托盘上有%d个名字的祭品最多有%d个;\n&apos;%(k,v)) print(&apos;\n&apos;, v)if __name__ == &apos;__main__&apos;: t1 = time.time() find = Solutions(&apos;Example.csv&apos;, &apos;result.txt&apos;) find.load() find.search_circles() find.output_ans() t2 = time.time() print(&apos;Runing Time: %ds&apos;%(t2-t1))个人线下IDE 采用VS Code，笔记本电脑运行环境为64位 Win10下的Anaconda3 Python 3.7虚拟环境，CPU为2.3GHz的i5-8300H，总内存为16G。针对第一阶段数据，程序用时大约3s左右，针对第二阶段数据，程序用时大约50s左右。实际上，此份代码是还可以进一步优化的，尤其是去重部分，还可以根据数据做些文章，我自己不是很感兴趣，没再继续下去了。]]></content>
      <categories>
        <category>算法与实现</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>algorithm</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MIT]计算机科学课堂中学不到的知识]]></title>
    <url>%2Fposts%2F4074%2F</url>
    <content type="text"><![CDATA[Abouthomepage;lecture video;2020年初始刚放出的公开课，十分实用，千呼万唤始出来。主要是介绍一些CS领域常用的工具和技巧，这些对于平时科研，工作都有很大的帮助。正如在课程介绍和评论中说的，“It’s not computer science. It is computer literacy.”相关资源：阮一峰老师的bash脚本教程Lecture 1. Course overview + the shell官方讲义比较系统和简练，其中包含一些练习题。1date #显示时间12345678910111213141516171819202122232425262728293031# echo 后面跟上要输出的文本echo Helloecho &quot;Hello World&quot;echo Hello\ Worldecho $PATHwhich echo#讲解绝对路径和相对路径pwd # print working diretorycd # change working pathcd .. #进入当前目录上一目录# 讲解输入代码要注意相对路径和绝对路径ls #当前路径下的文件ls .. # 当前路径前一层的文件夹下的文件cd ~ # 返回/home/username/cd - #往返当前和上一个文件夹路径# 讲解 - 加在某个命令后增加argumentls -l # 显示更加详细的文件信息，比如read, write, excute（对该文件或文件夹执行命令）# mv 文件名 文件名 将源文件名改为目标文件名# mv 文件名 目录名 将文件移动到目标目录# mv 目录名 目录名 目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名# mv 目录名 文件名 出错mv filename1 filename2cp source dest #复制文或目录rm filename #删除文件或目录，不可恢复的操作rmdir # 删除空目录，但无法删除非空目录mkdir # 新建目录man ls #manual, 功能类似-help，但是更便于阅读，按q退出# CTRL + l清除面板记录在终端有个输入流input stream和输出流output stream，一般输出流就是执行输入的命令，打印在终端上，但是而可以通过&lt; 和 &gt;符号对input stream和output stream进行指定1234567echo hello &gt; hello.txt # 把文本hello存储在hello.txt中cat hello.txt or cat &lt; hello.txt # 显示file 内容cat &lt; hello.txt &gt; hello2.txt # 复制内容到hello2.txt中，而且是从头覆写cat &lt; hello.txt &gt;&gt; hello2.txt # append, 接着后面写ls -l | tail -n1 &gt;ls.txt # 显示最后一行并写入ls.txt# | 管道命令，是指 | 的左边运行结果 是|右边的 输入条件或者范围12345678sudo su # 加入root权限，后续命令都以super user执行，exit命令推出cd sys # 进入系统设备，可以查看一些参数# 进入之后如果想改变某些系统参数，但是又没有使用sudo su，可以使用tee命令# tee命令用于读取标准输入的数据，并将其内容输出成文件# 下面的命令不仅改变了brightness亮度值，还打印出结果在终端echo 1060 | sudo tee brightnessxdg-open filename #以默认程序打开文件Shell Tools and Scripting官方笔记12345678foo=barecho foo# 失效foo = bar# echo单引号和双引号的区别echo &quot;value is $ foo&quot; # value is barecho &apos;value is $foo&apos; # value is $fooecho &quot;we are in $(pwd)&quot;.sh中的$12345# creates a directory and cds into it.mcd () &#123; mkdir -p &quot;$1&quot; cd &quot;$1&quot;&#125;$0 - Name of the script$1 to $9 - Arguments to the script. $1 is the first argument and so on.$@ - All the arguments$# - Number of arguments$? - Return code of the previous command(上一次的错误代码，echo $?，返回值为0代表正确)2$ -Process Identification number for the current script (两个美元一起，把’2’换成’$’，我这里显示有问题)!! - Entire last command, including arguments. A common pattern is to execute a command only for it to fail due to missing permissions, then you can quickly execute it with sudo by doing sudo !!$_ - Last argument from the last command. If you are in an interactive shell, you can also quickly get this value by typing Esc followed by .grep命令用于查找文件里符合条件的字符串，grep foobar mcd.sh12345678910111213141516171819trueecho $? # 0falseecho $? #1false || echo &quot;Oops, fail&quot;# Oops, failtrue || echo &quot;Will not be printed&quot;#true &amp;&amp; echo &quot;Things went well&quot;# Things went wellfalse &amp;&amp; echo &quot;Will not be printed&quot;#false ; echo &quot;This will always run&quot;# This will always run，分号代表两个不关联的语句example.sh，查找指定的arguments代表的文件中是否有“foobar”这个字符串，没有就加上12345678910111213141516#!/bin/bashecho &quot;Starting program at $(date)&quot; # Date will be substitutedecho &quot;Running program $0 with $# arguments with pid $$&quot;for file in $@; do grep foobar $file &gt; /dev/null 2&gt; /dev/null # When pattern is not found, grep has exit status 1 # We redirect STDOUT and STDERR to a null register # since we do not care about them if [[ $? -ne 0 ]]; then echo &quot;File $file does not have any foobar, adding one&quot; echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot; fidone12ls *.py #打印所有含有.py的文件名ls project? #打印所有&quot;project&quot;后加一个字符的文件名1234convert image.png image.jpgconert image.&#123;png,jpg&#125; #大括号有笛卡儿积的作用touch foo/x bar/y #touch更改文件时间属性，没有则创建diff &lt;(ls foo) &lt;(ls bar) #比较两个文件夹的不同#!/usr/bin/env python加在第一句可以将python按照./file.py执行，提供了解释器的环境路径利用shellcheck检查bash脚本错误几个shell tools：利用tldr简化命令的使用教程，可代替man命令find命令1234567891011121314# Find all directories named srcfind . -name src -type d# Find all python files that have a folder named test in their pathfind . -path &apos;**/test/**/*.py&apos; -type f# Find all files modified in the last dayfind . -mtime -1# Find all zip files with size in range 500k to 10Mfind . -size +500k -size -10M -name &apos;*.tar.gz&apos;# 还可以找到特定的文件然后执行命令# Delete all files with .tmp extensionfind . -name &apos;*.tmp&apos; -exec rm &#123;&#125; \;# Find all PNG files and convert them to JPGfind . -name &apos;*.png&apos; -exec convert &#123;&#125; &#123;.&#125;.jpg \;另有根据数据库查找的locate命令，更新数据库updatedb利用rg等代替grep查找代码中的特定语句12345678# Find all python files where I used the requests libraryrg -t py &apos;import requests&apos;# Find all files (including hidden files) without a shebang linerg -u --files-without-match &quot;^#!&quot;# Find all matches of foo and print the following 5 linesrg foo -A 5# Print statistics of matches (# of matched lines and files )rg --stats PATTERNhistory，history | grep find, CTRL+R交互搜索命令，推荐fzf文件导航，推荐broot]]></content>
      <categories>
        <category>MissingcourseofCS</category>
      </categories>
      <tags>
        <tag>computer science</tag>
        <tag>public course</tag>
        <tag>MIT</tag>
        <tag>practical skills</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stanford CS231n 笔记]]></title>
    <url>%2Fposts%2FnotesofCS231N%2F</url>
    <content type="text"><![CDATA[Abouthomepage;2017 lecture video;中文笔记课程相关时间安排，课件，参考资料，作业详见homepage链接，以最新版为主；官方的assignments和notes做得非常好，强烈推荐学习和反复观看；时间原因，学习19版的时候恰好2020版春季课程将要开始，这一版换了team，里面加了不少新的research介绍，尤其是非监督，自监督之类的，因此会加入一下2020版的内容；个人比较喜欢Justin Johnson的讲课风格和深度，因此配合他在UMICH (University of Michigan) 的 EECS498: Deep Learning for Computer Vision课一起看，可以相互补充（和CS231N有很大重叠， 但也些不同）；Lecture1. IntroductionRelated courses in Stanford:CS131: Computer Vision: Foundations and ApplicationsCS231a: Computer Vision, from 3D Reconstruction to RecognitionCS 224n: Natural Language Processing with Deep LearningCS 230: Deep LearningCS231n: Convolutional Neural Networks for Visual RecognitionAndrew Ng的CS229虽然不在列表中，但个人觉得也值得一看，毕竟也属于经典ML课程。A Brief history of Computer Vision and CS 231n:从史前生物产生视觉开始，到后面的人类对于视觉的研究：相机，生物学研究，以及陆续地对于计算机视觉/机器视觉的系统研究，在社会各个领域结合产生的特定任务的建模设计等工作，这里再一次提到了David Marr的《vision》一书对整个计算机视觉领域的奠基于推动作用。介绍卷积神经网络CNN对计算视觉的推动作用，简介了CNN的历史以及在各个视觉有关问题上的强大作用。推荐课本教材：《Deep Learning》 by Goodfellow, Bengio, and Courville.Lecture2. Image Classificationmaterial: 主讲人Justin Johnson编写的python numpy tutorial，个人觉得是个很不错的教程。官方的notes1—image classification和notes2-linear classification是对本次课的一个总结，补充和拓展（其中第二个笔记大部分是下次课的内容，放在这里我猜可能是预习吧），可以说写得十分详细了，而且常温常新。首先阐述对于计算机而言，为什么分类图片很难（光照，视点，类似纹理背景等）；介绍了一些传统方法对此的努力，但是这些方法效果不好，具有单一性，鲁棒性和generalization都很差；引入data-drive approcah, 也就是收集数据，训练，预测三段式方法；介绍Nearest Neighbours分类器，并阐释不同K值和distance metric选取的不同performance（L1和L2的选取与坐标轴旋转对数据引起的改变）；介绍交叉验证的作用，以及说明K-NN的维度诅咒（处理大数据吃力）和 predict速度慢的缺陷（需要一个个和训练集图片计算distance）；引入线性分类器，权重矩阵W，偏置矩阵b，并在第二个官网的notes中详细地介绍了SVM和Softmax两种loss衡量方式；关于交叉熵，相对熵以及为什么选择交叉熵作为损失函数。官网推荐的一篇阅读review A Few Useful Things to Konw About Machine Learnig，写于2012年，但是仍不过时，可以一读。文中写到的12个”folk wisdom”:Learning = representation+evaluation+optimization;It’s generalization that counts;Data alone is not alone;Overfitting has many faces;Intuition falis in high dimensions;Theoretical guarantees are not what they seem;Feature engineering is the key;More data beats a cleverer algorithm;Learn many models, not just one;Simplicity does not imply accuracy;Representable does not imply learnable;Gneralization does not imply causation;Lecture3. Loss Functions and Optimization官方笔记：linear classification, optimization有更为详细的课程内容解释和总结;其中linear classification笔记中有个交互式demo，主要用来体会SVM和Softmax来训练线性分类器的过程，包括调节正则项，学习率等超参数；上节课引入linear classification，现在需要loss function定量分类器对分类结果与training data的GT之间的差异，需要一些optimization方式去有效寻找模型参数可以最小化loss；介绍两种loss衡量metric: Multiclass SVM和Softmax，并认为两种方式在训练分类器时差异不会很大，SVM是为了拉大正确的score与非正确score之间的差值到设定的margin，所以分的越差惩罚越重，分的越好基本上不再去多费精力，而Softmax则不断将正确的probability拉的更高，错误的拉的更低；由于满足loss function的权重矩阵W有无数个（针对linear classification），之间可成正比例关系，因此需要引入正则项让模型自己适应数据，得到generalization比较高的模型参数；针对优化参数方法，通过随机搜索过渡到梯度下降gradient descent，在官方笔记中更加仔细地介绍了针对实际工程应用的梯度下降法（数值梯度，分析梯度等），满足计算性能之间的trade-off最后针对图像特征，介绍了color histogram, HoG (Histogram of Oriented Gradients), Bag of Words等方法。将feature映射到更高维的空间，使分类问题变得容易，这也是CNN的一大作用，从而引入下一节主题；在这里插一下sigmoid, softmax和cross entropy之间的联系，我们一般说的分类是单标签多分类，也就是说一张图片只会有一个标签，标签与标签之间是互斥的，而softmax计算的类别概率是类别互斥的，因为和为1，而针对多标签分类，也就是说一张图片可能有多个标签存在，标签之间不是非此即彼的，类别不互斥，此时用sigmoid激活函数，因为sigmoid是互相独立的计算，只判断此神经元是否属于该位置对应的类别，所以在计算多分类交叉熵时是每个神经元按照二分类交叉熵算然后求和平均。参考blog1, blog2.梯度下降算法理解：假设一个模型拟合表达式为：$h_{\theta}(x)=\theta_{0}+\theta_{1} x_{1}+\theta_{2} x_{2}+\ldots+\theta_{n} x_{n}$，其中$\theta_{i}, x_{i}$一般都是矩阵，对于一个输入，我们希望计算的值与真实函数$y$尽可能得接近，直接照着真实函数分布去“依葫芦画瓢”比较困难，所以来最小化他们之间得残差来搜索拟合函数的参数，假设我们用平方损失函数：$J(\theta)=\frac{1}{2} \sum \limits _{i=1}^{m}(h_{\theta}(x)-y)^{2}$，现在我们对每一个超参数$\theta_{j}$求偏导，得到关于它得梯度（函数上升最快得方向），由于我们是想找最小值，所以要反方向走（实际可以在损失函数前加个符号，转为找最大值）：\begin{array}{c} \frac{\partial}{\partial \theta_{j}} J(\theta)=\frac{\partial}{\partial \theta_{j}} \frac{1}{2}(h _{\theta}(x)-y)^{2}=(h _{\theta}(x)-y) \cdot \frac{\partial}{\partial \theta_{j}}(h _{\theta}(x)-y) \\ =(h _{\theta}(x)-y) \cdot \frac{\partial}{\partial \theta_{j}}\left(\sum_{i=0}^{n} \theta_{i} x_{i}-y\right)=(h _{\theta}(x)-y) x_{j} \end{array}根据梯度，加上步长learning rate, 对参数$\theta_{j}$进行更新：$\theta_{j}:=\theta_{j}-\alpha(h _{\theta}(x)-y) x_{j}$通过不断地迭代，使函数往最小值逼近。在深度学习实际应用时，训练的数据样本可能很大，一次迭代要计算所有的样本会非常耗时，所以利用SGD方法，抽取一些数据作为batch，认为可以近似代表整体样本的分布，每次换不同的样本去学习，也可以得到近似的解（但这也只是工程近似）。深度学习中的模型拟合函数是非常庞大而又复杂的，结合BP加梯度下降可以使函数收敛到局部最小值。Lecture4. Introduction to Neural Networks这一节官方指定阅读的笔记为：optimization-2-bp, linear-classifier-bp; 此外还给了一些推荐的阅读材料，以供选择，其中包括一份向量，矩阵，BP的导数推导示意笔记，Yan leCun在1998年写的名为“Efficient BackProp”的论文，两篇解释BP的博客（1, 2）和MIT Artificial Intelligence公开课中有关BP讲解的课程视频，此外还有一篇ML中automatic differentiation的survey. 个人感觉如果对微积分和线性代数比较熟悉的话，看一下官方指定阅读的两篇笔记就差不多了，主要是为了深入理解BP，有时间的话也强烈推荐那篇推荐阅读的博客2，是Micahel Nielsen写的《nndl》教材中的一节，在入门DL的时候我就是看的这本书，十分经典耐读。BP的使用大多是对矩阵或者说tensor张量进行的，如果对矩阵求导不熟悉，或者想系统的学习巩固下，可以移步矩阵求导术-上和矩阵求导术-下，上-篇写的是标量对矩阵的求导方法，下-篇写的是矩阵对矩阵的求导方法，都是通过标量上全微分表达式来进行推广和计算的：“导数与微分的联系是计算的枢纽，标量对矩阵的导数与微分的联系是$d f=\operatorname{tr}\left(\nabla_{X}^{T} f d X\right)$，先对$f$求微分，再使用迹技巧可求得导数，特别地，标量对向量的导数与微分的联系是$d f=\nabla_{x}^{T} f d \boldsymbol{x}$；矩阵对矩阵的导数与微分的联系是$\operatorname{vec}(d F)=\frac{\partial F^{T}}{\partial X} \operatorname{vec}(d X)$，先对$F$求微分，再使用向量化的技巧可求得导数，特别地，向量对向量的导数与微分的联系是$d \boldsymbol{f}=\frac{\partial \boldsymbol{f}^{T}}{\partial \boldsymbol{x}} d \boldsymbol{x}$。”（其中，$x,\boldsymbol {x}, X$分表代表标量，向量和矩阵）我想对矩阵的求导可能是本节课的一个小重点以及后面进行DL理论学习的基石。该课延续上一讲提出的linear classifier,介绍了神经元的概念，历史和应用，引入fully-connected network；指出如果层数加多，再加上激活函数，损失函数等，网络所代表的拟合函数表达式将非常庞大而复杂，采用梯度下降的方式训练时，推出分析表达式非常不现实和实际（如果想要零时改变一个函数就要重新推算）；由于我们不关心函数梯度具体表达式，我们只是想通过计算梯度值来更新参数，所以采用computation graph的方式来逆推local gradient，forward + backpropagation形成一个完美体系（upstream gradient, local gradient）；在此课之前我推导过全连接和卷积神经网络的BP，就是当成链式法则”chain rules“来对待，而这次课给我了一个数学公式之外一个更加形象化理解，也即是”computation graph“和”门电路“：Backpropagation can thus be thought of as gates communicating to each other (through the gradient signal) whether they want their outputs to increase or decrease (and how strongly), so as to make the final output value higher.而网络通过一系列”add gate”, “mul gate”, “max gate”等”gate”一步步垒成复杂的函数，而且部分组织可以组合成一个特殊的”gate”，也可以被分解成其他简易的”gate”，方便我们进行梯度计算（注意variable分流forward之后bp要加起来+=）。通过简单的example可以了解到”gate” input和output之间的梯度分配关系，非常形象生动。Lecture 5. Convolutional Neural Networks该节课的官方笔记对卷积神经网络CNN来龙去脉和计算都介绍得很详细，同时也对每个层（Conv layer, pooling layer, fc layer）都做了全面的回顾和介绍。另有一篇博客解释卷积神经网络中”卷积“一词和信号与系统中得卷积操作的联系，知乎也有个理解卷积的回答，看完之后可以加深对卷积核的理解。首先介绍感知机，神经元和CNN的历史；简介一个卷积神经网络的结构以及直觉上层级学习的内容和特征；大部分时间讲解卷积的计算过程；Convolution arithmeticAssignment 1assignment page;reference：github-code;参考培训机构深度之眼的cs231n-camp的文档具体过程和结果参见这个repository注意：一开始运行knn.ipynb文件时可能显示scipy.misc.imread缺失，这是因为新版的scipy包去掉了imread这个module，解决方法是可以在data_utils.py中的from scipy.misc import imread改为from imageio import imread。Lecture 6. Deep Learning Hardware and Software讲义中包含的官方制作的两大深度学习框架（Pytorch, TensorFlow）的tutorial，我把它们直接下载下来放在GitHub便于观看。2017版中该课在train neural network之后，19年改为之前，由于两年间框架格局也在发生改变，所以以最新版slides为主（17版主推TensorFlow，也花了一大半时间介绍TF，19版偏向于PyTorch）。结合前面的tutorial一起看，可以当作非常好的入门学习材料。Lecture 7—8. Training Neural Networks I &amp; II这两节课硬货非常非常的多，很多东西都值得深究。课程讲的不是很清楚，因为内容多，所以需要线下仔细看看笔记。笔记主要分为三个部分：1.neural fc network model: 介绍来自脑启发的神经元neuron，常用的激活函数（sigmoid, tanh, ReLU, Leaky ReLU, Maxout, ELU, SELU），全连接神经网络的一些结构问题，比如是否可以拟合任意连续函数，多少层足够，多大足够，以及表征能力和前向计算等。Sigmoid在训练时除了会有梯度消失的情况外还有输出不是0均值（zero-centered）的情况：这会导致后层的神经元的输入是非0均值的信号，这会对梯度产生影响。以 $f=sigmoid(Wx+b)$为例， 假设输入均为正数（或负数），那么对$W$的导数（sigmoid的导数总是正的）总是正数（或负数），这样在反向传播过程中要么都往正方向更新，要么都往负方向更新，导致有一种捆绑效果，使得收敛缓慢。“What neuron type should I use?” Use the ReLU non-linearity, be careful with your learning rates and possibly monitor the fraction of “dead” units in a network. If this concerns you, give Leaky ReLU or Maxout a try. Never use sigmoid. Try tanh, but expect it to work worse than ReLU/Maxout.larger networks will always work better than smaller networks, but their higher model capacity must be appropriately addressed with stronger regularization (such as higher weight decay), or they might overfit. We will see more forms of regularization (especially dropout) in later sections.2020.6更新：最近Yolo v4使用了Mish激活函数，2020年新版CS231N也加入了Swish激活函数，后续可以实验看是否高于ReLU，但是可能要注意权重初始化的问题。Swish: $f(x) = x * sigmoid(\beta x)$Mish: $f(x)=x*tanh(ln(1+e^{x}))$以及更多激活函数对比见此。2.one time setup: 介绍数据预处理（先减去mean image，或者是mean RGB vector中心化，然后除以std进行normalization；进行PCA降维数据，进行decorrelated或者利用whitening得到各向同性的Gaussian blob；一般利用CNN训练时不需要进行太复杂的数据预处理），权重初始化（非常重要和经验化的一点，不要以零对权重进行初始化，而是随机高斯分布采样初始化，“Xavier” initialization, 并且进行w = np.random.randn(n) * sqrt(1/n)对方差进行校准，为的是让输出的方差与输入的相同，后来何恺明的研究中表明，采用ReLU激活函数，初始化为w = np.random.randn(n) * sqrt(2.0/n)见论文”Delving Deep into Rectifiers: Surpassing Human-Level Performance on ImageNet Classification“，在conv中n是$kernel _size^{2}*input _channels$），batch normalization（直接作为一层插入FC/CNN与激活函数层之间，把batch数据进行标准高斯分布化，当然后面还有一个超参的逆向高斯化，主要是为了让网络自己去判断这哪种对自己适合是一种启发式处理），正则化（L1，L2正则化，一般L2更好些；Max norm constraints设置权重边界；Dropout进行组合训练或者是认为进行数据增强）和损失函数（classification, regression (最好不要硬来，因为没有规律，试着往分类转化), structured prediction）等问题。权重初始化中还有一个transfer learning技巧，利用ImageNet的预训练模型，再根据自己的数据进行层的选择性finetune. 不过目前的研究来看，在object detection领域，自训练似乎比预训练更好（数据够多，卡够多的情况下，数据少还是老老实实用预训练吧），参照恺明大神的Rethinking ImageNet Pre-training。Dropout: Forces the network to have a redundant representation; Prevents co-adaptation of features对Dropout起防过拟合作用的解释—组合派和噪声派；对Inverted Dropout中神经元进行Dropout之后为何需要对余下工作的神经元进行rescale的一个解释—乘再除确保下一层输出期望不变（除以p是为了保证训练和测试时输入给下一层的期望是一样的，那些失活的神经元损失的值会通过其他神经元补回来，这样就等于加强了某些神经元的鲁棒性，如果不除的话等于是随机挑选神经元训练，这样可能达不到预期的增强效果。）Data Augmentation: translation, rotation, stretching（拉伸）, shearing（修剪）, lens distortions（镜头畸变）, color jitter （颜色抖动）等等。Batch Normalization（类似于”白化“，实现数据独立同分布，但是BN并没有实现独立同分布，仅仅是压缩再变换）: 在前向传播时，分两种情况进行讨论：如果是在train过程，就使用当前batch的数据统计均值和标准差，并按照第二章所述公式对Wx+b进行归一化，之后再乘上gamma，加上beta得到Batch Normalization层的输出；如果在进行test过程，则使用记录下的均值和标准差，还有之前训练好的gamma和beta计算得到结果（作业中记录的值也是采用了指数权重滑动平均的方法）。此外，CNN使用时叫spatial batchnorm，主要是考虑到卷积神经网络的参数共享特性。（知乎回答)之前大家对BN的理解就是为了解决ICS (internal covariate shift)，让每一层输入的分布不再变化莫测（网络需要不停调整参数适应数据分布变化），同时也要加上线性变换层保留一些模型需要的原始信息，也让输出的数据值落在激活函数的敏感区域，也可作为正则化的手段（进一步解读见：1, 2, 3）。但是MIT 发表在NeurIPS 2018上的研究”How Does Batch Normalization Help Optimization“发现二者并无关系。研究者证明 BatchNorm 以一种基础的方式影响着网络的训练：它使相关优化问题的解空间更平滑了。这确保梯度更具预测性（见机器之心的翻译）。另外，最近，2020 DeepMind刚出的论文”Batch Normalization Biases Deep Residual Networks Towards Shallow Paths“研究了BN为何可以提升深度残差网络的训练深度：”在初始化阶段，批归一化使用与网络深度的平方根成比例的归一化因子来缩小与跳跃连接相关的残差分支的大小。这可以确保在训练初期，深度归一化残差网络计算的函数由具备表现良好的梯度的浅路径（shallow path）主导“（见机器之心的报导）。出了上述几种变体外，还有个结合版本的Switchable Normalization，给IN, BN, LN分配权重，让网络自己去学习哪种归一化方式适合（总结1，总结2，在NLP中也UCB也通过观测BN的异常情况提出了最新的PN，见此）。在防止模型过拟合方面，正则化方法除了对大权重进行惩罚外，还有引入“random noise”的思路，具体有以下几种（如下图所示）。2019年 CS231N 跟进潮流，新加了Cutout和Mixup方法，其中MixUp方法本人在custom dataset上用过，对小数量数据确实有用。The recommended preprocessing is to center the data to have mean of zero, and normalize its scale to [-1, 1] along each featureInitialize the weights by drawing them from a gaussian distribution with standard deviation of sqrt(2/n), where n is the number of inputs to the neuron. E.g. in numpy: w = np.random.randn(n) * sqrt(2.0/n).Use L2 regularization and dropout (the inverted version)Use batch normalizationWe discussed different tasks you might want to perform in practice, and the most common loss functions for each task3.training dynamics &amp; evaluation: 梯度检查，一些网络学习的注意事项，参数更新，超参搜索，模型ensemble等。这里的重点在于optimizer优化器，从一开始的普通SGD到带动量的SGD，然后是一些自适应学习率的优化器，比如目前最好用的Adam等。Momentum updateing: 关于“动量”更新参数的动力学解释—“动量”应当是“阻尼系数”，点的质量和运动时间看成“1”，然后推导关于位置的更新；Nesterov Momentum: 利用趋势点希望可以跳出“坑”的困境；Second order optimization: quasi-Newton methods, 数学公式，Hessian矩阵，二阶方法是利用函数的曲率，也就是导数的导数来进行参数更新，速度会更快，但是Hessian阵难以计算，带数学推导的知乎推荐论文A Stochastic Quasi-Newton Method for Large-Scale Optimization. 2020.2.20，Google brain放出一篇二阶优化算法训练Transformer的论文Second Order Optimization Made Practical. 关于非线性优化方法的一些区别：一阶法（梯度下降，最速下降），二阶（牛顿法，拟牛顿法），共轭梯度等。从本质上去看，牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快。如果更通俗地说的话，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。所以，可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。（牛顿法目光更加长远，所以少走弯路；相对而言，梯度下降法只考虑了局部的最优，没有全局思想。）根据wiki上的解释，从几何上说，牛顿法就是用一个二次曲面去拟合你当前所处位置的局部曲面，而梯度下降法是用一个平面去拟合当前的局部曲面，通常情况下，二次曲面的拟合会比平面更好，所以牛顿法选择的下降路径会更符合真实的最优下降路径。Adam优化算法: 其实就是momentum + RMSProp，减缓mini-batch训练中的抖动，同时自适应更新学习率，对超参的选择比较鲁棒。相关解释：矩估计，指数加权移动平均与初始时刻阶段偏差修正，a review ppt.The two recommended updates to use are either SGD+Nesterov Momentum or Adam.（有时候带动量的SGD法可能比Adam训练出的效果更好，但是调参的难度可能大点）优化算法总结推荐阅读Juliuszh的知乎专栏：1，2，3另有一篇大牛Sebastian Ruder写的An overview of gradient descent optimization algorithms，最近一次更新在2020.3.20，加入了新的优化器，博客中也提供了arXiv版本。超参Hyperparameters主要包括网络架构，学习率以及其deacy 机制，参数更新机制，和正则化regularization选择及其强度。面对这些超参，在实验时可以通过一下步骤来进行：首先检查模型初始化是的loss，一般权重对每一类都是零认知的，所以会给出平均猜测；然后拿出小部分样本进行实验，进行初始化，给出一些学习率然后对其训练，从中挑出靠谱的；接着再组合学习率和deacy参数，看看哪些不错；然后对上面最好的进行长时间训练，一言以蔽之就是先在数据中的小范围中进行预演。此外也要注意learning rate中的deacy参数选择和加入时间，否则可能使学习不充分。训练刚开始可以采取warm up或者grad warm up处理，这个主要是针对大数据，大网络中权重的初始平稳问题，详见知乎回答。To train a Neural Network:Gradient check your implementation with a small batch of data and be aware of the pitfalls.As a sanity check, make sure your initial loss is reasonable, and that you can achieve 100% training accuracy on a very small portion of the dataDuring training, monitor the loss, the training/validation accuracy, and if you’re feeling fancier, the magnitude of updates in relation to parameter values (it should be ~1e-3), and when dealing with ConvNets, the first-layer weights.The two recommended updates to use are either SGD+Nesterov Momentum or Adam.Decay your learning rate over the period of the training. For example, halve the learning rate after a fixed number of epochs, or whenever the validation accuracy tops off.Search for good hyperparameters with random search (not grid search). Stage your search from coarse (wide hyperparameter ranges, training only for 1-5 epochs), to fine (narrower rangers, training for many more epochs)Form model ensembles for extra performanceLecture 9. CNN Architecture这一节主要讲CNN的几个经典结构（AlexNet, VGG, GoogLeNet, ResNet），课外阅读材料相关网络对应的论文。推荐阅读Justin ho对CNN architecture的介绍文章，链接在此。AlexNet: 开启CNN风潮的奠基之作，规划了CNN网络该有的部件（data augmentation, filter, maxpool, normalization, non-linearity activation function, fc, dropout, gpu加速等）。VGG: 引入小卷积核，一方面小卷积核堆叠拥有大卷积核同样的感受野，另一方面还可以减小参数，同时加深网络，提高拟合精度。后续的网络基本吸取了VGG网络中小卷积核（3x3, p=1, s=1）提取特征，mxpool (s=2) downsample 特征图，同时在缩小后的特征图上加倍filter数量保持时间复杂度。GoogLeNet: 受到Network in Network很大启发（一个是跨通道融合的1x1卷积核带来的MLP功能，提高局部特征的抽象表达能力，另一个是Global Average Pooling (GAP)，单独利用特征图分类），同时提升网络的深度和宽度。为了避免梯度消失，网络额外增加了2个辅助的softmax用于向前传导梯度（辅助分类器）。辅助分类器是将中间某一层的输出用作分类，并按一个较小的权重（0.3）加到最终分类结果中，这样相当于做了模型融合，同时给网络增加了反向传播的梯度信号，也提供了额外的正则化，对于整个网络的训练很有裨益。而在实际测试的时候，这两个额外的softmax会被去掉。之后Google对inception进行改进到v4版本(详见blog)，v2, v3主要是改小卷积核，v4是加入了Resnet的残差连接思想，然后将basic block或者bottleneck中的conv组合换成inception module。GoogLeNet团队发表的有关GoogLeNet的论文：《Going deeper with convolutions》、《Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift》、《Rethinking the Inception Architecture for Computer Vision》、《Inception-v4, Inception-ResNet and the Impact of Residual Connections on Learning》ResNet：加深网络可以获得更好的性能，但是采用常规方法堆叠卷积加深优化困难，实际效果不好。恒等映射，深网络中有不少是对浅网络的缝补，深层网络中，如果保留那些浅层网络的性能，同时又考虑采用恒等映射，那么效果应该不会比单独用浅层网络更差。但是直接学习恒等映射不如学习输出与恒等映射的残差有效（redidual模块会明显减小模块中参数的值从而让网络中的参数对反向传导的损失值有更敏感的响应能力，虽然根本上没有解决回传的损失小的问题，但是却让参数减小，相对而言增加了回传损失的效果，也产生了一定的正则化作用），因此引入跳级连接，ResNet诞生（参考PRIS-SCMonkey，Pascal）。后续的研究者一直在思考为什么ResNet会如此简洁高效，它到底在解决网络学习中的什么问题？1.degradation问题，梯度有效性被跳级连接解决（何恺明在论文中指出梯度消失爆炸问题已经被BN等normalization手段解决得很好了，跳级连接是为了深层的网络参数对梯度更加敏感，保持前面梯度的相关性，因为前向传播的时候将原始的信息带出一部分。当然ResNet也可以在一定程度上缓解梯度弥散的问题，但是这不是最主要的，详见这个知乎回答），且必须是1系数。多个浅层子网络代表的函数的组合函数，并不是真正意义上的深层特征网络。神经网络的退化才是难以训练深层网络根本原因所在，而不是梯度消散。虽然梯度范数大，但是如果网络的可用自由度对这些范数的贡献非常不均衡，也就是每个层中只有少量的隐藏单元对不同的输入改变它们的激活值，而大部分隐藏单元对不同的输入都是相同的反应，此时整个权重矩阵的秩不高。并且随着网络层数的增加，连乘后使得整个秩变的更低。这也是我们常说的网络退化问题，虽然是一个很高维的矩阵，但是大部分维度却没有信息，表达能力没有看起来那么强大。残差连接正是强制打破了网络的对称性。(来自Orhan A E, Pitkow X. Skip connections eliminate singularities[J]. arXiv preprint arXiv:1701.09175, 2017.)来自知乎专栏：https://zhuanlan.zhihu.com/p/428339492.ResNet中恒等变换的意义目前有多种解释，我目前倾向的解释是这种残差结构是为了动态自适应拟合训练数据集网络深度的一种方法，它除了可以平稳甚至加速训练外（跳级连接让不同分辨率的feature组合，梯度的相关性得到了保持，后续的DenseNet则用了更多的不同分辨率的特征组合），就是可以根据你的问题去慢慢补充浅层网络解决的最主要的拟合之外的小边边角角，让最后的函数更加平滑。网络输出的残差$F(x)$部分可能在某个block接近0，可能某个部分比较大，所以是一种自适应复杂度。ResNet是完成一个微分方程的差分形式，dx(t)/dt=H(t)=&gt;x(t+1)=x(t)+H(t). 所以ResNet就是用微分方程来描述一个动态系统，寻找合适的H(t)来构造系统。采用这个结构的好处是H(t)具有某种自适应特性（相比于普通的CNN），对网络的深度不会过于敏感（自适应差分方程的步长），同时简化网络的结构，让网络结构更加均匀化，从几何角度看就是制造了一个更为平直的流形并在其上进行优化，导致系统的收敛性更好。不同的网络结构实际上构造了不同的解空间的流形，并且部分的定义了其上的度量，而不同的度量引出不同的曲率分布，这对系统的收敛性能影响重大。所以不同网络结构的差异表现在：（1）网络结构是否和问题匹配，是否是一个包含了可能解的足够紧致的空间；（2）由网络结构所部分定义的度量是否导致一个比较平直的均匀的流形（度量还被所采用的代价函数所部分定义）。从这两个角度就可以定性和半定量的分析不同网络结构的特性和关系。残差模块并不是就是恒等啊，我觉得可以理解为:当网络需要这个模块是恒等时，它比较容易变成恒等。而传统的conv模块是很难通过学习变成恒等的，因为大家学过信号与系统都知道，恒等的话filter的冲激响应要为一个冲激函数，而神经网络本质是学概率分布 局部一层不太容易变成恒等，而resnet加入了这种模块给了神经网络学习恒等映射的能力。所以我个人理解resnet除了减弱梯度消失外，我还理解为这是一种自适应深度，也就是网络可以自己调节层数的深浅，不需要太深时，中间恒等映射就多，需要时恒等映射就少。当然了，实际的神经网络并不会有这么强的局部特性，它的训练结果基本是一个整体，并不一定会出现我说的某些block就是恒等的情况来自知乎回答：https://www.zhihu.com/question/293243905在论文Deep Networks with Stochastic Depth中，作者设置概率p让residual block随机失活（均匀概率与线性概率，线性概率更有效些，符合ResNet的设计思想），只保留shortcut，结果精度也没有怎么下降，反而提高了训练速度，这也说明Identity Mapping的正确性。对ResNet的改进以及后续其他网络：Wide Residual Networks认为ResNet中有些block去掉也没有影响，所以residual是最主要的影响因素，作者尝试加倍block中的卷积核数量，而不是增加深度，结果发现效果更好，而且由于加深宽度可以由并行化计算解决，所以计算也更加快速。另外，作者也使用了卷积层上的dropout，结果也可以得到一些提升（论文指出何恺明他们是在identity part使用dropout效果不好，所以他们用在这，我想可能是因为拓宽了宽度，特征图增多，可能带来冗余信息，存在过拟合信息）。我没有仔细看论文，也没看源代码，不清楚作者是不是随机给特征图某个元素置0来进行的，实际上给卷积层做dropout的操作并不常见，一般都是BN就足够了，有部分研究是针对卷积层上或者特征图上的droput的，而且认为随机置某元素为0并不能起到作用，因为特征图一般是局部关联的，所以提出了区域置0，某个特征图置0等操作，见此知乎回答。Aggregated Residual Transformations for Deep Neural Networks: ResNeXt，来自ResNet的作者，想法和上面的差不读，在一个block里采用多组重复卷积核操作，拓宽网络。Squeeze-and-Excitation Networks : SENet是在网络的特征通道之间进行建模，显示地通过FC去得到通道之间的依赖关系，然后利用最后的sigmoid激活函数给每个通道附一个新的权重，依照这个重要程度去提升有用的特征抑制用处不大的特征 (feature recalibration)。相关介绍见作者胡杰在机器之心的解释。FractalNet: Ultra-Deep Neural Networks without Residuals: 分形（从多个层次、多个角度、多个组成成分来共同解决一个问题）网络结构，类似于ResNet，但是认为深层网络的关键是浅层到深层的有效过度，residual representation不是必须的。分阶段组合不同分辨率特征，达到了类似于教师-学生机制、深度监督的效果。由于比较复杂，所以没有ResNet用的广泛，但是思想很有深度，其中最突出的contribution就是drop path。在下图的示意中，从输入到预测有很多条路可以走通，drop path机制就是随机失活某些路径，假如其中一条承担的作用是比较大，那么一旦被失活，其他网络就得承担全部的责任，加强其学习力度，所以一方面防止过拟合，另一方面让整个网络变得非常鲁棒，不会出现退化问题，参考此博客。Densely Connected Convolutional Networks: CVPR2017 Best paper，写的也非常简洁通透。其dense block的设计是ResNet的“完全版”，不仅提高了特征的利用率，减小了参数，也减轻了梯度弥散，每一dense block单独产生的特征图层数也相对较少，也便于训练，具体解读见此博客。但是一开始的DenseNet虽然参数少，但是由于复杂的的skip connection和concatenate操作，中间量的存在会占用很多显存，作者后续论文Memory-Efficient Implementation of DenseNets减缓了这个问题，现在PyTorch等框架也应该自动解决了这个问题，在一定程度上。MobileNet, ShuffleNet等轻量级计算网络，通过引入depthwise separable convolution, pointwise group convolution, channel shuffle (顺序重分配每组的channel到新的组，减少每个组单独流动信息的局限性)等操作改变传统卷积计算方式，来加速计算。详见知乎白裳的博客随笔和AI之路的详解。Meta-learning，NAS自动搜索合适架构，开山之作是Google的Neural Architecture Search with Reinforcement Learning ，通过RNN确定架构中每个元素的参数，然后利用reinforcement learning奖励精度高的，惩罚精度差的，以此来学习。NAS领域交叉知识多，暂时无法深入理解。Assignment 2宝藏作业，值得认真做。assignment page;reference：github-code;参考培训机构深度之眼的cs231n-camp的文档具体过程和结果参见这个repository在做CNN那一节时（ubuntu环境，如果是Windows环境可能需要安装python for c++等库），如果在fast_layer.py环节出现CS231n A2: Global name &#39;col2im_6d_cython&#39; is not defined解决，请关掉jupyter notebook，然后重新编译就可以了。Lecture 10. Recurrent Neural Networks这一节课主要讲RNN的网络结构（recursive neural network是树结构，recurrent neural network是chain结构），设计文本生成，image caption, visual question之类的网路，后面通过training问题提及了下LSTM。课程的目的在于希望NLP和CV两者结合，相辅相成，解决更为智能化的问题。参考阅读材料方面主要是花书《deep learning》中的第十章: Sequence Modeling: Recurrent and Recursive Nets. 其内容不难理解，也都是介绍性文字，大部分细节都是列出论文便于感兴趣读者去进一步阅读。（个人觉得看好Justin Johnson的课件就差不多了，主要内容都是RNN结构和LSTM）这里有一篇讲解LSTM的blog（嫌麻烦的可以直接看中文翻译版本）。有关Justin Johnson课上提到的RNN的一些fun application可以在karpathy的这篇blog找到。目前，有关机器翻译，文本生成等NLP问题自谷歌的”Attention is all you need“之后，基本上都直接采用self-attention机制了，但这并不代表RNN没有用，已被淘汰了，其在处理依赖时间序列问题还是有很多用武之地的。Lecture 11. Gnerative Models这节课没有官方推荐阅读材料，只有slides首先介绍监督学习和分监督学习的一些区别（有无外部label带来的监督信号，前者着重利用数据做任务，后者着重学习数据内部的结构和分布等）。2020新版增加了CS236的VAE的notes和Ian Goodfellow在NIPS2016上的tutorial.后面主要讲无监督学习中的一个核心问题density estimation，介绍跟此问题有关的三类generative models：目前在生成式模型方面还未进行研究，所以暂时也没有啥思考，也就单纯把这节课当成一次introduction。课程中有关这三类模型的概念的公式也不搬过来了，直接看课件就好。后续会好好研究一下GAN，那时会再专门写笔记讨论体会心得，先放几个不错的resources链接：review-A Review on Generative Adversarial Networks: Algorithms, Theory, and Applicationspaper list-the-gan-zoohow-to-train-gan-ganhacks知乎文章-令人拍案叫绝的Wasserstein GANresearcher-Jun-Yan-ZhuStanford-cs236-deep generative modelsUCB-cs294-deep unsupervised learning2020.6更新：普通的pixelRNN/CNNs是显示估计数据分布，即：$p_{\theta}(x)= \prod\limits _{i=1}^{n} p_{\theta}\left(x_{i} \mid x_{1}, \ldots, x_{i-1}\right)$，虽然效果不错，但是计算很慢，VAE是利用一个中间的隐变量来进行，即：$p_{\theta}(x)=\int p_{\theta}(z) p_{\theta}(x \mid z) d z$但是上述的VAE只能重建输入图片，如果想要重建满足输入数据分布下的另一个图片该怎么做？我们可以选择$p(z)$为一个已知的比较简单的先验分布，比如高斯分布，$p(x|z)$是神经网络解码出的分布，但是前面的积分会使得整个过程intractable. 考虑后验概率，即$p_{\theta}(z \mid x)=p_{\theta}(x \mid z) p_{\theta}(z) / p_{\theta}(x)$，进一步地有：现在我们先让encoder去让后验概率去近似我们设定的先验概率$p(z)$，比如说是标准正态分布，然后让decoder从拟合的后验概率中采样去重建图片。训练时重建输入图片，用以反向传播，测试时可以直接丢掉encoder，利用decoder随机从先验概率分布中采一个数然后decoder出新的图片。非常漂亮的思想！此外，隐变量$z$也是多维的，每个维度可以带便不同的图像特征，这样的话可以控制我们想要输出的图片内容。以上的两种方法都在试图显示建立数据的分布，而GAN试图绕过复杂的数据分布建模，利用博弈的思想隐式建立数据分布，从而直接生成新的图片样本。Lecture 12. Detection and Segmentation这节课介绍了计算机视觉中比较重要的四个任务：classification, semantic segmentation, object detection, instance segmentation, slides做的很不错。此外，18版的课程里有个两个相关的discussion section：Practical Object Detection and Segmentation，列出了经典的检测和分割结构，并给出了相应的代码实现链接和一些其他resources；Video Understanding.1.semantic segmentation主要通过FCN的结构介绍了downsampling—upsampling这种经典结构，重点引出一般的upsampling的方法，比如unpooling (一种是最近邻补值，一种是记下pooling的索引，然后其他补零)和转置卷积（利用权重矩阵乘以每个元素，然后得到大的特征图区域，overlap的地方累加&lt;累加只是一种处理手段，这方面或许可以有更好的办法恢复信息&gt;）转置卷积transpose convolution： upsampling的一种 ，unpooling, max unpooling, 为什么叫转置卷积更好点，Justin Johnson在课上也给了数学解释。（知乎问题）空洞卷积Dilated Convolution：源自于语义分割领域，目前也大多用于语义分割领域。初衷是为了解决downsample丢失的信息会影响pixel-wise的分类。“dilated的好处是不做pooling损失信息的情况下，加大了感受野，让每个卷积输出都包含较大范围的信息”（知乎问题）2.object detection和instance detection是交叉介绍的，因为后者是前者的集成，也顺带提及了human pose estimation，keypoint。这一部分的介绍相比2017版多了一些细节（尤其是RoI pooling&lt;浮点数两次转整型处理，丢失proposal原始像素信息&gt;和RoI Align&lt;保留浮点数，利用双线性插值得到每个max pooling小区域的四个点，对小目标更好&gt;）和scene graph, 3D检测，3D shape prediction等部分（3D Machine Learning应该是目前工业界比较看重的一个领域，在无人驾驶，增强现实等领域可以发挥作用）。其中object detection部分着重介绍了R-CNN系列，更详细的解释可以阅读另一篇博客。课程中也推荐一篇综述类型的paper: Speed/accuracy trade-offs for modern convolutional object detectors便于进一步了解（在我的另一篇R-CNN检测专题博客会有所提及）。可变形卷积Deformable convolutional networks：受Andrew Zisserman的STN (Spatial Transformer Network) 启发，针对物体的形状自发的选择卷积的区域，而不是按照约定的矩形计算规则，更适合实际。在知乎回答中，有人说可变性卷积是对空洞卷积的一种generalization，增大了感受野 。Lecture 13. Visualizing and Understanding1.试图理解卷机神经网络是怎么做决策的，这些layers到底学了什么东西。因此引入了特征图可视化，看看网络对图像的那些区域或者blob甚至是pixel反应大些（感受野，遮挡，回传对pixel的梯度，gradient ascent等），激活的是哪些地方（这里面的针对像素的梯度上升方法与学习权重等参数的方法是对立统一的，固定神经元参数，给定zero 图像，加一些正则化方法，然后对图像进行优化，看看什么样的图像可以获得更高的类别分数），然后借此产生对抗样本adversarial example试图欺骗网络（17年的最后一课就是请Ian Goodfellow讲这个）。2.利用可视化思想通过选定特定的layer对输入图像做gradient，然后更新图像，放大特征，产生DeepDream效果；3.Neural Texture Synthesis, 利用Gram matrix对小区域图像进行延展；4.Neural Style Transfer, 对输入图像进行特定风格的渲染。这项技术现在已经被商业化了，有不少手机APP和其他应用都有此功能！Justin Johnson也有个torch的实现。但是得到一张转换的图片很慢，因为有很多的forward和backword，因此J.J做了个Fast Style Transfer, 训练另外一个网络来实现style transfer, 其中IN (instance norm)就是为了快速风格转换发明的。课程的slides里也提供了很多相关的paper，对细节感兴趣的可以看看。有关神经网络可视化，个人觉得是个很有意义也和好玩的一个领域，它在一定程度上解释了模型为什么work，也可以结合一些idea做出可消费的funny application出来。Assignment3也有相关的作业，到时候应该可以深入学习理解下。从assignment3来看，为了让输入图像的风格靠近目标图像 (style loss)，采用gram矩阵来编码模型各个层产生的通道之间的相关性，然后尽量让两幅图像的gram矩阵（以指定维度方向上的各个向量之间做内积）相近。gram矩阵代表图像特征中哪些特征是同时出现的，哪些是此消彼长，不相干的，而特征呢就相当于图像的某个特性，比如在修图的时候，我们会调调对比度，加些高光，调调饱和度等，为了得到我们想要的风格的图像，其中有些修图选项可以一起做，有些往大的值调，有些就得往小的调，gram矩阵也是类似的操作，缩小目标gram矩阵和输入gram矩阵之间的差异就等于是给图像加滤镜。此外，gram矩阵的对角线上还包含了每个特征图的原始信息，也就是说不仅有哪些特征（哪些修图选项），也有各个特征之间的联系（修图选项的调整值），因此可以大致代表图像的风格。（相关知乎问题)相关blog: Hungryof的“谈谈图像的style transfer”系列—-1, 2, 3Discussion—Learning on videos视频理解和3D machine learning 似乎成为现在CV中的两个新的热点。2020年的课程中也没有把视频理解放进前面的CV applications中，估计是考虑到视频理解中用的方法也是从那些分类，检测等基础任务中迁移过来的。从现在工业界短视频作为火热的媒介来看，视频理解的研究预计会出现比较大的需求和增长。Discussion Section—-learning on videos其中提到目前主流的三种模型：CNN + RNN: video understanding as sequence modeling3D Convolution: embed temporal dimension to CNNTwo-stream: explicit model of motion (video = apperance + motion)Lecture 14. Deep Reinforcement Learning对于强化学习的印象只停留在一个框架的系统层面上：输入是状态（state），动作（action）和奖励（reward），输出时方案或者策略（policy），大意就是通过奖惩机制，在某个环境中为对象制定在初始状态实现目标的一系列策略。强化学习的热度似乎没有神经网络，GAN等技术大，而且据我身边研究的朋友说，强化学习的学习难度有点高，具体没有细问，可能是模型，critic制作和训练的难度不低。一位bloger在他对强化学习简介的blog中说到：强化学习的领导研究者Richard S. Sutton认为，只有这种学习法才考虑到 自主个体、环境、奖励 等因素，所以它是人工智能中最 top-level 的 architecture，而其他人工智能的子系统，例如 logic 或 pattern recognition，都应该在它的控制之下，我觉得颇合理。个人认为，目前的强化学习方式确实是一个可以融合许多机器学习技术和模型的一个理论框架，视觉中的注意力机制可以用到，NAS中也可以用到，随着时间推移，可能会有更多的结合和应用会产生，甚至引导未来很多产业的落地。一些相关resources:知乎—强化学习（reinforcement learning)有什么好的开源项目、网站、文章推荐一下Deep_reinforcement_learning_CourseA Beginner’s Guide to Deep Reinforcement Learningtextbook—Reinforcement Learning: An IntroductionBesides，这课件做得也挺好的，虽然Serena Yeung小姐姐讲的课让我一知半解，云里雾里的 :(Assignment 3assignment page;reference：github-code;参考培训机构深度之眼的cs231n-camp的文档具体过程和结果参见这个repositoryCOCO_Caption数据集下载速度很能很慢，将链接放至迅雷可能快点，我这边是1～2M/s。做RNN_Caption.ipynb时出现类似assignment1的无法导出imread,imresize问题，原因就是scipy包现在不支持这个函数了，直接将scipy从1.4退回到1.2.0即可。在执行Look at the data部分时出现[WinError 10054] 远程主机强迫关闭了一个现有的连接错误，按照此博客的解释，可能是链接存在一些无法访问的情况，将“http”改成”https”即可，url = url.replace(http://&quot;, &#39;https://&#39;)改完之后可以顺利访问，但是出现进程被占用情况，解决方法同上面博客，修改image_utils.py中的image_from_url函数：123456789101112131415161718192021def image_from_url(url): &quot;&quot;&quot; Read an image from a URL. Returns a numpy array with the pixel data. We write the image to a temporary file then read it back. Kinda gross. &quot;&quot;&quot; try: f = urllib.request.urlopen(url) #_, fname = tempfile.mkstemp() # 为了解决“另一个程序正在使用此文件，进程无法访问的错误&quot; fd, fname = tempfile.mkstemp(dir=&quot;G:\CS231N&quot;) with open(fname, &apos;wb&apos;) as ff: ff.write(f.read()) img = imread(fname) # 在删除临时文件前关闭该文件，防止被占用 os.close(fd) os.remove(fname) return img except urllib.error.URLError as e: print(&apos;URL Error: &apos;, e.reason, url) except urllib.error.HTTPError as e: print(&apos;HTTP Error: &apos;, e.code, url)在NetworkVisualization-Pytorch.ipynb的load some ImageNet images中，运行报错Object arrays cannot be loaded when allow_pickle=False，通过这篇博客发现是自己numpy版本过高问题，将其回退到1.16.1或1.16.2即可解决在使用pytorch时，要注意对requires_grad=True的Tensor和求梯度阶段需要用到的Tensor都不能用inplace operation，也就是不能直接对这些张量进行数值操作，最好加上.detach()曲线救国，见此。在Generative_Adversarial_Networks_PyTorch.ipynb中下载MNIST可能很慢，可以直接找到数据网址自己下载好数据集，然后放到代码自动创建的存放数据的文件夹中的raw中，再次运行就可以不用在线下载，而是直接读取在process了。还有一种办法是改变源代码的中的urls到本地，详情可见here.2017 Invited Talk-Efficient Methods and Hardware for Deep Learning, Song HanCS231N每年都会邀请不同的专家来做一些专题介绍，由于2017年以后都没release视频了，所以就直接看17年的talk了，正好17年的这两个topic都比较不错，在应用上都很重要，因此也很值得学习下。课件Song Han17年的旷视也有一节课专门讲神经网络压缩，链接韩松在该领域算是比较有名的一位，他在此节课从算法讲到硬件（分inference和training两部分），非常系统。虽然大多是overview，但是包含的内容很多，后续研究压缩领域也会从他主页中列举的资料来入门和学习。韩松教授2017年的phd thesis: EFFICIENT METHODS AND HARDWARE FOR DEEP LEARNING)DSD (Dense-Sparse-Dense Training) Model Zoo2017 Invited Talk-Adversarial Examples and Adversarial Training, Ian Goodfellow课件Ian Goodfellow的语速很慢，然而我整节课却没怎么听懂他在讲什么。知乎文章对抗样本Adversarial Examples知乎问题如何看待机器视觉的“对抗样本”问题，其原理是什么？Lecture 17. Human-Centered AI李飞飞最后的总结性课程，描绘AI对社会和人类的影响和蓝图，提出HAI的概念。Lecture 18. Scene Graphs2020版新增了Scene Graphs and Graph Convolutions，slides.这一部分应该是让计算机去更好的理解图片。分类，检测都是认识图片的一种手段，不是目的。]]></content>
      <categories>
        <category>课程记录</category>
      </categories>
      <tags>
        <tag>computer vision</tag>
        <tag>public course</tag>
        <tag>deep learning</tag>
        <tag>Standford</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旷视2017年深度学习实践课程]]></title>
    <url>%2Fposts%2Fmegviidlcourse%2F</url>
    <content type="text"><![CDATA[About视频;课件关注“旷视研究院”公众号回复“深度学习实践PPT”可获取;这套课程虽然是2017年的，但是涉及的内容还是很全面的，很多工作现在都发挥着不小的作用，所以并不过时，仍然值得一看。建议观看者是有过一定基础的人，刚入门者最好一开始不要看此系列课程，个人觉得第五课神经网络压缩，第六课基于DL的目标检测，第十课GAN，第十一课Person Re-Identification讲得比较好。1. Introductioncomputer vision 在AI中的地位属于感知（perception）智能（还包括speech），另外一块是认知（cognitive），包括NLP和AGI（通用人工智能）；人使用眼睛和大脑认识世界，电脑使用图像传感器和算力来视觉感知周围环境；大脑皮层的出现，灵活，结构化，计算处理；CV和AI的关系：其中非常重要的一个task/不同的研究工作和成果/作为关键应用；现阶段的CV任务：classification (image)/ detection (region) /segmentation (pixel，实例，语义，全景)/ sequence (video，spatial+temporal)；David Marr 的《vision》一书，这在visual SLAM中也十分重要，视觉知识的表示，part representation (拆成块，用各种模型表示，举例关键点检测);part representation存在局限，有些不可分，引发了神经网络第二次复兴，Yann Lecun 的卷积神经网络应用于手写字体识别和人脸检测。由于当时难以复现，且懂的人不多，加上小规模数据和SVM等模型流行，神经网络出现衰落；learning-based representation/ feature-based representation，特征工程+分类器（handcraft features engineering+SVM/Random Forest），浅层学习pipeline a short sequence；端到端学习，所有参数联合优化 ，a long or very long sequence实现高维非线性映射；受感知机启发的多层感知机（multilayer perceptron，MLP），利用backpropagation (BP) 梯度训练逼近（局部最优解）任意非线性函数；90年代的神经网络成果：CNN/ autocoder/ boltzmann machine/ belief nets/ RNN；复兴：data+computing+industry competition+a few breakthrough；Resnet的思想：由浅到深学习，保持梯度数值较大，防止梯度消失 ；从以前的手工设计feature为重点到现在设计网络结构（2012-2017为止）为重点，不同的结构所需算力不同，现在轻量级网络是一个热点；卷积核的方式：1x1，3x3，depthwise 3x3等，网络layer连接的方式；2. Math in DL and ML Basics深度学习的内涵：deep learning) representation learning) machine learning) AI;Linear Algebra：向量，矩阵，集合，群，封闭性，矩阵乘法是为了表示一种变换关系，向量映射到另一个向量；方阵，正交矩阵，特征值，特征向量，实对称矩阵，二次型，正定矩阵，半正定矩阵，奇异值分解；Probability：随机事件，随机变量，概率密度函数，联合分布，边缘分布，条件分布，独立变量；贝叶斯法则，先验分布，后验分布，期望，方差，协方差矩阵（半正定）；常见分布：二值分布，二项分布，多值/多相分布（图像分类问题），正态分布（高斯分布）；信息熵（分类中的交叉熵损失函数，发生概率越大的事情信息越不值钱），交叉熵和KL-divergence，生成式模型中的wassertein distance；Optimize：minimization（最小化）— 梯度下降gradient descent（步长的选取很关键），stochastic gradient descent;机器学习基本知识（machine learning basics）— 定义，假设，模型，评估，supervised &amp; unsupervised learning (learning $p(y | x) \quad or \quad p(x,y)$，判别式模型，生成式模型&lt;目前都用判别式模型&gt;, learning $p(x)$，auto encoder，GAN)，“no free lunch theorem”（all learning algorithms are equal, but some algorithm are more equal than others），overfitting &amp; underfitting，model capacity vs. generalization error，regularization (正则项，数据增强，parameter reduce and tying);3. Neural Networks Basics &amp; Architecture DesignFundamental task in CV: classification, object detection, semantic segmentation, instance segmentation, keypoint detection, human pose estimation, VQA…计算机识别图像的难点：图像内容的复杂性和多样性，比如姿势，光照，模糊等；特征是计算机认识图像的一个灯塔，且应当使用非线性特征抽取器；线性组合特征（kernel learning，boosting），缺点是需要大量的templates，对特征的利用性差；特征层级组合，重复利用特征，更为高效 —-&gt; concepts reuse in DL，网络层级的特征也是由低到高，但是这样高度非线性的函数难以优化（目前采用收敛到局部最优值）；key ideas of DL: nolinear system, learn it from data, feature hierarchies, end-to-end learning；激活函数，神经元，全连接网络，训练决定网络参数（前向，反向，更新）；针对图像的认识从locally-connected net到convolutional net的设计，参数共享；卷积层的卷积操作，pooling layer等；网络结构设计：网络拓扑结构，layer function，超参，优化算法等经验性的东西，手动/autoML；简介AlexNet（包含LRN，加速收敛），VGG（发掘3x3小卷积核的显著作用，但并不代表最高效的做法），GoogleNet，ResNet（拟合残差而不是直接拟合原函数），Xception，ResNeXt (借鉴Xception在resnet基础改进)，ShuffleNet，DesneNet，SqueezeNet；structure design: deeper and wider, ease of optimization, multi-path design, resdiual path, sparse connection；简介部分layer design：SPP，batch normalization，parametric rectifiers，bilinear CNNs（做细粒度分类）；针对特定任务的结构设计：Deepface (人脸识别)，Global Convolutional Networks (语义分割)，Hourglass Networks (沙漏结构，大的感受野，用于pose estimation或者关键点)；4. Introduction to Computation Technologies in Deep Learning该节课偏底层，听的不是很懂，权当了解。symbolic computation：深度学习框架overview—program, compilation, runtime mangement, kernels, hardware；computing graph, graph structure—variable, operator, edge；静态图和动态图；执行和优化；dense numerical computation:CPU computation (机器码，流水线，超流水线，超标量，乱序执行/cache hierarchy/…)；other computation devices (NVIDIA GPU&lt;单指令，多线程架构&gt;，Google TPU，Huawei NPU in Kirin 970，Mobile CPU+GPU+DSP)；computation &amp; memory gap；distributed computation:system (communication，Remote Direct Memory Access);optimization algorithm (synchronous SGD，asynchronous SGD)；communication algorithm (MPI Primitives，An AllReduce Algorithm)；5. Neural Network Approximation(low rank, sparsity, and quantization)该节课着重神经网络压缩，for faster training，faster inference， smaller capacity;convolution as matrix product，利用近似权重矩阵达到网络压缩的目的;Low Rank (本质是对矩阵进行一系列分解变换近似操作，减小计算量和存储量):对权重矩阵进行奇异值分解，singular value decomposition；SVD+Kronecker Product ——&gt; KSPD；矩阵分解：C-HW-K====》C-HW-R-(1X1)-K，然后通过reshape进行重新分解，目前horizontal-vertical decomposition最好；shared group convolution is a kronrcker layer；CP-decomposition与depthwise；Sparse Approximation:权重分布有点类似高斯分布 ，0附近很多，微调网络，weight pruning: 韩松博士的deepcompression，让为0的权重逐渐增多（掩模矩阵使权重为0），不让0附近的权重在训练时抖动，FC层效果压缩明显；网络加速计算—稀疏矩阵计算，channel purning，sparse communication for distributed gradient descent；Quantization：用什么精度算；参数的量化，激活的量化，梯度的量化；二值化，binary network；大容量模型利用小bit训练时掉点不明显，小容量模型视情况而定；主讲人周舒畅推荐的几篇文章，其中XNOR-Net为课程阅读要求材料：Bit Neural Network● Matthieu Courbariaux et al. BinaryConnect: Training Deep Neural Networks with binaryweights during propagations. http://arxiv.org/abs/1511.00363.● Itay Hubara et al. Binarized Neural Networks https://arxiv.org/abs/1602.02505v3.● Matthieu Courbariaux et al. Binarized Neural Networks: Training Neural Networks withWeights and Activations Constrained to +1 or -1. http://arxiv.org/pdf/1602.02830v3.pdf.● Rastegari et al. XNOR-Net: ImageNet Classification Using Binary Convolutional NeuralNetworks http://arxiv.org/pdf/1603.05279v1.pdf.● Zhou et al. DoReFa-Net: Training Low Bitwidth Convolutional Neural Networks withLow Bitwidth Gradients https://arxiv.org/abs/1606.06160.● Hubara et al. Quantized Neural Networks: Training Neural Networks with Low PrecisionWeights and Activations https://arxiv.org/abs/1609.07061.6. Modern Object Detectionanchor-free与anchor-based的交替轮回;Representation:Bounding-box: face detection, human detection, vehicle detection, text detection, general object detection;Point: semantic segmentation (下一节课);Keypoint: face landmark, human keypoint;Evaluation Criteria：precision (预测为真的里面真正是真的比例), recall (所有是真的里面预测为真的比例), Average Prcision (AP), mean AP (mAP)，IoU, mmAP(coco);Perform a detection:之前是手工特征+图像金字塔+滑动窗口+分类器（robust real-time detection; IJCV 2001）；通过Fully Convolutional Network进行计算共享;Deep Learning for Object Detetcion:proposal and refine;one stage:example: Densebox, YOLO, SSD, Retina Net…keyword: anchor, divide and conquer, loss sampling;two stage:example: Faster R-CNN, RFCN, FPN, Mask R-CNN;keyword: speed, performance;One Stage:Densebox:流程：图—&gt;图像金字塔—&gt;卷积神经网络—&gt;upsampling—&gt;卷积神经网络—&gt;（4+1）通道—&gt;预测+threshold+NMS；输入：$m \times n \times 3$，输出：$m/4 \times n/4 \times 5$；输出的feature map每个像素对应一个带分数的边框：$t_{i}=\left\{s_{i}, d x^{t}=x_{i}-x_{t}, d y^{t}=y_{i}-y_{t}, d x^{b}=x_{i}-x_{b}, d y^{b}=y_{i}-y_{b},\right\}$其中t和b分别代表左上角和右下角坐标；问题：回归的L2损失函数选的不好（不同程度scale的object学习程度不同），GT assignment也存在问题，object比较拥挤的情况下，多个物体可能缩小在最后特征图上的一个点上，FP比较多，回归变量选取问题，误差较大；UnitBox：把L2 loss换成IoU loss = $-\ln IoU$;YOLO：$7 \times 7$的grid，加了fc层可以覆盖到一些更全局的context，但是受限于固定输入尺寸，运行速度虽快但是拥挤场景检测不是很work；SSD：引入不同scale和aspect ratio的anchor；回归GT与anchor的offset；不同layer检测不同尺寸的物体，小物体浅层出，大物体深层出（但是并没有直接证据证明此法可靠）；loss sampling和OHEM；blog；DSSD:SSD利用浅层检测小目标，但是浅层语义信息少；利用upsampling和融合加强语义信息；RON:reverse connect (similar to FPN)；loss sampling: objectness prior (先做二分类在再细分)；RetainaNet:引入Focal loss；FPN结构；One Stage Detector: SummaryAnchor：No anchor: YOLO, densebox/unitbox/east；Anchor: YOLOv2, SSD, DSSD, RON, RetinaNet；Divide and conquer：SSD, DSSD, RON, RetinaNet；loss sample：all sample: densebox；OHEM: SSD；focal loss: RetinaNet；Two Stage:RCNN:selective search+分类proposal；Fast RCNN:selective search对应到特征图，通过RoI pooling去分类；Faster RCNN:用预设的anchor去找proposal；RFCN，Deformable Convolutional Networks，FPN，Mask RCNN…Two Stages Detector-Summary:Speed：RCNN -&gt; Fast RCNN -&gt; Faster RCNN -&gt; RFCN；Performance：Divide and conquer：FPN；Deformable Pool/ROIAlign；Deformable Conv；Multi-task learning；Open Problem in Detection：FP；NMS (detection in crowd)；GT assignment issue；Detection in video：detect &amp; track in a network；Human Keypoint Task:Single Person Skeleton：CPM；Hourglass；Multiple-Person Skeleton：top down:detect-&gt;single person skeleton；Depends on the detector：Fail in the crowd case；Fail with partial observation；can detect the small-scale human；More computation；Better localization when the input-size of single person skeleton is large；bottom up:Deep/Deeper cut, OpenPose, Associative Embedding；Fast computational speed；good at localizing the human with partial observation；Hard to assemble human；7. Scene Text Detection and RecognitionBackground:文字的重要性：文明标志，携带高层语义信息，作为visual recognition的线索；problem: scene text detection+scene text recognition；challenge: 比OCR更复杂，比如背景，颜色，字体，方向，文字混杂等；application: card recognition，图片定位，产品搜索，自动驾驶，工业自动化等；conventional methods：detection before deep learning: MSER (maximally stable extremal regions)，SWT (stroke width transform)，Multi-Oriented；recognition: Top-down and bottom-up cues（滑窗+统计特性），Tree-structured Model (DPM+CRF)，Label embedding (另辟蹊)；统一检测和识别：Lexicon Driven；Deep learning methods：包含传统辅助方法的：end-to-end-recognition: PhotoOCR，Deep Features，Reading Text；detection: MSER Trees；不包含传统辅助方法的：detection: Holistic (当作语义分割来做)，EAST (旷视CVPR2017，多任务学习)，Deep Direct Regression (与EAST相似)，SegLink (多尺度特征图)，Synthetic Data (在图片上产生文字)；recognition：$R^2AM$ (递归循环神经网络+soft-attention)，Visual Attention；end-to-end recognition：Deep TextSpotter；summary: ideas from object detection and segmentation，end-to-end，use synthetic data；datasets and competitions：dataset: ICDAR 2103, MARA-TD500, ICDAR 2015, IIIT 5K-Word, COCO-Text, MLT, Total-Text；conclusion:challenges:Diversity of text: language, font, scale, orientation, arrangement, etc；Complexity of background: virtually indistinguishable elements (signs, fences, bricks and grasses, etc.)；Interferences: noise, blur, distortion, low resolution, nonuniform illumination, partial occlusion, etc；Trends:Stronger models (accuracy, efficiency, interpretability)；Data synthesis；Muiti-oriented text；Curved text；Muiti-language text；References:Survey:Ye et al.. Text Detection and Recognition in Imagery: A Survey. TPAMI, 2015.Zhu et al.. Scene Text Detection and Recognition: Recent Advances and Future Trends. FCS, 2015.Conventional Methods:Epshtein et al.. Detecting Text in Natural Scenes with Stroke Width Transform. CVPR, 2010.Neumann et al.. A method for text localization and recognition in real-world images. ACCV, 2010.Yao et al.. Detecting Texts of Arbitrary Orientations in Natural Images. CVPR, 2012.Wang et al.. End-to-End Scene Text Recognition. ICCV, 2011.Mishra et al.. Scene Text Recognition using Higher Order Language Priors. BMVC, 2012.Busta et al.. FASText: Efficient Unconstrained Scene Text Detector. ICCV 2015.Deep Learning Methods:Bissacco et al.. PhotoOCR: Reading Text in Uncontrolled Conditions. ICCV, 2013.Jaderberg et al.. Deep Features for Text Spotting. ECCV, 2014.Gupta et al.. Synthetic Data for Text Localisation in Natural Images. CVPR, 2016.Zhou et al.. EAST: An Efficient and Accurate Scene Text Detector. CVPR, 2017.Busta et al.. Deep TextSpotter: An End-To-End Trainable Scene Text Localization and Recognition Framework. ICCV, 2017.Ghosh et al.. Visual attention models for scene text recognition. 2017. arXiv:1706.01487.Cheng et al.. Focusing Attention: Towards Accurate Text Recognition in Natural Images. ICCV, 2017.Useful Resources:Laboratories and Papershttps://github.com/chongyangtao/Awesome-Scene-Text-RecognitionDatasets and Codeshttps://github.com/seungwooYoo/Curated-scene-text-recognition-analysisProjects and Productshttps://github.com/wanghaisheng/awesome-ocr8. Image Segmentationsemantic segmentaion, instace segmentation, scene parsing, human parsing, stuff segmentation, UlrtraSound segmentation, selfie segmentation…评价指标：\begin{array}{l} {\operatorname{Accuracy}(\mathbf{y}, \hat{\mathbf{y}})=\sum_{i=0}^{n} \frac{I\left[y_{i}=\hat{y}_{i}\right]}{n}} \\ {\operatorname{mean} I O U(\mathbf{y}, \hat{\mathbf{y}})=\frac{\sum_{c}^{m} \sum_{i}^{n} I\left[y_{i}=c, \hat{y}_{i}=c\right]}{\sum_{c}^{m} \sum_{i}^{n} I\left[y_{i}=c \text { or } \hat{y}=c\right]}} \end{array}Semantic Segmantation:FCN: 第一篇语义分割工作；Learning Deconvolution Network for Semantic Segmentation，引入unpool和反卷积deconvolution；DeepLab，引入空洞卷积dilated-convolution和DenseCRF；CRF AS RNN;Deeplab Attention;PSPNet;GCN (Global Convolutional Network，主讲人的工作，想要框住任意尺度的物体);Deeplab V3;Deformable Convolution;Instance Segmentation:Top-down pipeline (目前主流，依赖detection框架)：先detection再segmentationFCIS (框得不准，但是分割依然准)；Mask RCNN;Bottom-up pipeline (效果差，难实现，思考空间大):不出框分割;Semantic instance segmentation via metric learning;介绍旷视的框架：batch size in training:​ detection得batch size往往比分类小很多，主要是训练尺寸不同，另外可能一张图片会有很多proposal…​ 小batch size 会导致：unstable gradient，inaccurate BN statistics， extremely imbalanced data, very​ long training period…Multi-device BatchNorm;Sublinear Memory;Large Learning Rate;打COCO instance segmentation比赛的一些tricks: precise RoI pooling, context extractor, mask generator；keypoint比赛tricks；9. Recurrent Neural NetworkRNN Bascis:Turning Machine, RNN is Turing Complete, Sequence Modeling；RNN Diagram,$(h_{i}, y_{i}) = F(h_{i-1},x_{i},W)$ ；根据input/output分类：many-to-many, many-to-one, one-to-many, many-to-one+one-to-many;many-to-many example: language model (predict next word by given previous words, tell story, write books in LaTex…);many-to-one example: Sentiment analysis…many-to-one+one_to_many exapmle: Neural Machine Translation (encoder+decoder)…训练RNN，梯度爆炸和梯度消失: singular value &gt; 1 =&gt; explodes, singular value &lt; 1 =&gt; vanishes… LSTM (Long short-term memory) come to the resuce;why LSTM works (input gate, forget gate, output gate, temp variable, memory cell);GRU (similar to LSTM, let information flow without a separate memory cell);Search for better RNN architecture;Simple RNN Extentsions:Bidirectional RNN (BDRNN)，预测未来；2D-RNN: Pixel-RNN, each pixel depends on its top and left neighbor (补图，segmentation);Deep RNN (stack more of them, harder to train);RNN with Attention:attention: differentiate entities by its importance, spatial attention is related to location; temporal attention is related to causality;attention over input sequence: Neural Machine Translation (NMT);Image Attention: Image Captioning (input image—&gt; Convolutional feature extraction—&gt;RNN with attention over the image—&gt;Word by word generation);RNN with External Memory:copy a sequence: Neural Turning Machines (NTM);More Applications:RNN without a sequence input: read house numbers from left to right, generate images of digits by learning to sequentially add color to canvas;generalizing recurrence (a computation unit with shared parameter occurs at multiple places in the computation graph);apply when there’s tree structure in data;bottom-up aggregation of information;speech recognition;generating sequence;question answering;visual question answering;combinatorial problems;learning to excute;compress image;model architecture search;meta-learning;…RNN’s RIval:WaveNet: causal dilated convolution, Oord, Aaron van den, et al. “Wavenet: A generative model for raw audio.” arXiv preprint arXiv:1609.03499 (2016).Attention is All You Need (Transformer) ;10. Introduction to Generative Models (and GANs)Basics:Generative Models: Learning the distributions;Discriminative: learn the likelihood;Generative: performs Density Estimation (learns the distribution) to allow sampling;回归建模的话会取平均值，回归的是最可能情况的平均值，显得不真实，a driscrminative model just smoothes all possibilities, ambiguity and “blur” effect;application of generative models: image generation from sketch, interactive editing, image to image translation;How to train generative models:给出一系列样本点，模型生成符合预期分布的输出；exact model: NVP (non-volume preserving), real NVP: invertible no-linear transforms, 理论要求过于严格（Restriction on the source domain: must be of the same as the target.），效果不好（人脸稍微好点，因为其structure比较规矩）；Variational Auto-Encoder (VAE): encoder 做density estimation的过程， decoder做sampling的过程。Generative Adversarial Networks (GAN): 生成器和判别器相互学习进步，交替训练；DCGAN: example of feature manipulation （人脸加眼镜，变性别之类的的操作）；conditional, cross-domain generation (genenative adversarial text to image synthesis);GAN training problems: unstable losses（训练时应该G和D应该处于动态平衡）, mini-batch fluctuation （每个batch之间生成的图像不同），model collapse (lack of diversity in generated results);improve GAN training: label smoothing, Wasserstein GAN (WGAN) (stabilized taining curve, non-vanishing gradient), loss sensitive GAN (LS-GAN)… The GAN Zoo;举一些有名的GAN例子：zhu junyan—-Cycle GAN :correspondence from unpaired data;DiscoGAN: cross-domain relation;GeneGAN: shorter pathway improves training (cross breeds and reproductions, 生成笑容)，object transfiguration (变发型)，interpolation in object subspace (改变发型方向)；Math behind Generative Models:formulation: sampling vs. density estimation;RBM (现在已经不怎么使用)；from density to sample: 给定概率密度方程，无法有效采样；from sample to density: 给定black-box sampler，是否可以估计概率密度（频率）；​ Given samples, some properties of the distribution can be learned, while others cannot.the future of GANs: guaranteed stabilization (new distance), broader application (apply adversarial loss in xx/ different type of data);GAN tutorial from Ian Goodfellow: https://arxiv.org/abs/1701.00160;11. Persom Re-IdentificationReID: from face to person;face recognition (verification, size: $32 \times 32$, horizontal: -30~30, vertical: -20~20, little occlusion);person Re-Identification (trcaking in cameras, searching person in videos, clustering person in photos, challenges: inaccurate detection, misalignment, illumination difference, occlusion…);common in FR &amp; ReID: deep metric learning, mutual learning, re-ranking;special in ReID: feature alignment, ReID with pose estimation, ReID with human attributes;from classification to metric learning:classification network只能辨别那些“见过的”物体，没见过的物体就要重训练，对于人脸识别部署来说，不现实。为了克服这点，加入metric learning，拿pre-train过的classification网络在metric learning中finetune (similar feature);有些工作是fusing intermediate feature maps, 但是计算量和存储都加大，拖慢了速度，不实用；Metric Learning:Learn a function that measures how similar two objects are. Compared to classification which works in a closed-word, metric learning deals with an open-world.contrastive loss: $L_{\text {pairwise}}=\delta\left(I_{A}, I_{B}\right) \cdot\left|f_{A}-f_{B}\right|_{2}+\left(1-\delta\left(I_{A}, I_{B}\right)\right)\left(\alpha-\left|f_{A}-f_{B}\right|_{2}\right)_{+}$ （最后一项有focus困难样本的作用，$\delta$ is Kronecker Delta，$\alpha$ is the margin for different identities），让有相同identity的图像距离变小，反之变大，$\alpha$被用来略掉那些“naive”的negative pairs；triplet loss: $L_{t r p}=\frac{1}{N} \sum \limits ^{N}\left(\left|f_{A}-f_{A^{\prime}}\right|_{2}-\left|f_{A}-f_{B}\right|_{2}+\alpha\right)_{+}$ (The distance of A and A’ should be smaller than that of A and B. $\alpha$ is the margin between negative and positive pairs. Without $\alpha$, all distance converge to zero.);improved triplet loss: $ L_{i m t r p}=\frac{1}{N} \sum^{N}\left(\left|f_{A}-f_{A^{\prime}}\right|_{2}-\left|f_{A}-f_{B}\right|_{2}+\alpha\right)_{+} +\frac{1}{N} \sum^{N}\left(\left|f_{A}-f_{A^{\prime}}\right|_{2}-\beta\right)_{+} $ ($\beta$ penalizes distance between features of $A$ and $A^{\prime}$), only consider image pairs with the same identity;quadruplet loss: $\begin{aligned} L_{q u a d} &amp;=\frac{1}{N} \sum^{N}(\overbrace{\left|f_{A}-f_{A^{\prime}}\right|_{2}-\left|f_{A}-f_{B}\right|_{2}+\alpha}^{\text {relative distance}}) \\ &amp;+\frac{1}{N} \sum^{N}(\overbrace{\left|f_{A}-f_{A^{\prime}}\right|_{2}-\left|f_{C}-f_{B}\right|_{2}+\beta}^{\text {absolute distance }}) \end{aligned}$, 结合了triplet loss和pairwise loss，任何有着相同identity的image之间的distance都要比不同不同image之间的distance小；triplet loss较contrastive loss提升明显，后面的quadruplet loss较triplet提升不多，而带来了计算量和搜索空间的提升，因此常用triplet loss;Hard Sample Mining:triplet hard loss: $ L_{\text {trihard}}=\frac{1}{N} \sum_{A \in \text {batch}}(\overbrace{\max _{A^{\prime}}\left(\left|f_{A}-f_{A^{\prime}}\right|_{2}\right)}^{\text {hard positive pair }} -\overbrace{\min \left(\left|f_{A}-f_{B}\right|_{2}\right)}^{\text {hard negative pair }}+\alpha) $, 找出矩阵中相同identity images中最不像的（the largest distance in the diagonal block）和不同identity images中最像的（The smallest distance in other places）;soft triplet hard loss: 不用一个个找出来，而是利用softmax自动去分配大权重给harder samples;margin sample mining: $L_{e m l}=(\overbrace{\max _{A, A^{\prime}}\left(\left|f_{A}-f_{A^{\prime}}\right|_{2}\right)}^{\text {hardest positive pair }}-\overbrace{\min _{C, B}\left(\left|f_{C}-f_{B}\right|_{2}\right)}^{\text {hardest negative pair }}+\alpha)_{+}$;Mutual Learning:knowledge distill: 知识蒸馏，学生网络学习老师网络的输出；mutual learning: 几个学生网络自己相互学习，利用KL散度算各个网络output pro之间的接近程度；metric mutual learning: $ L_{M}=\frac{1}{N^{2}} \sum_{i}^{N} \sum_{j}^{N} \left(\left[Z G\left(M_{i j}^{\theta_{1}}\right)-M_{i j}^{\theta_{2}}\right]^{2}+\left[M_{i j}^{\theta_{1}}-Z G\left(M_{i j}^{\theta_{2}}\right)\right]^{2}\right) $, ZG代表zero gradient，不计算梯度，不进行反向传播，学习distance matrix;re-ranking: 对initial ranking list进行再ranking，使其smooth，on Supervised Smoothed Manifold/ by K-reciprocal Encoding;Person Re-Identification:difficulties: inaccurate detection, misalignment, illumination difference, occlusion, non-rigid body deformation, similar apperance…evaluation criteria: CMC (Cumulative Math Characteristic), mAP (based on rank);datasets: Marke1501, CUHK03, DukeMTMC-reid, MARS;Feature Alignment:motivations:Person is highly structured;Local similarity plays a key role to decide the identity;methods:Local Features from local regionsTraditional Methods (colors, texture…);Deep Learning Methods;Local Feature AlignmentFusion by LSTM (RNN cannot fuse local features properly);Alignment in PL-Net (Part Loss Network, unsupervised);Alignment in AlignedReID (Face++出品，性能超越人类，global feature+7个local feature，代表人的7个部分，横向pool，只拿对应的边，使用动态规划);ReID with Extra Information:ReID with Pose Estimation:Providing explicit guidance for alignment;Global-Local Alignment Descriptor (GLAD);Vertical alignment by pose estimation;SpindleNet;Fusing local features from regions proposed by pose estimation;ReID with Human Attributes:Attributes is critical in discriminating different persons;12. Shape from X (3D reconstruction: 传统和DL)Structure from Motion (SfM): the most easy-to-understand approach, triangulation gets depth;triangulation: the epipolar constraint对极约束，单目；stereo, rectification (更正), disparity (视差，depth): correspondence, 不能远距离测量；3D point cloud: paper-building Rome in one day, 多视角图片SfM重建，3D geometry；surface reconstruction: integration of oriented point;SfM scanning: SLAM based, positioning, 华为手机发布会实现静止小熊猫玩偶重建；depth sensing: active sensors, structured light, ToF (Time of Flight);short baseline stereo: phase detection autofous;shape from shading: shading as cue of 3D shape (the Lambertian law);photometric stereo;shape from texture, depth from focus, depth from defocus, shape from shadows, shape from sepcularities, object priors paper-A point set generation network for 3D object reconstruction from single image;3D reconstruction from single image:the ShapeNet dataset;depth map;volumetric occupancy;XML file;ponit-based represenation;A neural method to stereo matching:Flownet &amp; Dispnet (using raw left and right images as input, output disparity map);stereo matching cost convolutional neural network—Yan lecun;MRF (马尔可夫随机场) stereo methods;global local stereo neural network;PatchMatch Communication Layer;13. Visual Object TrackingMotion estimation/ Optical flow:motion field: the projection of the 3D motion onto a 2D image;optical flwow: the pattern of apparent motion in images, $I(x, y, t)=I(x+d x, y+d y, t+d t)$, 在adjacent frames中像素的运动；motion field与optical flow不是完全相等；KLT feature tracker (找点，计算光流，更新点)，比较成熟，available in OpenCV；optical flow with CNN: FlowNet / FlowNet 2.0, lack of training data (Flying Chairs / ChairsSDHom, Flying Things 3D);optical flow长距离跟踪和复杂场景跟踪容易失效，不建议采用；Single object tracking:model free: nothing but a single training example is provided by the bounding box in the first frame;short term and subject to causality;paper list;correlation fiter: 模板匹配，similar to convolution;MOSSE (Minimum Output Sum of Squared Error) Filter;KCF (Kernelized Correlation Filter);from KCF to Discriminative CF Trackers: Martin Danelljan, 从Deep SRDCF开始利用CNN feature;Continous-Convolution Operator Tracker: very slow (~1fps) and easy to overfitting;Efficient Convolution Operators: based (factorized convolution operator + Guassian mixture model) on C-COT, ~15fps on GPU;Multi-Domain Convolutional Neural Network Tracker: online tracking, bounding box regression, ~1fps;GOTURN: ~100fps;SiameseFC: ~60fps, a deep FCN is trained to address a more general similarity learning problem in an initial offline phase;Benchmark: VOT (accuracy, robustness, EAO-expect average overlap), OTB(one pass evaluation, spatial robustness evaluation);Multiple object tracking:tracking by detection: assocation based on location (IoU, L1/L2 distance), motion (modeling the movement of objects, Kalman filter), apperance (feature) ans so on;association:association as optimization: local method (Hungarian algorithm), global methods (clustering, network flow, minimum cost multi-cut problem), do optimization in a window (trade off speed against acc);Benchmark: MOT, KITTI, ImageNet VID;evaluation metrics: Multiple object tracking accuracy (MOTA);Other:fast moving object (FMO): an object that moves over a distance exceeding its size within theexposure time;multiple camera tracking;tracking with multiple cues: with multiple detectors, with key points, with semantic segmentation, with RGBD camera;multiple object tracking with NN:Milan, Anton, et al. “Online Multi-Target Tracking UsingRecurrent Neural Networks“. AAAI. 2017.Son, Jeany, et al. “Multi-Object Tracking with QuadrupletConvolutional Neural Networks.” CVPR. 2017.14. Neural Network in Computer Graphics计算机视觉是将图像信息转换成抽象的语义信息等，而计算机图形学是将抽象的语义信息转换成图像信息。Graphics: rendering, 3D modeling, visual media retouching （图像修整）；Neural Network for graphics: faster, better, more robust;NN rendering:Monte Carlo ray tracing （光线追踪，寻找光源），paper-[SIGGRAPH17] Kernel-Predicting Convolutional Networks for Denoising Monte Carlo Renderings ( utilize CNN to predict de-noising kernels, thus enhance ray tracing rendering result);volume rendering;NN shading (real-time rendering), paper-Deep shading: Convolutional Neural Networks for Screen-space shading (2016);goal is to accelerate, all training data can be gathered virtually;NN 3D modeling:shape understanding:3D ShapeNets: A Deep Representation for Volumetric Shapes (2015).VoxNet: A 3D Convolutional Neural Network for Real-Time Object Recognition (2015).DeepPano: Deep Panoramic Representation for 3-D Shape Recognition (2015).FusionNet: 3D Object Classification Using Multiple Data Representations (2016).OctNet: Learning Deep 3D Representations at High Resolutions (2017).O-CNN: Octree-based Convolutional Neural Networks for 3D Shape Analysis (2017).Orientation-boosted voxel nets for 3D object recognition (2017).PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation (2017).shape synthesis: 3D-conv, also use GANfrom 2D to 3D, data becomes harder to handle, design of mesh representation, high-resolution 3D problem;NN visual retouching:tone mapping: paper-Deep Bilateral Learning for Real-Time Image Enhancement (2017), it can handle high-resolution images relatively fast;automatic enhancement: paper- Exposure: A white-box Photo Post-processing Framework (2017);Example-NN 3D Face:given a face RGB/RGBD still/sequence, reconstruct for each frame (intrinsic image or inverse rendering):Inner/outer camera matrix;Face 3D pose;Face shape;Face expression;Face albedo;lighting;3D face priors: shape &amp; albedo, paper-A 3D Morphable Model learnt from 10,000 faces (2016);3D face priors: expression: paper- FaceWarehouse: a 3D Facial Expression Database for Visual Computing (2012);optimization: based 3D face fitting;Coarse Net, Fine Net;3D Face-without prior: paper-DenseReg: Fully Convolutional Dense Shape Regression In-the-Wild(2017);render for CV:Synthesizing Training Data for Object Detection in Indoor Scenes, (2017);Playing for Data: Ground Truth from Computer Games (2016)Learning from Synthetic Humans (2017);demo: Face2Face, Real-Time high-fidelity facial performance capture, DenseReg;]]></content>
      <categories>
        <category>课程记录</category>
      </categories>
      <tags>
        <tag>computer vision</tag>
        <tag>deep learning</tag>
        <tag>Megvii</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-2020:漫长的告别]]></title>
    <url>%2Fposts%2FSummaryofthisyear-1%2F</url>
    <content type="text"><![CDATA[搭博客的时间大概只有一年，当初是因为受到pluskid网站和博客的影响，觉得做一个有趣的人，学习自己想了解的，放淡自己的心态是是每天很重要的事，因此想记录下来，有些规划，也好作为充实自己的见证，搁以前每年都来一个总结这件事我是不怎么做的。求学生涯没有结束，每年都是反复地上课，做项目，似乎都是浑浑噩噩度过，科研中的磕碰和一些不甘心也会时不时消磨自己的意志，让自己在怀疑，焦虑，麻木，强迫的交织中蹒跚着。我之前也知道很多励志结论，他们说的都很对，但每个人的生活总是悲喜交加的，而大多数情况下都是在平平无奇中暗生悲戚，羁绊越多的人似乎悲戚越浓。2019年的寒假里，我翻看了很多pluskid的博客内容，其中以年终总结最多。一开始我是被博主优秀的履历所吸引，后来在那些博客里我读到了对于生活细节的热爱，以及对于艺术，真理和其他人类活动的浓郁兴趣，真诚，质朴同时又很能温暖人，所以算是“始于履历，陷于才华”吧！（厚脸皮地说，有一种惺惺相惜之感）。罗曼罗兰在《米开朗琪罗传》中有句很出名的话：“Il n’ya qu’un héroïsme au monde : c’est de voir le monde tel qu’il est et de l’aimer.（世界上只有一种真正的英雄主义，那就是认识生活的真相后依然热爱它）”，我开始渐渐明白其中的血肉故事，目前虽然谈不上热爱，但可以说是慢慢从走出到走入，慢慢进入状态。接下来，我想还是先从自己的学校科研生活讲起，然后再去讲讲自己看过的书，去过的地方，听过的音乐，拍过的照片，看过的电影等，一步步勾勒出自己的故事，就像是在索拉里斯星上模拟出的记忆花园，感想估计无法给出多少，倒是想能抓住几分情绪便好。研究生科研工作2019年开始慢慢接受18年底国外读博计划失败的经历，审视自己这一个大时间段的失意，认清自己的能力和所需。前半年一半时间在慢慢恢复神志，试图理清自己后面的研究方向，还是想坚持SLAM+DL的路线。从头开始看高翔在深蓝学院的《视觉 SLAM 14讲》，看书，推公式，理解代码，再总结下来写到博客上，当然也时不时关注DL+CV相关论文的最新进展。大概是在3月底的时候，老板受人所托，给了我个在校外一家初创AI医疗研究院实习的机会，当时正好毫无头绪， 像个无头苍蝇到处乱撞，便答应下来。为了能够顺利拿到实习机会（小型团队，气氛很好。mentor是海归，前百度员工，有梦想的工作狂），开始正式去看深度学习的理论，同时也参加了一个小型的“蔚蓝杯”人工智能 竞赛（赛题是检测图片中的商品，给出商品数量），熟悉一下数据分析，pytorch掉包和调参。趁着研一上课空余时间，突击学习理论，撕撕代码，看完了Michael Nielsen(这个人好像是个物理学家，写了一本关于量子通信，量子计算机方面的书籍，最近又搞了个网站专门介绍量子通信)的nndl，魏秀参的《解析卷积神经网络》和一部分深度学习500问，本来计划接着看邱锡鹏教授的新书《神经网络与深度学习》，不过时间没赶得上就去面试了，个人感觉这些都是不错的参考资料。实习面试的时候理论问题问得比较浅，可能对方知道我是个DL新手，只有训练CNN的一些防止过拟合技巧，BP中的链式法则等等；编程题就比较惨了，题目大概是在一个包含”x”和“o”的矩阵（”o”是少量元素）中找出起始“o”和终止”o”之间的最短距离（只能顺着“o”走）。很久没撕过代码， 加上第一次工作面试有点紧张，连暴力搜索都没能写出来，场面一度十分尴尬。后来我觉得可能看在老板的面子上，还是让我过了。。。实习期是6月底到9月底，期间做的一些工作和感想我都放在了之前的博客里，认识的师兄，了解到的新知识都打开了我的思路，也培养了我一些工作习惯，锻炼了自己的代码能力，总之还是十分感谢这段实习经历的。回来之后就在准备研究生毕业开题的事情，同时也赶着实习工作总结出的论文。当然要不是因为组里小老师给的项目，也不会三个月实习期结束就回来。年初的时候想着拿深度视觉里程计开题，后来实习的时候一度打算一边实习，一边拿实习的AI医疗项目做毕设，最后，还是综合考虑答应了做小老师的项目，以此作为毕设。毕设的大致内容其实就是检测无人机，但是由于要求检测距离远，所以可能常规的Faster R-CNN等框架的检测效果可能不太好，要引入GAN和超分辨率等手段。目前最大的坑处应该是数据集的收集了，既要拍摄RGB，也要拍摄红外；既要考虑不同出现场景和环境，还要引入多形态的无人机，鸟，风筝类别，此外还得保证将近1km的拍摄距离。估计数据拍完了，毕设时间也差不多到了(&gt;_&lt;|||)。2019年的学习与科研不算太顺利，自己也经常没进入状态，算是那种没别人努力，却还时常抱怨，焦虑的人。希望2020年能加把劲，不管是工作还是继续申请读博，都得把自己整硬实起来才行啊（@_@）！探访之境今年南京之外去过的其他城市不多，大多是借着出差机会逛逛，不像本科时期年年都会找几个地方专程去看看。出走对于我来说已经成为生活中必不可少的一部分了，以为我是个很容易“习惯”的人，日常生活中的每件事都可以成为惯例，从不会厌倦，直到自己觉得到了需要进行调整或者改变的时刻。人在一个熟悉的封闭的空间里待久了，容易怀疑自己和这个世界，容易陷入空想而无所为的状态，这种感觉最能吞噬人的精神和智力。可能是我自己心浮气躁的原因，有时候会觉得内心烦闷，精气神不足，以前就任其发展，以无所事事应对，等待其消失。现在，随着这种情况出现次数的增多，我开始体会到这可能是科技异化人性和人类自身特质共同作用导致的，为了应对，我强制给自己找合适的，能辅助静下心来的事情做：“要么学习，要么运动“。其中”学习“的方式有很多种，不仅仅是科技理论知识，还可以是培养兴趣爱好，发展艺术视野和思维，出走旅游也是其中一种形式。我学校处于靠市中心的位置，离很多景区都比较近，偶尔朋友来金陵的时候便会一起去玩玩，比如夫子庙，中山陵，老门东等地方。自己平时有点累或者烦躁的时候，通常会选择傍晚围中山陵绿道或者体育公园骑一圈，或者偶尔跟朋友师兄们相约爬紫金山，逛灵谷寺看萤火虫等。一年四季，这些地方都有很多”隐秘之地“，树草虫鸣，风拂月泻，令人舒心。本科的时候有一些喜欢骑行的小伙伴，经常会约出去骑车到处逛，自从毕业读了研以后，朋友都各自纷飞，自己的圈子也越来越小，大家也都在实验室忙着各自的事。我偶尔一个人出去，也少了好几分乐趣。南京不像上海深圳，文化艺术多样性方面还是有所欠缺的，好歹有个南京博物院会时不时联合办些展览，可以饱饱眼福。2019年除了专程去看了固定的艺术馆的书画展，就是三次合作的特展：世界巨匠-意大利文艺复兴三杰；从毕加索到基弗-路德维希的艺术课；仰之弥高-二十世纪中国画大家展。前两次展品不多，毕竟大作是不太可能借过来的，最近一次的书画展规模比较大，看得也比较过瘾，将近百幅的画作看了两三个小时。世界巨匠-意大利文艺复兴三杰展览内容是文艺复兴三杰达芬奇，米开朗琪罗，拉斐尔和他们继承人的一些作品，一开始我还妄想会有“蒙娜丽莎”，实际上三个人的真迹不多，其中有一些还只是复制品。不过，能看到这样的一些合作已经很满足了(&gt;～&lt;)。拍的作品不多，有几幅是自己心水的。从毕加索到基弗一一路德维希的艺术课路德维希夫妇是非常有名的艺术收藏家，曾收集了很多毕加索的名画。这次展览也展出了毕加索的几幅真迹，比如“带鸟的步兵”等，不过鉴于规模，大部分还是我这个圈外人士不曾了解过的艺术家。画作风格上涵盖了立体主义，表现主义，抽象派，野兽派和波普艺术等，神秘，荒诞，又虚无。画作和诗歌一样，都得参照下创作背景，虽然有些艺术家可能是天赋异禀，像小松美羽，画作直接在脑海呈现，一气呵成。一千个读者，有一千个哈姆雷特，画作也是这样，那些吸引我的画，都有一种能攫住人的思绪得魅力，触发观赏者的千万感受。很抱歉我自己读书和思考比较少，鉴赏水平有限，没能做出比较完整的评价来。(+_+)仰之弥高-二十世纪中国画大家展20世纪中国画作继往开来，有种特别的魅力。南京博物院这一次的联合展览规模据说是国内之最，由于展品较多，分为上下半场，上半场在2019末尾，下半场在2020开年，我只看了上半场，就已经觉得展品数量多且质量高，2个多小时下来后意犹未尽，又去买了配套的书珍藏。国画当中，我最喜爱也是唯一爱的是山水画，尤其以写意为主，创造了与西方讲究逼真复刻思想截然不同的心境体验。齐白石挑了几张图，从左到右分别是山溪群虾图，秋荷图，松寿图，寻旧图。展出的黄宾虹作品中，狮子林望松谷园，练江南岸图，栖霞山居图，天目奇峰图，湖滨山居图，江村图，黄山记游图，九子山，练滨草堂图个人都非常喜欢，可惜手机里只翻出其中三张。徐悲鸿：双马图|侧目图|飞鹰图，愚公移山图，鹰图，山鬼图，九方皋相马图。张大千的画作想必很多人都喜欢，毕竟颇有古人风骨。下面挑出的几张是江岸图，泼墨荷花图，荷花图，仿杨昇笔意设色山水图，夏山高隐图。潘天寿：青山白云图，雄视图，雨后千山铁铸成，记写雁荡山花。林风眠，中西集合的一位画家：夜枭图，劈山救母图，早春暮色图，风景图，灰鹭图，鱼鹰小舟图。傅抱石：万竿烟雨图，待细把江山图画，兰亭修褉图，龙蟠虎踞今胜昔。李可染：苏州虎丘图，万山红遍 层林尽染，崇山茂林源远流长图，无尽江山入画图，树百重泉图。近日受到2019-ncov病毒影响，学校也不准提前到校，下半场的展览不知还能不能赶得上了。19年除南京城外，只到访过西安和成都。西安是“故地重游”，当时本科毕业时去了甘肃，正好顺路就去西安找朋友玩了趟。当时正值夏季，大西北天气炎热，白天毒辣的阳光炙烤得人很难受，不过晚上舒服，没有南京那么闷热，有些凉爽。西安的夜景确实很不错，市民们的夜生活也丰富多彩。大雁塔，大唐芙蓉园周边的柔和灯光映衬着来回的身着汉服的姑娘，恍如隔世。第一次玩那会没吃上臊子面，算是一大憾事，19年年底开会的时候正好借着机会找了一家“乡党臊子面”体验了一把一顿“几十碗”的快感。吃撑了肚子，跟朋友一起到了附近的城墙走了一圈，夜景还是像以前来那样令人惊喜。两次的西安之行，没有很长时间，达不到能够感受一个城市风格的力度。粗略的印象是面很好吃，夜景很好看，人民生活丰富也比较健谈，可惜大西北灰尘太多，空气质量差了点，嗓子实在吃不消。大学本科四年来，成都是我一直想去但没能去成的地方，要么是没钱，要么是没时间。自西安开会结束回来后，正好收到要赶去四川成都陪师兄们做oral的消息，甚是激动。4天的学术会议，只花了几个小时参加作报告就溜了，剩下的时间都和师兄，朋友们在成都吃喝玩乐闲逛了。刚下飞机的那天就跑去谭鸭血吃了火锅，和热情的成都朋友们喝得酩酊大醉，半夜回旅馆路上还看到街上人来人往，分外悠闲。尽管只有将近4天的短暂游玩，但成都却给我留下了与众不同的印象，特色美食，热情的小伙伴，悠然的生活方式，以及温润的气候让我一度不想归宁。临行的出租车司机大叔对我们说“你们年轻人不要随便来四川工作生活”，估计也是怕缓慢慵懒的生活节奏让我们丧失奋斗的意志了吧。阅读19年的阅读量比18年稍多了些，主要是在L同学的影响下，翻了很多画册或者手绘书。这些书看起来快，又不需要花时间思考，正好适合我现在的碎片阅读时间。本来今年打算着手学习一下画画，不管是什么绘画分支，得画起来才行，硬盘里也收藏了很多很多绘画教材和一些作品集，然而到现在都几乎没怎么翻过。19年让我感触最大的两本书是两部小说，一本是科幻小说，《索拉里斯星》，塔可夫斯基也曾将其拍成电影《飞向太空》；另一本是写实结构主义小说，《城市与狗》，拉美文学作品，写作方式不怎么规则，但是阅读体验很好。我在豆瓣也建了个相册存放自己有关看过的书的一些手拍照片，算是思考总结，也算是一种鞭策自己多阅读的手段吧。和空姐同居的日子是初中是很喜欢的一部广播小说，作者三十也居住在南京。内容虽然有些yy的成分，但是总体还算是清新自然，单纯美好。19年年初那会觉得心情不好，就重听了一遍，个人觉得第一部（季）质量最好，第二部可能是因为大家不喜欢第一部的结局而写出来的。现在喜马拉雅还有第一部的广播资源。线性代数的几何意义是19年年初看MIT 线性代数公开课阅读的课外材料。学过线代后看一遍会有不小的收获，也算是解释数学意义的一个体现吧，尤其是在实际工程上。给青年人的信是在自己的kindle上当作睡前读物看完的。大一时候听老师讲里尔克时心潮澎湃，专程去图书馆借了里尔克的诗集，囫囵吞枣地看完了，现在几乎对他的诗歌也没什么印象了，除了经典的几首。实际上，这本书作为枕边读物，常拿出来翻翻还是很有裨益的。里尔克写信的文字十分真诚，字里行间透露出对生活的热爱，对细节，真善美的观察和思考，不仅是对诗歌创作者，即使是对忧郁迷茫中人，也有不小的指导和振奋作用。索拉里斯星是波兰科幻作家斯塔尼斯瓦夫·莱姆的代表作，也是我目前最喜欢的科幻小说之一。它不同于一般的大格局的科幻小说，关心宇宙和人类的命运，或者讽刺人性等等，而是着眼于人的记忆和内心之中的隐秘之痛，和特德·姜的《你一生的故事》有些异曲同工之妙。这篇小说的故事内容很简单：人类在一个遥远的星系里发现了一个特别的天体，称之为索拉里斯，人类派出了空间站去探测研究这颗特别的天体，地球上还出现相关的研究学科。这颗天体本身就是一个生命体，表面几乎都被”海洋“覆盖，那些奇怪的液体可以随便被天体操作，模拟出各种形态，甚至是有自己意识的人类实体。男主到达空间站后发现几位同事都被索拉里斯星折磨得濒临崩溃，自己也随着索拉里斯星的实验慢慢揭开其中的秘密。实际上，索拉里斯星的这些实验都是处于自己对宇宙好奇的探索，空间站的人类在其面前没有任何秘密可言，包括记忆。记忆和亡妻之痛（或者说是每个人内心独有的隐秘之痛）是最近很着迷的点，总觉得它们代表着人类特有的印记，以此为内容的电影总能让我感触良多，弥漫着无法抗拒的悲痛感，像是“海边的曼彻斯特”，“登月第一人”等都可以说这种类型电影的代表。莱姆的索拉里斯星恰好也是有着这两个点，但是又不全是，书中包含着对人类道德，思想和精神世界的审视，虽然也有那种宇宙的孤独感，但是却又不全是那种冰冷的感觉。索拉里斯星上的大海，不像地球上孕育着生命，却表现出一种宇宙的隐士般的好奇，无欲，与人类触碰却又收回了手。书中有关男主的心理描写和索拉里斯星的描写都十分出色，在一定程度上缓解了阅读的枯燥。小北野武是导演北野武的童年生活记录，同时也亲自手绘了插图。北野武的真诚，诙谐，充满童趣的特点在这本书中表露无疑，以孩子天真无邪口吻说出的故事，表面让人发笑，背后实则充满辛酸之感，尤其读到最后“父亲的遗物”那里，看到北野武老爸叫菊次郎，突然觉得有点抑郁~。书里的插画我也上传到豆瓣相册了。素描的艺术：席勒这本书是我在图书馆找书时无意发现的，看到书名时翻了一下，非常惊喜，国内有关埃·贡席勒作品介绍的书籍似乎不多，这本作品集编排得很用心，就借了出来。此外，前几年有部关于他的电影埃贡·席勒：死神和少女，感兴趣可以看看。埃贡·席勒是个很有艺术天赋的艺术家，但是画作不走寻常路，人物通常瘦骨嶙峋，不符合正常规律的细长，大多都是反映内在世界得敏感，孤独，暧昧，神经质等，作品风格好像叫立体解构主义或表现主义？他也有很多自画像，评论家认为其有着明显的自恋和自我剖析倾向。作为作品集，自然文字内容会少很多，主要是不做二次加工展示给读者，让其自己去感受自己所看到的内容。书中大部分作品传到了我的豆瓣相册上。念书还是工作，这是一个问题是法国一位女博士根据自己的经历画出的漫画故事。虽然是文学博士，但是很真实了，特别是在无穷的资料和方向中不断摸索，在碰壁，消沉，以及自我安慰中挣扎，有时还不得不面对社会和家庭的一些压力……在理工科界也有一本phd博士写的书，叫”the phd grind”。读不读博这个问题，感觉好难回答，那些读过了的人和没迈进去步子的人，感觉精神上应该有很大不同吧～或许那些有心得人会在读博期间不断地审视自己吧。线条：斯坦伯格的世界是漫画家斯坦伯格的一部作品集，这也是我偶然在图书馆发现的一本书。斯坦伯格的线条漫画作品简洁机智，有的讽刺意味很强，有的妙趣横生。他也曾经为杂志”New Yorker“作过不少次封面插画，在国外知名度很高。原书收集的作品比较多，我从书里挑了一些，放在了豆瓣相册里。蓝色小药丸是一部讲述HIV携带者相爱故事的漫画，作者画风凌厉，内容却细腻感人。难以想象，这样的事会如何发生在自己身上。梁山伯与祝英台是一部似皮影戏般的绘本，当初从多抓鱼凑单买的，薄薄的一本，可以拿来收藏。蝙蝠侠：致命玩笑。在凤凰叔“Joker”资源未出来之前解渴用的。英国插画师里面介绍了10位不同风格的英伦插画师，有卡通的，也有成人暗黑的。当中有位Aubrey Beardsley(奥伯利·比亚兹莱)曾是奥斯卡·王尔德的情人，曾为其作品莎乐美绘制插图，带有日本浮世绘风格，算是这10位插画师当中风格最与众不同的一位，可惜英年早逝，20几岁就陨落了。此外，奥伯利在英国the yellow book期刊中的插画作品也非常经典，我之前还专门google找到了几期数字化的pdf，现在不知道链接存哪而去了/_\。除了奥伯利之外，Arthur Rackham(亚瑟·拉克姆)的童话插画作品也十分梦幻，甚至带有些诡异。他为《爱丽丝梦游仙境》和《安徒生童话》绘制的插画神秘阴暗，带有一丝哥特风，风格十分独特。后来我在网上搜索，希望能翻到他的数字化作品，可惜童话插画作品太多，不如奥伯利的那么好找，只好放弃。这本书的人物介绍和作品选取都很棒，但我还是没看过瘾，要是编辑能放多点图就好了。书中提到的10位插画师中我个人比较喜欢Kate Greenaway(凯特·格林纳威 )，Heath Robinson(希思·罗宾逊)，Edward Lear(爱德华·李尔)， Aubrey Beardsley(奥伯利·比亚兹莱)，John Millais(约翰·米莱斯)，Arthur Rackham(亚瑟·拉克姆)和Walter Crane(沃尔特·克莱恩)这7位，我也挑选了他们的一些作品放在豆瓣相册。素描的艺术：毕加索这本书与席勒那本同属一个系列。由于内容限制在素描，所以很多作品都是平时不常见的。这本书展示了毕加索自己平常生活中的速写，寥寥几笔，形神兼备，让我感觉比那些挂在博物馆里的大作更有温度和情感。美中不足的是，作品排列似乎没有按照一定的顺序，比较杂乱，也缺乏一定的说明。部分作品上传到了豆瓣相册。拍电影时我在想的事是日本导演是枝裕和的随笔集，交织了电影拍摄历程，人生感悟。是枝裕和导演和村上春树的随笔风格很像，真诚又细腻，谦逊又不乏思考，没任何架子，感觉与这样的人聊天不仅很舒服，而且还会获益良多。不过说来惭愧，是枝裕和的影视作品看得不多，因此这本书也就是快速翻阅般地看完了，对他的作品有些了解之后再去看这本书或许阅读体验会更好。观山海是杉泽根据《山海经》所画的异兽部分。杉泽是微博上很火的手绘古风神话鬼怪艺术家，托L同学强烈推荐，我才开始慢慢了解到此类画风的作品和艺术家。总的来说，第一次看很新鲜，色彩很美，梦幻又诡谲。但是看多了有些审美疲劳，尤其是人物的脸部造型，觉得没什么变化，可能是一种想象和代表吧。同样，我也拍了些放在豆瓣相册上。Neural Network and Deep Learning和魏秀参的卷积神经网络是当初准备实习面试补的书，写得都还可以，不过魏秀参博士那本不太适合刚入门卷积神经网络的小白看。数学之美应当属于理工科内，尤其是是计算机专业圈内久负盛名的一本书，主要是以NLP自然语言处理，搜索引擎算法等讲述一些具体数学算法在工程中的实际应用。没有研究过相关领域，作为科普读物看看。灯塔是一本讲述孤独忧伤的“畸形儿”困在灯塔几十年，渴望自由和情感的漫画故事，故事很短很有想象力，像电影分镜一般，推荐阅读。其实19年也有一部电影也叫灯塔（罗伯特·帕丁森和威廉·达福主演，导演之前的女巫我也很喜欢），不过故事截然不同，要暗黑惊悚得多，目前还没来得及看，在此不再多说啦。城市与狗算是今年读到的比较惊喜的一部小说。因为APP MONO中的一个海报特地从图书馆借来，阅读之前也并不知道是结构主义小说，刚开始的时候没有准备，确实被混乱的时间线叙述，不同的人物视角搞得有点蒙，直到第一部分一半，整体故事脉络就慢慢缕清了。后面的阅读体验极佳，略萨的对话和心理描写别具一格，画面感很强，读者自己很容易就代入进去，成为旁观者或主角，很难想象20出头的略萨就已经有如此高的写作技巧。“我曾有过二十岁，我也不同意任何人说那是最美好的年华。”这句话算是全书最无奈的最忧伤的精髓了。音乐，电影，公开课以及其他19年听的除了一般的流行歌曲之外，主要是古典和爵士。听古典是由于一方面可以培养和提升个人品味，另一方面是可以放松舒缓心情，帮助大脑思考；听爵士呢主要是之前受村上春树和伍迪·艾伦的影响，自己也很喜欢爵士乐营造出的那种氛围，那种音乐里的情感和故事性，很能激发人的想象力。目前两种类型的音乐领域我都处于泛听阶段，当然也有一些比较喜好的作曲家和演奏家等，像德彪西，萨蒂，肖斯塔科维奇，鲁宾斯坦，查里贝克，路易斯·阿姆斯特朗，Karen Souza等。接下来还会多去探索，等到了一个适合的饱和点，然后再去慢慢整理自己在这方面的喜好，同时我也在看耶鲁大学聆听音乐这门公开课，当作一个参考的鉴赏指导，希望明年总结时也能给其他想入门的人一些听的建议。观影上，19年看的总量不多，主要是当时的爆米花商业片加上一些偶尔看到的冷门片。以前都是专门找自己喜欢的口碑片来看，现在基本都是想找些没什么情感压抑的爽片，可能是19年比较劳累了吧:-}。电视剧方面倒是看了好几部韩剧，比如《春夜》，《我的鬼神大人》等，另外还有一部木村拓哉的《东京大饭店》，看完之后学做菜的热情猛地高涨起来，木村拓哉的”带货能力“是真的强:-D。美剧里由于《权力的游戏》最终季和《黑镜》第五季都让我很失望，后面就没再看其他的了。我从自己的观影记录中挑出了10佳，其中昆汀的《好莱坞往事》是最喜欢的，而且还非常喜欢前面很长时间的絮絮叨叨，后面的”曼森杀人案“高潮也是一贯的昆汀式B级风格；马丁·斯科塞斯的《爱尔兰人》也还可以，更像是一曲挽歌，满怀忧伤唏嘘之感；凤凰叔的《小丑》中规中矩，凤凰叔的表演加上剧本上的点到为止成就了这部高分片；最惊艳的当属于基努·李维斯的《John Wick 3》了，续集不失前作的水准，反而让故事中的杀手世界变得越来越丰满…好莱坞往事疾速备战小丑我失去了身体 比较意识流的一部法国动画片自卫的艺术 一部诡异黑色片，如果不是卷西，效果可能会大打折扣昨日奇迹 纪念致敬披头士乐队极速车王 改编自福特与法拉利的勒芒大赛竞争，没有落入俗套的热血，也顺带讽刺了系统和机构以及对其的反抗丧失乐园2 时隔10年的续作，一如既往的脑洞大开纽约的一个雨天 伍迪·艾伦的近作，甜茶饰演的男主彷佛就是老爷子本尊爱尔兰人戏剧方面，除了一如既往地搜寻NT Live的资源，一边也慢慢探索其他类型的舞台剧，比如音乐剧，芭蕾舞剧等，不过19年还没完整看过其中的任何一部。对于舞台剧，要想有好的观感体验，获得共情能力，是必须要去现场的，可惜资源和机会有限，能偶尔盼到一两部电子拷贝也是极好的。听公开课是19年下半年开展的一个计划，每天都拿出30min~60min的时间花在一些有意义的课程上，不管是艺术类，理工科类，不管是通识概括还是深入讲解都可能拿来学习。但是自己的自律性还不够，没能每天坚持，尤其是年末那段时间基本属于自我放纵阶段了，20年里这个计划要得严格执行点才行。梁老师的爱情课 这个是一席 万象组织的一个演讲，内容比较充实，聊的也很透彻，需要观众在课后反复思考。里面的很多价值观我是持赞同态度的，然而爱情是人类中最复杂的问题之一，感性的，理性的手段都不一定能很好处理其中的纠葛联系。这个课更多地是让我看到了爱情中一些行为背后的人性因素，权当一种拓展知识面的材料了。戏剧入门-张先 这个是在B站上发现的为数不多的国内戏剧入门公开课之一，是中央戏剧学院开设的。课程内容个人觉得不是很充足，学习体验不是很好，推荐后面Crash Course中的剧院公开课系列。Crash Course-Computer Science 看的第一门Crash Course公开课，后面准备把整个系列中自己喜欢的系列都刷一遍。这门课我看很多微信公众号都推送了，内容上确实做得很用心，字幕组翻译的也很棒。Crash Course-Philosophy 课程基本上是以提出哲学问题形式展开的，看完之后可能需要看一些书籍辅助理解（这里有一个推荐的知乎回答)，然后再去找自己感兴趣的哲学家的专著阅读。Crash Course-Theatre 这个课看了一大半了，字幕组还没翻译完，内容属于通识类，老师的讲说风格有种”学术幽默“，挺有趣，只不过东西太多，记不住，有点伤脑筋@_@。我非常频繁的找有关戏剧的东西看是因为它这种融合了人性的考察、无处不在的想象力、轮回式的角色扮演的艺术形式让我深深着迷，我越深入其中，越发现它其实探讨的是人的命运问题，通过把虚构的/非虚构的人的过去、现在、和未来展现在观众面前，让我们发现生活的真相。什么是戏剧：Percy Bysshe Shelley The Cenci, ACT1. SCENE1The highest moral purpose aimed at in the highest species of the drama, is the teaching the human heart, through its sympathies and antipathies, the knowledge of itself.亚里士多德关于悲剧的描述：An imitation of an action that is serious, complete, and of a certain magnitude; in language embellished with each kind of artistic ornament, the several kinds being found in separate parts of the play; … in the form of action, not of narrative; through pity and fear effecting the proper purgation.这些公开课在看的时候我是没有记笔记的，后来发现几乎全都忘光了，而且看的时候难免会分心走神，因此还是推荐做一些总结，加强记忆和理解，否则看公开课就成了一种形式了，起不到扩展知识面的作用。摄影捕捉笔记19年的摄影陷入了瓶颈，同时拍摄热情也大大减少了。在写这一版块之前，我翻了翻手机相册，19年的作品少得可怜，更何况在这些片子之中基本上没有满意的作品。专门出去街拍的情况几乎没有，只是有时候碰巧出去会携带下GR II，因此相机SD卡里面的照片就更糟糕了。为了寻求突破，我开始陆续看一些大师的摄影作品，而且尽量按照他们出版的摄影集的顺序看，毕竟目前还买不起纸质摄影出版物。从森山大道，到荒木经惟，再到深濑昌久，从薇薇安，罗伯特·卡帕，到罗伯特·弗兰克，再到亚历克斯·韦伯，平卡索夫，Stephen Gill，只要是有照片看出了某种意义，就会专门花时间找来看看该摄影师的作品集。下半年的时候，渐渐在B站上发现了一些“宝藏UP主 ”，他们有的将自己的作品剪成视频，有的讲解自己的拍摄心得和后期技巧，有的介绍摄影大师和他们的作品集，还有的是有了很高摄影鉴赏水平和摄影理念，直接在视频中讲解属于自己的摄影笔记，这些对我都有或多或少的帮助，非常感谢他们的分享。回到我自己的摄影作品上来，拍景的明显多于拍人的，实际上，我个人一开始是倾向于拍人的，尤其是人景交织的作品对我最具有吸引力，人的独特性会让景更加生动化，富有情感。不过慢慢地，我不再执着于此，在开始拍之前，我不应该对将要拍到的内容做任何预期的规划，我觉得那样会破坏掉我拍摄时候的“捕捉力”，尤其对是任何未知的，不可预知的细节的捕捉，这些细节不局限于任何物和人，不局限于何种情绪，何种故事，恰是由于这些细节让观者解读到了属于他们每个人的独特的世界，成就了作品的魅力。诚然，我私以为摄影理念应该会随着自己的拍摄历程的积累而不断地发生进化，这种进化可能是完善性的，也可能是转变性的，具体可能会取决于人的想象力。等到写20年总结的时候，或许自己又是另一番说法了。我挑了几张自己的图片，基本上都是19年拍的，少数几张是19年之前的。自己的作品数量不多，质量也不高，希望20年能作为一个新的起点，多多去实践和思考。结语其实我在写总结之前，一直在想该取什么题目，由于第一次这样写年终总结，很多事情拿捏不准，有点小紧张。“漫长的告别”这个名字来源于美国侦探小说家雷蒙德·钱德勒的同名小说，书里面有句经典的话是“To say goodbye is to die a little.”，不过我取这个名字没有这么重的情怀，也没有这么哀伤，我只是觉得19年让我明白了很多事情，真正地认识到”这个充满偏见的，残酷的真实的世界“和渺小的自己，所以我想以此为人生的一个分割线，整理一下，告别20多年的过去，然后继续下一段路。现在2020年已经过去一个月了，我希望这年可以：把自己未来3，4年的路明确下来，不管是读博还是工作，都希望能追求到一个满意的结果；现场看一次音乐会和戏剧或者舞台剧；好好写一篇论文；多多看书，看不同类型的书，开卷有益；坚持摄影，日常摄影；多陪陪、关心身边爱我的人；]]></content>
      <categories>
        <category>纪录与总结</category>
      </categories>
      <tags>
        <tag>computer vision</tag>
        <tag>learning</tag>
        <tag>movies</tag>
        <tag>reflection</tag>
        <tag>summary</tag>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RCNN-series-in-object-detection(续)]]></title>
    <url>%2Fposts%2FRCNNseries-2%2F</url>
    <content type="text"><![CDATA[About自Faster R-CNN后，基于深度学习的目标检测框架大致形成，且精度也较为不错。在这之后，围绕着对图像数据更深层次理解，以及根据现有结构进行改进成为了一个主流点。Speed/accuracy trade-offs for modern convolutional object detectorsobject detection in 20 years: a surveyIoU-uniform R-CNN: Breaking Through the Limitations of RPNhttps://arxiv.org/pdf/1909.02466v2.pdfR-FCNIntroduction内容有参考：blog1ContentFPNIntroductionFeature Pyramid Networks(FPN)考虑到了卷积神经网络中各个尺度特征图的作用，认为像Fast R-CNN和Faster R-CNN这样的目标检测网络只用了一个特征图去来做RoI 和搜寻proposal，不一定能很好地处理全部尺寸的物体，虽然这种方式是为了speed-acc之间的trade off。作者认为，网络越深层产出的特征图往往语义信息越高，但是位置信息比较模糊，对小目标检测来说不太好；浅层的特征图提取出来的特征都是比较低级的边缘，纹理信息，但是分辨率好，位置信息得到了保留，因此将这些特征图结合起来，充分利用到高层语义信息，同时也不丢掉位置信息，应当能很大程度上提高检测的精度和鲁棒性。博客内容有参考：FPN在CVPR的posterblog1, blog2, blog3Content为了让各个尺寸的物体都能很好的检测到，以往的工作提出了图像金字塔，利用不同大小的图像尺寸进行滑窗，到了深度学习时代，直接通过神经网络输出的高层特征图，进行对应特征上的检测分类，之后考虑到尺度问题，开始挑选网络中产出的几个level的feature map，分别进行检测，然后合并筛选给出最后的结果。FPN认为，既然检测既需要高层的特征便于分类和统筹全局观念，又需要特征图具有一定的分辨率去定位物体的图像位置，那么应该想个办法将这两个重要信息结合起来。但是在网络的前向传播中，这两者是矛盾的，低层的特征图特征抽象度不够，高层的特征图物体分辨率过低。我想，作者应该是受到当时resnet等跳级连接和FCN，U-Net等语义分割模型的启发，通过下采样提取高级特征，上采样恢复尺度，同时侧级连接补充位置信息，然后在每个上采样的特征图上进行检测来覆盖到各个物体（这一点借鉴了SSD）。如果没有每个特征图的预测，乍看就是FCN的经典结构。不过FPN的侧重点是为了结合高级语义特征和位置信息，因此加了一些额外的卷积操作，让网络在梯度下降中去focus这一点。下采样过程属于正常的网络操作，上采样时每个特征图进行2倍放大（最近邻插值），当然这个2倍是根据你的下采样倍数来的，一般都是2倍，然后侧向对应的不是直接加过来（FCN），也不是叠操作（U-Net），而且先用个$1 \times 1$卷积处理下采样的特征图（我想可能是为了，然后加在一起，最后再做个$3 \times 3$的卷积。$1 \times 1$的卷积是为了减少通道数（上采样的通道数是固定的），否则不能相加，同时我想可能也是去提取一下位置信息，$3 \times 3$的卷积是为了处理一下加在一起后的特征图的混叠效应，提取出两者的有用信息。值得一提的是，作者在论文中也说了，按照解决问题的思想，这样的金字塔形式应当是最简单的，没有加入任何其他的复杂技巧，实验效果证明效果也足够好，简单又有效。Simplicity is central to our design and we have found that our model is robust to many design choices. We have experimented with more sophisticated blocks (e.g., using multilayer residual blocks [16] as the connections) and observed marginally better results. Designing better connection modules is not the focus of this paper, so we opt for the simple design described above.实验方面，FPN主要针对RPN和Fast R-CNN进行，通过ablation study论证了FPN结构的有效性，同时结构之间的各个部件都是必要的。其中 RPN 和 Fast RCNN 分别关注的是召回率和正检率，在这里对比的指标分别为 Average Recall(AR) 和 Average Precision(AP)，分别对比了不同尺度物体检测情况。以resnet为例，不管第一次feature map的缩小（$7 \times 7$的卷积），用后面的$\left\{ C_{2}, C_{3}, C_{4}, C_{5} \right\}$。对RPN来说，只用了$C_{4}$去生成预选框，然后利用pyramid of anchor去搜区域，由于FPN已经有了多尺度的作用，因此每个上采样的特征图中，会根据其特点设置一个固定size的anchor area，anchor aspect ratio还是保持[0.5, 1, 2]不变。为了照应到RPN中的512大小的anchor，FPN实验时多加了一个特征图（在$P_{5}$上下采样2倍），对应的区域大小和特征图level分别是：$\left\{ 32^{2}, 64^{2}, 128^{2}, 256^{2}, 512^{2} \right\} \longleftrightarrow \left\{ P_{2}, P_{3}, P_{4}, P_{5}, P_{6} \right\}$，用$P$代表上采样的特征图，便于区分下采样的$C$。从设置里可以看出，大特征图里找小物体，小特征图里找大物体。实验Fast R-CNN时，固定FPN+RPN提取的proposal结果，在其中也加入FPN分别在$\left\{ P_{2}, P_{3}, P_{4}, P_{5} \right\}$中找物体做RoI Pooling，一样的，对于大尺度的RoI就用小的特征图，小尺度的RoI就用大的特征图。为了安排每个RoI Pooling尺度对应的特征图，作者给出如下公式：k=\left\lfloor k_{0}+\log _{2}(\sqrt{w h} / 224)\right\rfloor其中，224是ImageNet的标准输入尺寸，$k_{0} = 5$是基准值，代表最后一个特征图，$w, h$分别代表RoI区域（RPN+FPN给的原图的proposal）的宽和高。假设RoI大小是$112 \times 112$，那么$k=5-1=4$，就在$P_{4}$特征图上找，做RoI Pooling。一般来说proposal大小不固定，所以应该取整处理。因为resnet的Conv5也作为特征金字塔的一部分，而原先的Fast R-CNN和Faster R-CNN在RoI Pooling后面才接上Conv5继续提取特征，所以论文简单的加了两个1024维的fc层在分类器和回归器之前，代替一下原先Conv5的工作。最后在加入FPN的Faster R-CNN中进行参数共享，检测精度也得到了一定的提升。具体实验结果直接看图，不再赘述。ConclusionFPN的贡献思想在于向上采样，融合了特征信息和位置信息，而且简洁有效。在这之后，何恺明率先利用FPN实现了Mask R-CNN，一统检测和实例分割，斩获马尔奖。现在FPN也被广泛使用，成为检测的必备组件（R-FCN由于自身设计缘故，无法加入FPN）。但是，FPN设计中的上采样和侧向连接，其实主要是给小目标检测提供了帮助，因为主要是引入位置信息，然后放大特征图（实验结果也说明小目标检测精度提升多）。对于大目标来说，顶层特征图的高级语义固然重要，位置信息肯定还是没有底层特征图的多的，因此可以对一开始网络产出的浅层特征图跳级连接到顶层特征图，类似下面的结构（PANet）：RetinaNethttps://zhuanlan.zhihu.com/p/133317452Mask R-CNNSOLO: Segmenting Objects by Locationshttp://deeplearning.csail.mit.edu/instance_ross.pdf]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>computer vision</tag>
        <tag>deep learning</tag>
        <tag>object detection</tag>
        <tag>semantic segmentation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尝试远程控制Ubuntu服务器]]></title>
    <url>%2Fposts%2FcontrolLinuxserver%2F</url>
    <content type="text"><![CDATA[About暑假实习用公司的显卡的经历很舒服，所以寒假回家之前，想在教研室的工作站上搭个ssh，方便回家也可以用显卡跑网络。但是自己对这方面知识不是很了解，尤其是端口映射之类的操作，所以导致外网登陆服务器的时候折腾了一点时间，最后勉强利用ngork进行了内网穿透。。。使用过程中发现，ngork似乎有些延迟，加上scp传文件问题（我是win利用git bash登Ubuntu服务器）一直没解决，还是放弃了ssh转战了teamviewer（还是有点香的。。）ssh我安装的时候没关心密匙之类的问题，也没去修改ssh 的config文件，直接在Ubuntu 18.04上安装openssh-server就好了。在Ubuntu终端上输入：12345678910sudo apt-get updatesudo apt-get openssh-server# 启动sshsudo service ssh start# 重启sudo service ssh restart# 查看有没有启动ps -aux | grep &apos;&apos;ssh&apos;&apos;# 关闭sshsudo /etc/init.d/ssh stop然后我在windows上打开git bash，输入：-p代表端口，默认是22，如果需要修改可以去/etc/ssh/sshd_config修改（改过记得source一下生效），参考blog1和blog2。端口后面跟的是uername@ip_of_server，密码输入服务器用户名密码，如果和服务器处于一个局域网，你的windows是可以无缝登陆的。服务器的ip地址可以通过ifconfig查询。但是只能在一个局域网登陆没什么用处。。我们需要随时随地登陆服务器，这时候就需要科普一些公网，内网，端口映射等知识，看得我也有点眼花…后来我就找了个比较简单的内网穿透方法，也没有自己买服务器降低延迟啥的，基本上按照blog3的教程，去ngork下载软件，然后解压，在输入命令./ngork tcp 22，这个tcp 22默认端口22。在Forwarding一行会出现地址（0.tcp.ngrok.io ）和端口号，同样地在git bash输入即可。Teamviewer没自己买服务器做内网穿透的结果就是卡！卡！延迟让我有点受不了，而且scp一直搞不到win上来，也懒得查是不是自己命令哪里错了。当然除了上面的ngork外还可以搞个VPN，让你的电脑连上服务器所在的网，然后就可以按照最开始的方式登陆和传输了，暑假实习的公司就是这么干的，不过他们有专人维护这块，稳定性以及文件传输速度都很快。最后…..我还是转向了teamviewer，设置了固定密码。]]></content>
      <categories>
        <category>技术支持</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>ssh</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RCNN series in object detection]]></title>
    <url>%2Fposts%2FRCNNseries-1%2F</url>
    <content type="text"><![CDATA[AboutFaster R-CNN是目标检测领域中”two-stage”的代表性方法，其精度高，适应性强，兼具学术和工程价值。整个框架由于吸取了很多先前工作的经验，因此比较庞大，而且细节很多，因此需要认真研读下相关paper和Faster R-CNN的python代码。在此之前，先贴上一位博主做的“The Modern History of Object Recognition — Infographic”，其中也包括了“one-stage”的方法，不过2017年以后的没再更新了。R-CNNIntroduction内容有参考blog1和blog2。R-CNN(Rich feature hierarchies for accurate object detection and semantic segmentation)是将深度学习应用于目标检测的开山之作，以前传统的目标检测算法使用滑动窗口法依次判断所有的可能区域，在该文章中，采用selective search方法先预先提取一系列可能是物体的候选区域（foreground），之后将这些候选区域（proposals）整合成固定的大小（$227 \times 227$， 采用AlexNet）送到预训练的CNN模型上提取特征然后进行fine-tuning迁移学习，然后通过fc6和fc7层，得到了针对目标检测任务的特征向量，然后再过SVM二分类器得到物体的每个类别分数（至于为什么用了两层fc，不直接用三层fc得到softmax分数，Ross他也在论文中作了说明和实验，主要原因就是proposal的筛选更加严格点，mAP更高点），得到2K个左右proposal的所属类别之后再做非极大抑制(NMS)，去掉那些多余的框，留下局部最优的建议框，然后根据这些剩下的框再去训练20个类别（针对pascal VOC数据）的regression器，最后终于得到图像中物体的种类和矩形框坐标信息。下面对一些重点内容进行分析，同时由于是object detection based CNN开篇，所以也顺便加上评价指标等细节。评价指标IoU和APIoU(insertion of union).中文名为交并比，主要用来衡量框与框的重合程度，计算公式为$IoU=\frac{area(A \cap B)}{area(A \cup B)}$AP(Average Precision)与mAP(mean Average Precision).这是目标检测中常用的评价指标，AP代表每一类的检测精度，mAP代表所有类的整体检测精度，也就是所有类AP的平均值。AP一般是二分类问题的P-R曲线（precision-recall curve）与x轴围成的面积。accuracy（准确率）=$(TP+TN)/(TP+FP+TN+FN)$，预测对的样本/所有样本；precision（精准率）=$TP/(TP+FP)$，预测对的正样本/预测出的正样本；recall（召回率）=$TP/(TP+FN)$，预测对的正样本/真正的正样本；如何绘制PR曲线?首先将样本按照置信度从大到小排列，然后设置一个从高到低的阈值，大于该阈值的才能认定为正样本，否则为负样本，在该阈值下就能得到一组（P,R）值，阈值设的越细，点对就越多，这样连接成线就得到了P-R曲线。AP的计算一般是通过插值或者估算的方式进行的，并不是直接积分。针对Pascal VOC数据来说，2010前后有两种计算方式，现在主要是第二种，计算方法如下（Pascal VOC给出的评价文本结果是img_name+置信度+x1_lefttop+y1_lefttop+x2_rightbottom+y2_rightbottom，通过坐标计算IoU，大于0.5的认为是TP，小于等于0.5或者检测到同一个GT的多余框认为是FP，没有检测到GT认为是FN）：假设样本中有M个正样本，且每个样本都有预测的类别置信度和预测的GT（IoU大于0.5），根据置信度顺序给出各处的P-R值，画出曲线，根据样本设定[0/M, 1/M, 2/M, 3/M, …, M/M]这几个recall点，找出每个点之后最大的precision值（如果曲线不能全部遍历完则只遍历到最后出现的recall值，没有的对应点，precision做0处理），以precision为高，相邻recall点之间的距离为宽，相乘相加近似得到曲线与X轴的面积，即为AP算出所有类的AP，再做平均就得到了mAP。举个例子：我现在用训练好的Faster R-CNN测试自己的数据集，总共有三类：drone，bird，kite，最后会在results文件夹下生成三类检测的.txt文件。比如在comp4_det_test_bird.txt里面，前面几行是：12345678910111213141516171819202122njust_drone2videotest_0119 0.002 536.2 359.2 564.2 378.1njust_drone2videotest_0119 0.000 563.2 404.0 580.2 413.3njust_drone2videotest_0119 0.000 522.2 338.8 539.9 346.3njust_drone2videotest_0053 0.983 663.7 407.7 671.3 416.6njust_drone2videotest_0053 0.939 259.6 358.7 267.8 367.3njust_drone2videotest_0053 0.077 667.9 410.4 675.7 420.0njust_drone2videotest_0053 0.005 265.2 359.2 272.8 368.0njust_drone2videotest_0053 0.003 591.5 400.0 619.1 419.3njust_drone2videotest_0053 0.002 657.2 406.7 667.6 416.6njust_drone2videotest_0053 0.002 261.8 362.8 269.0 372.3njust_drone2videotest_0053 0.000 259.6 353.4 271.0 361.2njust_drone2videotest_0053 0.000 280.1 399.3 292.0 407.7njust_drone2videotest_0053 0.000 561.4 439.9 576.8 446.5njust_drone2videotest_0053 0.000 666.5 415.0 672.5 424.4njust_drone2videotest_0053 0.000 662.8 402.8 673.9 411.6njust_drone2videotest_0053 0.000 647.6 444.0 659.6 461.4njust_drone2videotest_0053 0.000 269.3 390.4 278.0 400.9njust_drone2videotest_0278 0.001 686.4 397.4 711.0 415.7njust_drone2videotest_0280 0.001 678.2 399.2 703.1 416.0njust_drone2videotest_0280 0.000 710.2 437.4 725.8 446.0njust_drone2videotest_0280 0.000 654.5 382.8 673.3 391.2njust_drone2videotest_0280 0.000 704.2 454.3 719.0 463.2之后需要对上述文本就行处理，主要是筛选检测框，比如设置置信度阈值，使用NMS等，然后根据推测的坐标和真值坐标计算IOU，大于0.5的设置框的GT为1，否则为0。值得注意的是，即使做过筛选后，最后得到的检测框还是可能误检（FP)，多检（FP，一个物体框了多个），漏检（FN），大致流程如下：首先对所有的结果按置信度排序，从高到低，然后根据坐标判断检测是否成功。排好序的坐标每一组都得和真实标注的GT进行比较计算IoU,大于0.5的认为检测成功，那么赋给他的标签就是1（TP)，否则是0(FP)，同时，每当一个GT被成功检测了，那么就会被标记，后续如果发现有其他的检测与这个GT重复，那么就把IoU最大的当作TP，其他多检的当作FP，遍历完成之后，如果存在没有匹配到的标注GT，也就是漏检，认定为FN。这样一整个流程下来就会得到TP,FP和FN。借用上头知乎链接的答案，具体讲下怎么计算AP：在筛选，NMS，比较等步骤之后，假设对于bird这一类，有如下检测结果(IoU&gt;0.5时GT=1，按照置信度排好了顺序)：12345678910111213141516171819202122BB | confidence | GT----------------------BB1 | 0.9 | 1----------------------BB2 | 0.9 | 1----------------------BB1 | 0.8 | 1----------------------BB3 | 0.7 | 0----------------------BB4 | 0.7 | 0----------------------BB5 | 0.7 | 1----------------------BB6 | 0.7 | 0----------------------BB7 | 0.7 | 0----------------------BB8 | 0.7 | 1----------------------BB9 | 0.7 | 1----------------------其中BB代表bounding box，其中两个BB1代表一个物体被框了两次，则应属于FP，因此在计算的时候要注意，虽然给出的GT是1，此外还有两个bird没有被检测出来，那么属于FN，整体上实际是正样本的有5+2=7个。现在从上到下以此按置信度大小计算（recall,precison）点对。（$recall \in [0/7, 1/7, 2/7, 3/7, 4/7, 5/7, 6/7, 7/7]) $1.首行以下认为预测值全为0，则TP=1(BB1)，BB2,BB5,BB8,BB9实际是1，但是预测为0，所以FN=4+2=6(两个漏检的)，FP=0，所以recall=1/(1+6)=0.14,precision=1/(1+0)=1.00;2.第二行一下认为预测值全为0，则TP=2(BB1,BB2),BB5,BB8,BB9实际是1，但是预测0，所以FN=3+2=5,FP=0，所以recall=2/(2+5)=0.29,precision=2/(2+0)=1.00;3.第三行一下认为预测值全为0，则TP=2(BB1,BB2,BB1为多余的，算FP)，BB5,BB8,BB9实际是1，但是预测是0，所以FN=3+2=5,FP=1,所以recall=2/(2+5)=0.29,precision=2/(2+1)=0.67;4.第四行以下认为预测值全为0，则TP=2(BB1,BB2),BB5,BB8,BB9实际是1，但是预测是0，所以FN=3+2=5,BB3实际为0，预测为1，BB1多检一个，所以FP=2，则recall=2/(2+5)=0.29,precision=2/(2+2)=0.50;5.第五行以下认为预测值全为0，则TP=2,FN=5,FP=3,所以recall=2/(2+5)=0.29,precision=2/(2+3)=0.40;6.第六行以下认为预测值全为0，则TP=3,FN=4,FP=3,所以recall=3/(3+4)=0.43,precision=3/(3+3)=0.50;7.第七行以下认为预测值全为0，则TP=3,FN=4,FP=4,所以recall=3/(3+4)=0.43,precision=3/(3+4)=0.43;8.第八行以下认为预测值全为0，则TP=3,FN=4,FP=5,所以recall=3/(3+4)=0.43,precision=3/(3+5)=0.38;9.第九行以下认为预测值全为0，则TP=4,FN=3,FP=5,所以recall=4/(4+3)=0.57,precision=4/(4+5)=0.44;10.第十行以下认为预测值全为0，则TP=5,FN=2,FP=5,所以recall=5/(5+2)=0.71,precision=5/(5+5)=0.50接着根据每个不同的recall值去找对应的最大的precision值，即：1234567recall&gt;=0.00,precision_max=1.00recall&gt;=0.14,precision_max=1.00;recall&gt;=0.29,precision_max=1.00;recall&gt;=0.43,precision_max=0.50;recall&gt;=0.57,precision_max=0.50;recall&gt;=0.71,precision_max=0.50;recall&gt;=1.00,precision_max=0.00;则AP=(0.14-0) \times 1 + (0.29-0.14) \times 1 + (0.43-0.29) \times 0.5 + \\ (0.57-0.43) \times 0.5 + (0.71-0.57) \times 0.5 + (1-0.71) \times 0 = 0.50实际上，这就是在P-R曲线上找出一些特定的recall点，然后利用多个矩形的面积和来近似代替曲线与X轴围成的面积。如果是VOC2010之前，recall值的选取是固定的，即$recall \in [0, 0.1, 0.2, …, 1]$，对应的最大precision为1，1，1，0.5，0.5，0.5，0.5，0.5，0，0，0，此时AP的计算公式是11个precision的和的平均值，为0.5。在COCO数据集中，IoU要求在[0,5, 0.95]区间每隔0.05取一次作为正样本判断阈值，然后计算出10个类似Pascal VOC的mAP，然后再做平均，作为最后的AP。COCO并不将AP和mAP做区分，COCO中的AP@0.5等同于Pascal中的mAP。AP是衡量检测器性能的一个综合指标，但是对于你的数据集，可能并不是最适合的，因为有的数据场景认为误检几个影响不大，主要是都能检测出来，那么这时候recall值就大点好；有的数据场景呢，认为漏检几个没问题，但是不能检测错了，那么precision大点好。而AP是对recall和precision做了一个整体的评估，是检测器对数据普遍场景下的检测性能的打分。后续的一些研究工作发现了此评价指标在一些场景下水土不服，以及没有考虑具体物体检测的置信度得分情况而导致泛化能力失衡的情况，并对此做了一些改进，有兴趣的可以阅读下南京旷视研究院的两篇博文做个大概的了解。（blog1, blog2）ContentRegion prposals—Selective Search(paper, blog,code).最开始的阶段，算法要通过该方法提取出每张图像上存在物体的可能区域，即建议框，每张图片大概会提取2k左右。Selective Search算法属于经典计算机视觉范畴，主要是利用不同的尺度（颜色，纹理，大小等），采用图像分割，层次算法等，先分割成小区域，然后通过颜色直方图相近（颜色相似），梯度直方图相近（纹理相似）等规则合并，得到最终的proposals，由于这个方法严重限制了整体框架的速度，而且后面也被Faster R-CNN中的RPN取代，因此我也没有兴趣深究，感兴趣的读者可以通过原论文和代码进一步了解。CNN feature extraction.利用selective search得到的预选框由于大小不一，不方便过卷积层后reshape成统一维度的矩阵，因此需要进行resize等预处理。变形操作方面主要就是拉伸和填充的组合。如下图所示，(A)是原图，(B)，(C)是各向同性变形，(D)是各项异性变形。(B)考虑了proposal周围的纹理内容（context），利用其扩充到$227 \times 227$，如果遇到了图像边界就利用proposal的像素均值填充；(C)不考虑proposal周围的像素信息，直接用其像素均值填充到$227 \times 227$；(D)是直接对proposal resize到$227 \times 227$，不过在此之前先进行padding处理，padding的尺寸分别为0和16，像素值为proposal的像素均值。论文给出的结论是padding=16加各向异性缩放的效果最好。网络层面，R-CNN选用了Alexnet和VGG这两个网络，由于VGG采用了更小的卷积核和小的stride，因此最后的检测mAP也更高。在训练方面，R-CNN利用的是在ILSVC数据集上的预训练分类模型，等于是进行了较好的初始化，有了一个比较通用的特征提取器，然后在Pascal VOC这样的小数据集上进行fine-tuning，这样的迁移学习也算当时的一个contribution，但是现在来看已经属于比较正常的操作了。以Alexnet为例，proposal经过其中的5个卷积层之后，得到的是$6 \times 6 \times 256$的特征图矩阵，再经过fc6和fc7之后得到了4096个神经元，最后再经过一个有21个神经元的fc，即分类数，最终得到了适合该数据样本的分类器（和GT的IOU大于0.5的那些proposals都会标为正样本，否则为负样本）,但是并不能准确预测位置。SVM classification.一般来说，根据图像分类的操作，都是将最后的全连接层改成需要分类个数的神经元，因此针对Pascal VOC来说，可以将最后的fc进行softmax，但是R-CNN却在fc7后面加了个SVM分类器，是什么原因导致这样做精度更高呢？根据论文的说法，Ross在微调CNN的时候，和GT的IOU大于0.5的那些proposals都会标为正样本，否则为负样本，这样的话对bndbox的限制非常宽松，也就是说监督信息不是严格有效的，因为CNN对小样本容易过拟合，因此这样的操作只是为了微调网络，尤其是最后的fc6和fc7，使其能够得到针对Pascal VOC数据的分类特征。采用SVM是因为SVM适用于少样本训练，而且由于是最后的分类，所以IOU的阈值设定也比较严格，目的是为了提供尽量正确的监督信息（GT为正样本，IOU小于0.3的负样本，这个0.3也是调参试出来的）。SVM分类器（可以与sigmoid函数结合，进行概率输出，在scikit-learn package中的SVM函数可以直接输出概率，理解SVM）其实就是$4096 \times N$的权值矩阵，最后得到了每类的置信值，这样就得到了类别结果。此外还需注意的是，由于GT只有一个，而IOU小于0.3的proposal可能会有很多，这样就导致了训练SVM分类器的时候正负样本不均衡，论文中也提到，SVM的负样本是经过hard negative mining筛选的（负样本的处理是object detection中的一个技术细节和难点），具体怎么做的，我没有继续深究，我准备在Ross的下一篇文章“OHEM”进行梳理。NMS非极大值抑制。SVM分类器输出的是2k个proposal的类别置信矩阵，后面需要对每一类做NMS处理，去除掉无用的proposals，留下最接近的proposals（一个物体可能被selective search提取出了很多类似的proposals）。具体步骤如下：假设是2000个proposals，然后是21类（加一个background），那么一张图片最后过SVM得到了一个$2000 \times 21$的矩阵，每一列代表这2k个proposals的每个类别的置信度，那么：1.对此矩阵按列按从大到小的顺序排列；2.对每列，先选取该列最大的那么proposal，然后与该列后面每个得分对应的proposals计算IoU,如果大于设定阈值，则剔除该proposal，否则认定是这张图片存在该类别的多个物体；3.对这一列剩下的次大的proposal进行2的操作，并不断重复，直到该列遍历完；4.对21列（所有类）进行步骤2，3的操作经过NMS之后，就可以得到位置比较准确且类别置信度较高的一些proposals。Bounding box regression.分类完成并且NMS之后需要对proposals的位置进行精修，因为selective search得到的proposal并不是精确的目标检测器，因此还需要对物体的位置做进一步的修正。a).如何设计回归？首先是挑选与GT比较接近的proposal（框）进行回归，如果差的太远，是没办法进行学习的。其次也不是直接回归矩形框的四个坐标，而是学习一种框的变换，即从检测框到GT的平移和缩放，这样的话会使网络学习比较稳定，直接回归无规律的坐标可能导致网络不稳定。如下图所示，P代表送入网络的region proposal，G是标注的GT，$\hat{G}$是学习过后的regression模型预测出的更接近GT的bounding box。其中$P=(P_{x},P_{y},P_{w},P_{h}), G=(G_{x},G_{y},G_{w},G_{h}), \hat{G}=(\hat{G_{x}},\hat{G_{y}},\hat{G_{w}},\hat{G_{h}})$，下标$x,y$代表矩形框中心坐标，$w,h$代表矩形框的宽和高。$d_{x}(P),d_{y}(P)$为待学习的平移变换，$d_{w}(P),d_{h}(P)$为待学习的缩放变换，即：\begin{array}{l}{\hat{G}_{x}=P_{w} d_{x}(P)+P_{x}} \\ {\hat{G}_{y}=P_{h} d_{y}(P)+P_{y}} \\ {\hat{G}_{w}=P_{w} \exp \left(d_{w}(P)\right)} \\ {\hat{G}_{h}=P_{h} \exp \left(d_{h}(P)\right)}\end{array}(这里缩放变换用了exp可能还是因为网络回归小的值容易些，变化大的值不稳定）P实际上代表着proposal的信息，因为是对proposal进行修正，因此在回归学习时候，都可以看作是Alexnet最后一个pool层的线性函数，目的是学习对最后的feature map使其可以变换到真值附近的变换组合，即：d_{*}(P), *=x, y, w, hd_{\star}(P)=\mathbf{w}_{\star}^{\mathrm{T}} \boldsymbol{\phi}_{5}(P)Loss = \underset{\hat{\mathbf{w}}_{\star}}{\operatorname{argmin}} \sum_{i}^{N}\left(t_{\star}^{i}-\hat{\mathbf{w}}_{\star}^{\mathrm{T}} \boldsymbol{\phi}_{5}\left(P^{i}\right)\right)^{2}+\lambda\left\|\hat{\mathbf{w}}_{\star}\right\|^{2}$\mathbf{w}_{\star}^{\mathrm{T}}$就是要间接梯度下降学习的参数，$\boldsymbol{\phi}_{5}(P)$代表最后pool层出来的结果，$\lambda$是正则项系数，防止过拟合，在论文中Ross提到这个参数很关键，否则效果不好，论文中设的值是1000。$t_{\star}$是要去学习的准确的变换，即从P到G的变换：\begin{aligned} t_{x} &=\left(G_{x}-P_{x}\right) / P_{w} \\ t_{y} &=\left(G_{y}-P_{y}\right) / P_{h} \\ t_{w} &=\log \left(G_{w} / P_{w}\right) \\ t_{h} &=\log \left(G_{h} / P_{h}\right) \end{aligned}b).怎么训练？为了回归器有效训练，每类样本只采取与GT之间IoU最大的且大于0.6的region proposal，输入的是P和G的坐标信息，以及Alexnet的$pool_{5}$层特征，然后根据loss函数对每一类单独训练回归器。Discussion1.虽然整体繁琐，占用内存大，速度也慢，但是技术框架和细节为后面的改进工作奠定了整体基础，具有开创意义；2.论文写得非常详实，没有难懂的地方和句子，通读以后对其工作和贡献了解得很清楚；3.考虑问题很全面，实验的各个因素都考虑到了，而且做了很多对比试验（Ablation Study），让人信服，有理有据。Ross的写作技巧和框架对自己写论文有很大的借鉴意义。4.Ross论文中的推荐的object detection errors analysis ，进一步了解目标检测的错误分析。SPPNetIntroduction内容有参考blog1和blog2。何恺明在ICCV2015上作的tutorial，Convolutional Feature Maps —Elements of efficient (and accurate) CNN-based object detection，讲解了SPPNet的一些内容，同时对比了R-CNN, Fast R-CNN和Fsater R-CNN。SPPNet是在R-CNN的基础上进一步提高目标检测的速度和精度。何恺明等作者认为，R-CNN每次都要将Selective Search提取出的2k左右的region proposals进行crop和warp，然后分别过卷积这样的操作太费时间而且可能做了很多重复的计算，因此他们认为可不可以直接将full image过一次卷积网络，然后在feature map进行操作，毕竟图像的特征在卷积提取之后都是一样的，由此SPPNet应运而生。SPPNet的好处是速度得到了大幅提升，而且简化了部分操作，但是随之而来的问题是：region proposal的大小不一，但是conv之后的fc层是固定的向量长度，怎么去适应？解决这个固定尺度的问题后，那么怎么找region proposal对应的feature map区域？对于第一个问题，SPPNet提出了spatial pyramid pooling（SPP, 空间金字塔池化），通过多次pooling输出不同尺度（预设好尺寸）的特征图并进行concatenate叠操作（类似U-Net），得到了固定长度的特征向量，这也是该论文的主要contribution；对于第二个问题，SPPNet通过简化receptive field和对应中心坐标计算，来近似得到region proposal图像的top-left, right-bottom坐标对应在最后feature map上的坐标，从而确定区域。ContentSPP空间金字塔池化不同的regional proposal对应的feature map区域尺寸看成一个个不同尺寸的小feature map，然后在该map上做几次不同的maxpooling，得到尺度依次变小的特征图，不改变channel数，然后将这些不同尺度的金字塔特征图reshape成一维的向量，然后合并在一起形成固定维度的fc层。由于特征金字塔的尺度是预设的，所以不管region proposal或者image的尺寸如何，都不会影响最后的分类。此外，由于可以tolerate multi-scale，论文也采用了多尺度的图像去训练，并做了实验，结果也证明确实比单一尺度要好。We develop a simple multi-size training method. For a single network to accept variable input sizes, we approximate it by multiple networks that share all parameters, while each of these networks is trained using a fixed input size. In each epoch we train the network with a given input size, and switch to another input size for the next epoch. Experiments show that this multi-size training converges just as the traditional single-size training, and leads to better testing accuracy.Note that the above single/multi-size solutions are for training only. At the testing stage, it is straightforward to apply SPP-net on images of any sizesSPP is better than no-spp, and full-image representation is better than cropregion proposal 映射在进行SPP之前，网络需要知道最后卷出来的feature map中哪些部分和最初Selective Search得到的原始region proposal是对应的。论文对此方法的解释比较简略，只在附录最后做了提及，估计也是个工程性，实验性的处理。其大致思路前面也已经说过，就是找左上和右下的对应点，而这种对应的映射关系主要由网络的感受野（receptive field）决定。感受野The receptive field is defined as the region in the input space that a particular CNN’s feature is looking at (i.e. be affected by)简而言之，感受野就是当前你的特征图上的像素点对应的是前面特征图的哪些部分区域（这个点是从多少视野中抽象出来的），这个区域一般是矩形大小的。对应分类来说，一般网络越深、感受野越大越好（高层语义信息越准确），对于目标检测，如果感受野太大，那么小目标的信息可能丢失，因此需要针对具体的任务去分析调节。对于卷积之后特征图大小计算，感受野概念和推导来源，可以参考下面的references，我在之后的内容中就直接给出公式和结论了。卷积神经网络(CNN)简介卷积神经网络的感受野A guide to receptive field arithmetic for Convolutional Neural Networks—需要梯子感受野网页计算器A guide to convolution arithmetic for deep learning假设特征图是正方形的，特征图尺寸是$F$，感受野尺寸是$RF$，卷积核kernel_size是$k$，步长stride是$s$，填充padding大小是$p$，感受野中心坐标为$C$，下标$i$代表从上到下的顺序标号，则：经过一次卷积后特征图大小变为（向下取整，比如22.5取22）：F_{i+1} = \lfloor (F_{i}+2p_{i}-k_{i}) / s_{i} \rfloor + 1当前特征图的像素点对应上一特征图的感受野尺寸是（根据上面的公式逆推，下标意义不完全准确）：RF_{i}=(RF_{i+1}-1) * s_{i} + k _{i}当前特征图在上一个特征图的感受野大小就是卷积核大小，即$k$。感受野计算一般不加padding，因为感受野是指在原图上的感受野，与填充无关，虽然逆推公式时候padding会有影响，但是将其忽略然后近似计算。如果要计算最后特征图在原图上的感受野，依次递归即可。123456789101112131415161718192021222324252627举个例子：原图输入||k1=3, s1=2;||特征图1||k2=3, s2=2;||特征图2||k3=3, s3=1;||特征图3||特征图3在原图上的感受野尺寸是多大？特征图3在特征图2上的感受野就是卷积核大小，即3；特征图3在特征图1上的感受野尺寸：(3-1)*2+3=7;特征图3在原图上的感受野尺寸：(7-1)*2+3=15;特征图像素点对应上一个特征图的感受野中心坐标：C_{i}=s_{i} * C_{i+1} + ((k_{i}-1)/2-p_{i})这时候要考虑padding，因为坐标有影响。尺寸加上坐标就可以定位region proposal在特征图与特征图之间的映射关系。NIPS 2016的论文Understanding the Effective Receptive Field in Deep Convolutional Neural Networks提出了有效感受野的概念，也就是说感受野内部的每个像素的作用和贡献不是相同的，有效感受野仅占理论感受野的一部分，一般中心较多，属高斯分布影响。上图是何恺明简化的计算中心点的公式，也就是计算region proposal左上和右下坐标点的方法。设$p_{i} = \lfloor (k_{i} /2) \rfloor$，当$k_{i}$为奇数时，$p_{i}=(k_{i}-1)/2$，则$C_{i}=s_{i}\times C_{i+1}$；当$k_{i+1}$为偶数时，$p_{i}=k_{i}/2$，则$C_{i}=s_{i}\times C_{i+1}-0.5$，由于坐标取的都是整数，所以近似认为$C_{i}=s_{i} \times C_{i+1}$，也就是说感受野的中心坐标只跟步长以及后面的中心坐标有关，因此通过这种关系一步一步将原图的region proposal坐标映射到feature map上。另外，可能考虑到近似处理的原因，论文最后对映射到feature map上的坐标值做了进一步处理：左上坐标值：$x^{‘}=\lfloor x/s \rfloor + 1, y^{‘} = \lfloor y/s \rfloor + 1$；右下坐标值：$x^{‘}=\lfloor x/s \rfloor - 1, y^{‘} = \lfloor y/s \rfloor - 1$；也就是说，把区域缩小一点（左上点下移，右下点上移），应该是何恺明考虑到最后feature map上的点计算感受野映射回去的时候扩大了区域，所以做了一个这么经验化的处理。最后总结一下SPP方法，通过原图region proposal的左上和右下坐标，分别以各自作为中心坐标扩展出感受野大小的区域，然后映射到feature map上，找到对应的像素点，这样就定位出了原图region proposal对应的特征，然后对该特征进行预设金字塔尺寸的池化，最后对不同的特征图reshape，“叠”在一起给fc层，进行分类。Fast R-CNNIntroduction内容有参考：blog1, blog2, blog3-RoI poolingRoss Girshick在ICCV 2015上对自己论文的讲解，在他的个人主页可以找到slideFast R-CNN吸收了SPPNet的优点，并针对R-CNN冗余的的多推理结构，以及带来的占用内存资源多，推理速度慢的问题进行了改进，采用shared computation和mutli-task learning将整个流程（原始图像region proposal提取除外）合在了一个网络中，最终使得推理速度得到了显著提升，占用内存减小，训练也更加容易便捷。R-CNN的问题分阶段训练，多个步骤，首先是softmax分类网络，然后时linear SVM分类器，最后是bounding-box regression，而且每个阶段的训练样本都得按照各自的规则重新选取；训练时间很长（84h），region proposals 要一个个地进行resize，然后一个个送进网络，占用大量硬盘空间；训练好的结构推理时间长（利用vgg16 backbone一张图片47s）；SPPNet的问题SPP进行了图像级别的计算共享，只需在最后的feature map上进行region-wise computation计算，加速了推理时间。但是由于SPPNet的其他部分完全照搬R-CNN，所以也存在训练繁琐，训练时间长，占用磁盘空间大的问题。此外，Ross认为，SPPNet引入了一个新的问题：在训练时，SPP layer以下的卷积层等layer的参数无法更新。其原因主要跟mini-batch sample样本的策略有关，Ross也在其ICCV 2015的oral中解释了。SPPNet在训练时，一个batch随机采样128个regional proposal，这样的话样本有很大概率是来自于不同的图片，特征图上的一个proposal对应到原图上的感受野通常很大，最坏的情况是感受野是整个图像，那么每个batch可能就要去计算很多个几乎是整幅图像的梯度，而且不同图像间不能共享卷积计算和内容，反向传播会很慢且很耗内存。Fast R-CNN的优缺点单个网络训练，占用内存少；推理速度快，精度更高；region proposal依然耗时；Content如上图，Fast R-CNN的推理流程如下：输入任意size的图片和Selective Search产生的region proposals；原图经过一系列卷积层得到最终的特征图，并根据原region proposal找到feature map上的对应特征区域；对特征区域进行RoI pooling，得到固定大小的特征图，并经过fc层得到固定大小的特征向量（可由SVD分解加速推理）；特征向量继续向后传递产生两个branch，一个用softmax估计region proposal的类别（N+1个神经元），另一个回归bounding-box的平移和伸缩变换系数（4个神经元）；最后利用NMS剔除多余的框。RoI poolingRoI pooling是特殊的SPP，因为只有一个尺度的pooling，目的是为了不同尺寸的region proposal产生固定size的输出，兼容后面的fc层。论文中提到使用多尺度pooling对精度会有较小的提升，但是会带来成倍的计算量，所以只用单尺度是一种trade-off。此外RoI pooling的网格尺寸是自适应的，利用原proposal大小和期望输出的大小进行计算。由于RoI pooling采用max pooling，是可微分的，用于BP进行反向传播更新参数。但是由于一幅图像中不同proposal之间内容会有重叠，所以特征图上一个比较大的值可能出现在不同的pooling后的proposal上，因此论文提出直接将其相加。one-stage training—SGD &amp; multi-task loss如前所述，如果采取SPPNet mini-batch sample样本的方式，梯度计算会很慢，将会很难训练网络。Fast R-CNN采用了向同幅图片随机采多个region proposals（hierarchical sampling）来加快梯度计算和传递：先随机采两幅图片，然后从这两幅图像中分别再各自采取64（128/2）个proposals，这样的话感受野会有很大重叠，梯度计算就不会很慢，占用内存也不会太大。但是Ross认为这种方式可能会导致网络收敛很慢，因为proposals很多都是相关的，不过实际中并没有出现这个问题。分类损失函数：$L_{c l s}(p, u)=-\log p_{u}$，依然是交叉熵，分类采用softmax，未继续采用svm，实验证明采用前者精度更高，原因可能是因为多任务学习以及RoI pooling的作用。回归损失函数不再是平方损失函数，而换成了$smooth_{L1}$损失函数：L_{l o c}\left(t^{u}, v\right)=\sum_{i \in\{x, y, w, h\}} \operatorname{smooth}_{L_{1}}\left(t_{i}^{u}-v_{i}\right)\operatorname{smooth}_{L_{1}}(x)=\left\{\begin{array}{ll}{0.5 x^{2},} & {|x|]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>computer vision</tag>
        <tag>deep learning</tag>
        <tag>object detection</tag>
        <tag>semantic segmentation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FutureMapping2]]></title>
    <url>%2Fposts%2FFutureMappingofAJD-2%2F</url>
    <content type="text"><![CDATA[About继第一篇FutureMapping之后，视觉SLAM领域内的奠基者Andrew Davison最近又将他的和别人讨论的有关未来空间AI对地图构建，机器人协同定位，以及动态问题等新想法撰写成了新的论文FutureMapping2，置顶在了自己的推特上，表示欢迎大家交流自己的想法。总的来说，这篇文章干货还算是很多的，主要是着眼于factor graph（因子图）和Gaussian Belief Propagation（GBP，高斯置信传播）对整体，动态机器人建图等问题的潜力和前景，不仅在数学上进行一些tutorial，还给出了三个python demos。由于我对视觉SLAM只是了解整体特点，其中各种计算细节和优化方法并没有认真看过和代码书写过，因此读完这篇充满amazing reflections的文章之后我只能把握到整体的idea和一些实现方法。对于GBP和factor graph 结合构建的数学模型，我将在后续花时间弄懂后再对该blog进行补充。非常建议对SLAM或者机器视觉领域感兴趣的同行阅读此论文，相信会帮助您开阔思路！ContentIdeaAbstract: We argue the case for Gaussian Belief Propagation (GBP) as a strong algorithmic framework for the distributed, generic and incremental probabilistic estimation we need in Spatial AI as we aim at high performance smart robots and devices which operate within the constraints of real products. Processor hardware is changing rapidly, and GBP has the right character to take advantage of highly distributed processing and storage while estimating global quantities, as well as great flexibility. We present a detailed tutorial on GBP, relating to the standard factor graph formulation used in robotics and computer vision, and give several simulation examples with code which demonstrate its properties.关键词：分布式，边缘计算，局部估计，GBP，因子图，概率模型（边缘计算，分布式的，局部计算和存储，整体计算和构建以一种‘graph’的方式展开）首先，背景是现在的spatial AI系统要试着处理异质的数据，通过不同的估计手段将其转换成一致性的表示方式，但是这受限于现在的处理器性能（实时，持续地处理带来计算负担，存储负担和转换负担）。Andrew认为目前有两种方式可以对此进行提升：One is to focus on scene representation, and to find new parameterisations of world models which allow high quality scene models to be built and maintained much more efficiently. 这是表征方式的问题，这也是学术界都在解决的问题，representation learning. 机器人，计算机如何利用自己的硬件特点来认识和表征周围的世界，这跟人认识世界不一定是一样的。The other is to look towards the changing landscape in computing and sensing hardware. 另一个就是硬件设计，比如现在视觉SLAM中的“event camera”，利用事件来记录。这里Andrew也推荐了ETH苏黎世联邦理工大学 J. Martel的phD thesis，传送门硬件问题上，Andrew并没有说太多，大都还是一些常见的设想，在后续的section中，Andrew主要是是针对第一点来说的。The purest representation of the knowledge in a Spatial AI problem is the factor graph itself, rather than probability distributions derived from it, which will always have to be stored with some approximation. What we are really seeking is an algorithm which implements Spatial AI in a distributed way on a computational resource like a graph processor, by storing the factor graph as the master representation and operating on it in place using local computation and message passing to implement estimation of variables as needed but taking account of global influence.(有关因子图的资料，推荐Factor Graphs for Robot Perception， 关于高斯置信传播，Andrew是根据bishop的PRML一书来的，此外他在文中推荐的是比较老的参考文献Factor Graphs and the Sum-Product Algorithm，我自己也在网上发现了一篇伯希来大学的phD论文 Gaussian Belief Propagation: Theory and Application ，希望对后续理解有所帮助。）Andrew认为可以通过因子图来进行局部估计，进行边缘计算，然后进行信息传递，通过这种方法来构建分布式和全局上的计算，从而达到认知和执行任务的目的。—-to be continuedMathematics modelsfactor graphGBPExamples]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>mapping</tag>
        <tag>AI system</tag>
        <tag>computer vision</tag>
        <tag>hardware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习痰涂片项目总结]]></title>
    <url>%2Fposts%2Fworksummaryofintern%2F</url>
    <content type="text"><![CDATA[classification在上篇博客提到，该任务就是将原始数据的每张图片（256x256）进行grid级别的label预测，思路很简单，就是最后卷出的feature map是4x4的，不要过average global pooling layer，直接拉成1x16的向量过sigmoid激活函数即可（label也要变成16个字符，有点类似OCR)。dataset原始数据给的标注是json格式的框标注，但是框不是杆菌的具体位置，而是代表这个grid里面存在杆菌：1&quot;frames&quot;:&#123;&quot;0_grid.png&quot;:[&#123;&quot;x1&quot;:162.42542787286064,&quot;y1&quot;:25.34963325183374,&quot;x2&quot;:170.24938875305622,&quot;y2&quot;:34.11246943765281,&quot;width&quot;:256,&quot;height&quot;:256,&quot;box&quot;:&#123;&quot;x1&quot;:162.42542787286064,&quot;y1&quot;:25.34963325183374,&quot;x2&quot;:170.24938875305622,&quot;y2&quot;:34.11246943765281&#125;,&quot;UID&quot;:&quot;fd548124&quot;,&quot;id&quot;:0,&quot;type&quot;:&quot;Rectangle&quot;,&quot;tags&quot;:[&quot;TB01&quot;],&quot;name&quot;:1&#125;,&#123;&quot;x1&quot;:214.3765281173594,&quot;y1&quot;:24.410757946210268,&quot;x2&quot;:224.07823960880197,&quot;y2&quot;:34.11246943765281,&quot;width&quot;:256,&quot;height&quot;:256,&quot;box&quot;:&#123;&quot;x1&quot;:214.3765281173594,&quot;y1&quot;:24.410757946210268,&quot;x2&quot;:224.07823960880197,&quot;y2&quot;:34.11246943765281&#125;,&quot;UID&quot;:&quot;5318dd81&quot;,&quot;id&quot;:1,&quot;type&quot;:&quot;Rectangle&quot;,&quot;tags&quot;:[&quot;TB01&quot;],&quot;name&quot;:2&#125;,...&#125;部分标注内容如上，主要包含了对应的文件夹下有哪些图片，图片上有无杆菌，杆菌的位置在哪个格子（要自己判断），以及一张图片有杆菌的话共有几个（”name”）。首先找出哪些是positive的图片，并且根据坐标位置写出标签:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def find_write_positive_imgs(src_json_path, src_imgs_path, dst_csv_path, dst_imgs_path): data_csv = open(dst_csv_path, &apos;a+&apos;, newline=&apos;&apos;) csv_writer = csv.writer(data_csv) csv_writer.writerow([&quot;ImageName&quot;, &quot;LabelId&quot;]) with open(src_json_path,&apos;r&apos;) as load_json: load_dict = json.load(load_json) img_names = load_dict[&apos;visitedFrames&apos;] for img_name in img_names: #n_name represents the boxes quantities of the img &lt;&quot;name&quot; attribute in .json file&gt; n_name=len(load_dict[&apos;frames&apos;][img_name]) if n_name &gt; 0: src_img_path = os.path.join(src_imgs_path, img_name) img = cv2.imread(src_img_path) H = img.shape[0] W = img.shape[1] dst_img_path = os.path.join(dst_imgs_path, img_name.replace(&apos;.png&apos;, &apos;_22.png&apos;)) cv2.imwrite(dst_img_path, img) labelid = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] for i in range(0,n_name): x1 = load_dict[&apos;frames&apos;][img_name][i][&apos;x1&apos;] y1 = load_dict[&apos;frames&apos;][img_name][i][&apos;y1&apos;] area_h0 = 0 area_w0 = 0 for area_h1 in range(H//4, H+1, H//4): if y1 &gt; area_h0 and y1 &lt; area_h1: row_id = (area_h1 * 4 / H) - 1 for area_w1 in range(W//4, W+1, W//4): if x1 &gt; area_w0 and x1 &lt; area_w1: col_id = (area_w1 * 4 / W) - 1 id = int(col_id + 4 * row_id) labelid[id] = 1 break else: area_w0 = area_w1 break else: area_h0 = area_h1 csv_writer.writerow([img_name.replace(&apos;.png&apos;, &apos;_22.png&apos;), &apos;&apos;.join(str(k) for k in labelid)])此外，由于最后找出的positive图片很少（好像只有320张），我又对其进行了数据扩增，先是原始旋转一圈，然后right-left翻转后又旋转了一圈，因此总共扩增到了8倍大小。之后进行一下train-val-test set的划分，一般生成随机数就可以按自己的意愿划分，也有专门的库，具体划分代码就不上了。另外数据增强方面也考虑过rgb转hsv或者ycrcb的，但是我试了一个样例之后效果不是很好，毕竟这样做的目的就是为了将主要的前景和特征显示出来，奈何我的数据太差了些，不好操作，于是作罢。准备好数据之后，要对数据进行抽取，我用的是pytorch，直接继承Dataset类就好：1234567891011121314151617181920212223242526272829class SSDataset(Dataset): def __init__(self, imgs_path, csv_path, img_transform=None, loader=default_loader): with open(csv_path, &apos;r&apos;) as f: #这里一定要按字符串读取，否则前面的0会丢掉 #类似于OCR的labe读取 data_info = pd.read_csv(f, dtype=str) #第一列是image name self.img_list = list(data_info.iloc[:,0]) #第二类是labelid self.label_list = list(data_info.iloc[:,1]) self.img_transform = img_transform #loader用PIL.Image.open() #不要用cv2.imread() #pytorch默认PIL格式 self.loader = loader self.imgs_path = imgs_path def __getitem__(self, index): img_path = os.path.join(self.imgs_path, self.img_list[index]) img = self.loader(img_path) label = self.label_list[index] if self.img_transform is not None: img = self.img_transform(img) return img, label def __len__(self): return len(self.label_list)但是定义的labelid是str，还需要转成tensor去计算loss:1234567891011def labelid_switch(labels_str): b_s = len(labels_str) pad_label = [] for i in range(0, b_s): temp_label = [0]* 16 temp_label[:16] = labels_str[i] temp_label = list(map(int, temp_label)) pad_label.append(temp_label) pad_label = torch.Tensor(pad_label) labels_float = pad_label.view(b_s, 16) return labels_floattrain训练模型是主要用的是resnet和vgg，这部分代码可以直接参考torchvision，然后改改后面的layer就好了。loss function上我试了binary cross entropy和focal loss（毕竟整体上positive grids还是少于negative grids的），此外我也试了下mixup，就是随机把batch里面的图片两两混合，计算loss的时候按照混合的比例分别计算相加，这也是一种应对过拟合，降低模型复杂度的办法（还有一种类似的方法叫sample pairing，只混合图片，不管label，我也试了，不过实际好像没mixup顶用）：123456789101112class BFocalLoss(nn.Module): def __init__(self, gamma=1,alpha=0.8): super(BFocalLoss, self).__init__() self.gamma = gamma self.alpha = alpha def forward(self, inputs, targets): p = inputs loss = -self.alpha*(1-p)**self.gamma*(targets*torch.log(p+1e-12))-\ (1-self.alpha)*p**self.gamma*((1-targets)*torch.log(1-p+1e-12)) loss = torch.sum(loss) return loss1234567891011121314151617def mixup_data(in_img, in_label, alpha=1.0): #alpha in [0.1,0.4] in paper has better gain(for imagenet) #for cifar-10 is 1. if alpha &gt; 0: lam = np.random.beta(alpha, alpha) else: lam = 1 Batch_Size = in_img.size()[0] Index = torch.randperm(Batch_Size) mixed_x = lam * in_img + (1 - lam) * in_img[Index, :] y_a, y_b = in_label, in_label[Index] return mixed_x, y_a, y_b, lam #计算loss loss_mixup = lam * criterion(pred, labels_a) + \ (1 - lam) * criterion(pred, labels_b)接下来的事就是调参，对比实验，开tensorboard看loss的趋势了。（这里有一个现象，前期有一部分时间loss难以下降，总是在一个范围内波动，我猜想可能是因为数据扩增的原因。）test这部分就是加载模型，一张张图片测试，然后写出预测的csv即可，然后给出grid acc123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#部分代码如下：file_pre = open(PRE_TEST_CSV, &apos;w&apos;, newline=&apos;&apos;)pre_writer = csv.writer(file_pre)pre_writer.writerow([&quot;ImageName&quot;, &quot;LabelId&quot;])with open(SRC_TEST_CSV, &apos;r&apos;) as f_test: test_data = pd.read_csv(f_test, dtype=str) img_name = list(test_data.iloc[:,0]) labelid = list(test_data.iloc[:,1]) test_data_len = len(test_data.index) num_right = 0 positive_num = 0 positive_num_right = 0 for i in range(0,test_data_len): img_path = os.path.join(TEST_DATA_PATH, img_name[i]) img = Image.open(img_path) img_tensor = transformations(img).float() img_tensor = img_tensor.unsqueeze_(0) temp_label = [0]*16 temp_label[:16] = labelid[i] temp_label = list(map(int, temp_label)) for temp in temp_label: if temp &gt; 0: positive_num += 1 label = torch.FloatTensor(temp_label) label = label.view(1, 16) input = Variable(img_tensor) input = input.to(device) pred = net(input).data.cpu() #在CPU中比较 output = pred pred_len = pred.size()[1] out = [] for j in range(0, pred_len): if pred[0][j] &lt; 0.5: output[0][j] = 0 out.append(0) if output[0][j] == label[0][j]: num_right += 1 else: output[0][j] = 1 out.append(1) if output[0][j] == label[0][j]: num_right += 1 positive_num_right += 1 pre_writer.writerow([img_name[i],&apos;&apos;.join(str(k) for k in out)]) print(&apos;test acc is: &apos;, num_right/(test_data_len*16)) print(&apos;postivite acc is: &apos;, positive_num_right, &apos;/&apos;, positive_num)summary实际上这个代码下来，调参还是挺费劲的，尤其是对我这种刚开始搞深度学习，经验还不够的新手来说，着实走了不少弯路。可是数据集实在太差，实在是想不出什么招。。所以硬撑了快两个月（实际上前大半个月我是直接分割grid成单独的图片，然后全部丢进去训练的。。这样搞不仅正负样本差距极大，而且切断了图片的连续性，效果奇差也在意料之中了，基本训不动，即使加了focal loss也没什么卵用）最后最高也才得到90%的acc。weakly semantic segmentation好歹8月下旬那会找到了一个公开的sputum smear的数据集，还带着框的标注：Makerere University, Ugandahomepagepapercode跟CTO交流后，他觉得这数据集质量不错，干脆就提议做弱监督分割，毕竟object detection现在都做烂了，而且开源这数据集的小哥自己也把object detection的acc刷的不错了，所以没必要再调包重复同样的事情了。我当时其实没啥思路，但是觉得应该挺有意思的，于是就接了下来。后来通过调研发现，原来在自然图像上早就有人做了weakly segmentation(又是我恺明哥那些人…)，而且效果还不错，唯一可惜的就是完整的代码基本没人开源，不过后来参考GitHub上的一些相关代码也慢慢搭建出了整个框架。整个项目思路主要参考的是这两篇论文：戴季峰的BoxSup和Max Planck Institute的Simple Does It，主要的思路就是先设定几个从bounding box annotations生成segment proposals的方法（主要是opencv中GrabCut），然后利用此label去进行supervised training，最后过一下denseCRF优化一下，让boundary更加丝滑。当然也可以试试递归训练，让performance不错的model去预测生成新的training set中的label，然后进行下一轮的训练。因为代码比较庞杂，分块不好展示，完整的代码就直接放在我的github上。pre-processing原始的数据集中有1217张阳性图片，此外这些图片的标注还有47张莫名奇妙多了些20x20的框（可能是标的时候手抖了），因此要先一个个去掉。之后，对这些图片进行大致masks的生成，我这里给了三种方法：Box_segments: 把整个box里面的像素都认为是杆菌（要把box的坐标都转成int，得对上像素）Sbox_segments:取box里面的80%的矩形框，认为该框里面的像素都是杆菌（同样，坐标都是int类型）GrabCut_segments: 利用经典的计算机视觉方法GrabCut来得到杆菌的分割区域，但是该方法一般对图片的里面的单个的大物体比较友好，而杆菌又细又长，同时又包含着染色质，所以利用颜色分布的GrabCut分割出的杆菌要么会大点，要么就没有。大点的我不管，没有的我在这里就直接用Box_segments代替了。GrabCut部分代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778def grabcut(img_name): masks = [] # one image has many object that need to grabcut for i, ann_info in enumerate(ANNS[img_name], start=1): img = cv.imread((img_dir +img_name).rstrip()+&apos;.jpg&apos;) grab_name = ann_info[1] xmin = ann_info[3] ymin = ann_info[2] xmax = ann_info[5] ymax = ann_info[4] &quot;&quot;&quot;get int box coor&quot;&quot;&quot; img_w = img.shape[1] img_h = img.shape[0] xmin, ymin, xmax, ymax = get_int_coor(xmin, ymin, xmax, ymax, img_w, img_h) box_w = xmax - xmin box_h = ymax - ymin # cv.grabcut&apos;s para mask = np.zeros(img.shape[:2], np.uint8) # rect is the tuple rect = (xmin, ymin, box_w, box_h) bgdModel = np.zeros((1, 65), np.float64) fgdModel = np.zeros((1, 65), np.float64) #for small bbox: if box_w * box_h &lt; MINI_AREA: img_mask = mask[ymin:ymax, xmin:xmax] = 1 # for big box that area == img.area(one object bbox is just the whole image) elif box_w * box_h == img.shape[1] * img.shape[0]: rect = [RECT_SHRINK, RECT_SHRINK, box_w - RECT_SHRINK * 2, box_h - RECT_SHRINK * 2] cv.grabCut(img, mask, rect, bgdModel,fgdModel, ITER_NUM, cv.GC_INIT_WITH_RECT) # astype(&apos;uint8&apos;) keep the image pixel in range[0,255] img_mask = np.where((mask == 0) | (mask == 2), 0, 1).astype(&apos;uint8&apos;) # for normal bbox: else: cv.grabCut(img, mask, rect, bgdModel,fgdModel, ITER_NUM, cv.GC_INIT_WITH_RECT) img_mask = np.where((mask == 0) | (mask == 2), 0, 1).astype(&apos;uint8&apos;) # if the grabcut output is just background(it happens in my dataset) if np.sum(img_mask) == 0: img_mask = np.where((mask == 0), 0, 1).astype(&apos;uint8&apos;) # couting IOU # if the grabcut output too small region, it need reset to bbox mask box_mask = np.zeros((img.shape[0], img.shape[1])) box_mask[ymin:ymax, xmin:xmax] = 1 sum_area = box_mask + img_mask intersection = np.where((sum_area==2), 1, 0).astype(&apos;uint8&apos;) union = np.where((sum_area==0), 0, 1).astype(&apos;uint8&apos;) IOU = np.sum(intersection) / np.sum(union) if IOU &lt;= IOU_THRESHOLD: img_mask = box_mask # for draw mask on the image later img = cv.cvtColor(img, cv.COLOR_BGR2RGB) masks.append([img_mask, grab_name, rect]) num_object = i &quot;&quot;&quot;for multi-objects intersection and fix the label &quot;&quot;&quot; masks.sort(key=lambda mask: np.sum(mask[0]), reverse=True) for j in range(num_object): for k in range(j+1, num_object): masks[j][0] = masks[j][0] - masks[k][0] masks[j][0] = np.where((masks[j][0]==1), 1, 0).astype(&apos;uint8&apos;) &quot;&quot;&quot;get class name id&quot;&quot;&quot; grab_name = masks[j][1] class_id = grab_name.split(&apos;_&apos;)[-1] class_id = int(class_id.split(&apos;.&apos;)[0]) #set the numpy value to class_id masks[j][0] = np.where((masks[j][0]==1), class_id, 0).astype(&apos;uint8&apos;) # save grabcut_inst(one object in a image) scipy.misc.toimage(masks[j][0], cmin=0, cmax=255, pal=tbvoc_info.colors_map, mode=&apos;P&apos; ).save((grabcut_dir).rstrip()+masks[j][1]) &quot;&quot;&quot;merge masks&quot;&quot;&quot; # built array(img.shape size) mask_ = np.zeros(img.shape[:2]) for mask in masks: mask_ = mask_ + mask[0] # save segmetation_label(every object in a image) scipy.misc.toimage(mask_, cmin=0, cmax=255, pal=tbvoc_info.colors_map, mode=&apos;P&apos;).save((segmentation_label_dir+img_name).rstrip()+&apos;.png&apos;)这里面我是用scipy来保存masks的，我用的版本是0.19.0，超过这个版本的scipy就没有toimage()这个函数了，据说PIL有可以替代的函数，但是我看两个的功效好像不一样，就没去折腾了。读取数据部分进行了resize处理，原图尺寸是1632x1224，1224不能被32整除，五次下采样和上采样的时候会出现feature map维度不匹配的错误，因此resize成了1632x1216。这里要注意，原图是利用双线性插值进行resize的，masks图是利用最近邻进行resize的（实际上我是生成好masks后训练时才意识到这个问题，实际上可以在最开始就把dataset的数据resize好，这样masks的误差可能就小点），PIL和cv2里面都有类似的函数。数据读取部分代码：123456789101112131415161718192021222324252627282930class TBDataset(Dataset): def __init__(self, txt_dir, width, height, transform=None): self.img_names = [] with open(txt_dir, &apos;r&apos;) as f_txt: for img_name in f_txt: self.img_names.append(img_name) self.transform = transform self.txt_dir = txt_dir self.width = width self.height = height def __getitem__(self, index): img_name = self.img_names[index] img = Image.open(os.path.join(img_dir, img_name).rstrip()+&apos;.jpg&apos;) # the resize function like bilinear img = img.resize((self.width, self.height), Image.LANCZOS) img = np.array(img) label = Image.open(os.path.join(label_dir, img_name).rstrip()+&apos;.png&apos;) # for consider class_id is not consecutive and just fixed by user label = label.resize((self.width, self.height), Image.NEAREST) label = np.array(label) if self.transform is not None: img = self.transform(img) #img = torch.FloatTensor(img) label = torch.FloatTensor(label) return img, label def __len__(self): return len(self.img_names)train训练部分模型用的是FCN和UNet，因为考虑到只有二分类，后面也可以考虑deeplab，UNet++等等。FCN用的是VGG-16 backbone，下采样5次，UNet下采样4次，都是按照论文来的，没做什么改动。模型最后输出的是一个1632x1216的feature map，然后直接过sigmoid激活函数，再和1632x1216的mask图片（读进来的是一个二维0-1矩阵，代表每个像素点的label）进行loss计算，然后BP，更新参数学习。loss也用了交叉熵和focal loss.post-processing对模型预测出的结果再过一遍denseCRF，优化分割的同时也会去掉一些false-positive部分代码如下：12345678910111213141516171819202122232425262728293031323334353637383940def run_densecrf(img_dir, img_name, masks_pro): height = masks_pro.shape[0] width = masks_pro.shape[1] # must use cv2.imread() # if use PIL.Image.open(), the algorithm will break #TODO --need to fix the image problem img = cv.imread(os.path.join(img_dir, img_name).rstrip()+&apos;.jpg&apos;) img = cv.resize(img, (1632,1216), interpolation = cv.INTER_LINEAR) # expand to [1,H,W] masks_pro = np.expand_dims(masks_pro, 0) # masks_pro = masks_pro[:, :, np.newaxis] # append to array---shape(2,H,W) # one depth represents the class 0, the other represents the class 1 masks_pro = np.append(1-masks_pro, masks_pro, axis=0) #[Classes, H, W] # U needs to be flat U = masks_pro.reshape(2, -1) # deepcopy and the order is C-order(from rows to colums) U = U.copy(order=&apos;C&apos;) # for binary classification, the value after sigmoid may be very small U = np.where((U &lt; 1e-12), 1e-12, U) d = dcrf.DenseCRF2D(width, height, 2) # make sure the array be c-order which will faster the processing speed # reference: https://zhuanlan.zhihu.com/p/59767914 U = np.ascontiguousarray(U) img = np.ascontiguousarray(img) d.setUnaryEnergy(-np.log(U)) d.addPairwiseGaussian(sxy=3, compat=3) d.addPairwiseBilateral(sxy=80, srgb=13, rgbim=img, compat=10) Q = d.inference(5) # compare each value between two rows by colum # and inference each pixel belongs to which class(0 or 1) map = np.argmax(Q, axis=0).reshape((height, width)) proba = np.array(map) return proba这里主要用到了二元势pairwise potential，比较每个像素和其他像素的关系，具体原理可以去看看原代码和论文。此外，我还顺手进行了下迭代训练。实际上，对于我这个数据集，基本上用GrabCut生成label训练一遍效果就不错了，不过为了看下更新label再训练一轮会不会得到更好的结果，在固定的epoch结束后将训练好得模型设为eval模式，然后预测train set的数据，然后再返回train模式继续训练。需要注意的是，更新label的时候，可能会有漏诊和误诊，我就直接将预测的mask和Box_segments得到的mask相加，只取为2的部分，这样就去掉了假阳性，然后漏诊的部分再用box补回来。从实验结果来看，一般我这个是更新3次label（每10个epoch更新一次）就差不多了，再多也没什么提升。总体上来说，这个操作可以提高单张图片同时存在多个杆菌的分割效果，但是提升力度也没什么太令人满意的地方。可能是我的更新姿势不对？1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283def update_label(predict_model, device): &quot;&quot;&quot;load train_pairs.txt info for check the missed diagnosis objects&quot;&quot;&quot; #ann_info:[image name, image name_num_ class_id.png, bbox_ymin, # bbox_xmin,bbox_ymax, bbox_xmax, class_name] print(&apos;start to update...&apos;) ANNS = &#123;&#125; with open(dataset_pairs_dir, &apos;r&apos;) as da_p_txt: for ann_info in da_p_txt: # split the string line, get the list ann_info = ann_info.rstrip().split(&apos;###&apos;) if ann_info[0].rstrip() not in ANNS: ANNS[ann_info[0].rstrip()] = [] ANNS[ann_info[0].rstrip()].append(ann_info) predict_model.eval() # define the same image transformations transformations = transforms.Compose([ transforms.ToTensor(), transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]) ]) update_num = 0 print(&apos;updating progress:&apos;) with open(dataset_txt_dir, &apos;r&apos;) as da_txt: # don&apos;t use the code line below # or it will close the file and the whole programm end here (I guess) # I debug here for two hours...... #lines = len(da_txt.readlines()) for update_name in da_txt: update_num += 1 # in RGB [W, H, depth] img = Image.open(os.path.join(img_dir, update_name).rstrip()+&apos;.jpg&apos;) img_w = img.size[0] img_h = img.size[1] img = img.resize((1632, 1216), Image.LANCZOS) input_ = transformations(img).float() # add batch_size dimension #[3, H, W]--&gt;[1, 3, H, W] input_ = input_.unsqueeze_(0) input_ = input_.to(device) pred = predict_model(input_).view([1216, 1632]).data.cpu() #pred.shape[H,W] pred = np.array(pred) &quot;&quot;&quot;crf smooth prediction&quot;&quot;&quot; crf_pred = run_densecrf(img_dir, update_name, pred) &quot;&quot;&quot;start to update&quot;&quot;&quot; last_label = Image.open(os.path.join(label_dir, update_name).rstrip()+&apos;.png&apos;) last_label = last_label.resize((1632, 1216), Image.NEAREST) last_label = np.array(last_label) # predicted label without false-positive segments updated_label = crf_pred + last_label updated_label = np.where((updated_label==2), 1, 0).astype(&apos;uint8&apos;) # predicted label with missed diagnosis # we just use the box segments as missed diagnosis for now info4check = ANNS[update_name.rstrip()] masks_missed = np.zeros((1216, 1632), np.uint8) for box4check in info4check: xmin = box4check[3] ymin = box4check[2] xmax = box4check[5] ymax = box4check[4] xmin, ymin, xmax, ymax = get_int_coor(xmin, ymin, xmax, ymax, img_w, img_h) xmin = int(xmin * 1632 / img_w) xmax = int(xmax * 1632 / img_w) ymin = int(ymin * 1216 / img_h) ymax = int(ymax * 1216 / img_h) if np.sum(updated_label[ymin:ymax, xmin:xmax]) == 0: masks_missed[ymin:ymax, xmin:xmax] = 1 updated_label = updated_label + masks_missed scipy.misc.toimage(updated_label, cmin=0, cmax=255, pal=colors_map, mode=&apos;P&apos;).save(os.path.join(label_dir, update_name).rstrip()+ &apos;.png&apos;) print(&apos;&#123;&#125; / &#123;&#125;&apos;.format(update_num, len(ANNS)), end=&apos;\r&apos;)metric一般的segmentation论文都是用IoU来进行比较的，但是这个数据集没有segmentation groundtruth，所以我就自己定义了个检测的acc：预测的mask和框有交叉(np.sum(region of box)!=0)，就认为检测出了一个，然后算average acc，通过这个指标和test set上的预测结果来大致衡量哪些方法组合在一起不错。最后总结下来，还是GrabCut+FCN+FL($\alpha=0.75,\gamma=1$)更好些，不过我没加大UNet的深度和通道数，否则的话我猜想可能UNet会占上风。篇幅有限，放几个还不错的预测结果：summary总的来说，最后的弱监督分割还是收获挺多的，尤其是自己的工程能力得到了锻炼，代码组织和书写也得到了一定地提升，最后相关成果也写成论文投了ISBI会议，如果能中的话，还是很舒服的^-^]]></content>
      <categories>
        <category>工作总结</category>
      </categories>
      <tags>
        <tag>computer vision</tag>
        <tag>deep learning</tag>
        <tag>CNN</tag>
        <tag>medical image analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习见闻及其他]]></title>
    <url>%2Fposts%2Fthoughtsofintern%2F</url>
    <content type="text"><![CDATA[早有耳闻近年的机器学习和计算机视觉岗位不好找，很多研究生都会借着自己城市和学校的优势，去争取一些公司的实习。我是兜兜转转好几年后才开始正式去学机器学习，也算是半路出家，而且有种49年入国军的赶脚。平日里看着教研室的师兄们即使做着非机器学习算法也在求职的道路上一波三折，心里不免对自己的前途充满着担忧和焦虑。好在导师关系网络庞大，在今年5月丢给了我一个去AI医疗影像公司实习的机会。能够得到锻炼，同时也可以见识见识工业界的研究节奏和方式，这样的运气，我自然不会让其白白溜走。这家公司南京分部的CTO是一位加州海归博士，热爱技术又充满激情，在勉强通过他的面试之后，我得到了三个月的实习机会。公司的效率和推进速度还是非常快的，刚开始确实不适应，毕竟放羊久了，长时间地坐在电脑前看论文，垒代码，调参数还是有点乏人的。不过我是分配了一个单独的项目，所以三个月来就相当于单干，虽然没有外部的压力，但是没能参与核心项目，与公司大佬们一起讨论，还是心存遗憾（不过自己水平确实不高，也很正常，咱心里还得有点数才行…）。实习的任务主要是对他们提供的痰涂片（sputum smear）数据集进行分类，但是不是一般意义上的单张图片分类。这里我先简单科普下，痰涂片是为了辅助诊断结核病而采集的样本，医生根据采集的病人的痰液里面的结核杆菌（tuberculosis bacillus）数量来判断阳性或阴性，这种手段主要在发展中国家，贫困地区等地方常见（有条件的直接照X光了）。原始数据集的每张图片都是从显微镜采的，而且分成了4x4的grid，我要做的就是分类图片每个grid的label，有点类似one-stage的目标检测。然而，数据又脏又少。。。。折腾了两个月实在没弄出满意的结果（好像最后最好才到0.9的acc）。没办法，最后Google找了好几天偶然发现了一个公开的数据集，还带着bounding box的标注！！！于是后面和CTO商讨，干脆上了weakly semantic segmentation（最后10几天的工作量比前两个月的还要多的多。。果然deadline是第一生产力）。好歹最后结果还可以。详细的讲解可以看我下一篇博客。下面我想重点谈谈自己的收获与感想：代码和算法。只有真正经历了才明白代码能力是多么的重要。从面试一直到解决实际工程问题，或者是自己平时研究，搭网站，作图，实现自己的一个想法…等等等等，都可以发挥巨大的的作用。虽然说做机器学习数学相对重要点，可是进入职场以后，算法和代码能力才是硬实力。对于我这种菜比来说，多练，多参考，多总结是唯一有效的办法工业界和学术界。工业界基本上都是以项目和数据驱动的（可能国内大的学教研室跟其也没什么不同。。），基本上不关心如何创造新方法，新理论，只关心产品如何更好地生成和落地。每天的迭代节奏都很快，各个领域的知识都会涉及（初创公司可能更多）。一般的项目组都是利用现成的SOTA去修改然后适配自己的数据，所以就要求职员得预先懂得很多东西，或者知道哪些方法可以用上，要是从头开始调研的话就太慢了。此外，工业界还有着模块化的管理，比如利用trello这样的软件和早会来安排具体每个人一段时间的任务，交流进展情况，及时解决blocked问题等等。对于涉及到算法的公司，代码的管理，维护，更新是个big problem，从代码托管平台或者服务器的选择，coding的规则制定，review code的指定和审阅标准，要审几轮之后才能merge等都是一些比较琐碎却很实际的问题，是需要慢慢完善的过程。现在想想，那么多学术大牛后面选择投身工业界不是没有道理的，对他们来说研究可以照常进行，资源也更加丰富，而且更有那种creating的青春感，反而学术界里面无拘无束的环境，可能会慢慢消磨他们的激情。处于象牙塔里是很可能被温水煮青蛙的。保持学习和交流的习惯。即使是工作以后，也要保持一种好奇心，要促使自己不断地去进步。学习不仅是让你更加游刃有余于自己的工作，也是为了打开自己的视野，丰富自己的生活。以技术学习为例，公司的研究组一般都会有paper reading这样的活动，每周读一篇典型的论文，轮流安排组员上去讲解，一方面打开工作思路，一方面也是锻炼人的说话和展示能力（费曼学习法）。不要对别人的工作满不在乎，漠不关心，经常主动和别人交流，既交了朋友，也可以扩展自己的领域认知。把握工作节奏，保持沟通。如今996大行其道，加上媒体大肆宣扬，搞得程序猿们人心惶惶。实际上如果是一个项目要到期了，某段时间可能要加点班一起赶出来的话，是可以接受的，但是如果每天强制加班，搞得连自己生活都没了，那我肯定是果断放弃了，除非给我年薪百万。。。因此，在找工作前，首先得平衡好自己的要求，认清一些现状，身体健康和生活质量是放在第一位的，其他的都是为了这两者服务的。有困难，有难题一定要及时反映或者在其恰当的时机吐露出来，不要动不动就轻视自己的生命（可能还没到这种地步），当然这是最差的情况。平时和同级沟通，和上级沟通（反映意见，提出工作思路，建议等）都是必不可少的职场状态。总的来说，第一次实习还是挺圆满的，虽然没学到什么大本事，但是起码这段经历让我收获了很多，也更加坚定了自己的选择，对未来的路也看得明晰了些。不得不说，有些事情还是要自己经历过后才能懂得，这些没法感同身受的经验，是怎么也无法理解的。趁着年轻，还是应该多把自己推出舒适区，多去争取一些历练和出走的机会，以此开阔自己的眼界，认识社会和世界。好像写到现在也没怎么提及到实习公司的情况。。。想着最后了，还是祝贺下组里的大佬们帮公司拿到了吴恩达chestXpert 数据集比赛的冠军，而且霸榜了几个月！着实佩服。我也从他们身上学到了不少新知识和新姿势。自己厚着脸皮也和他们一起公费嗨皮庆祝了下。好了，今年的实习告一段落了，明年希望能自己争取到大厂的实习。(‘ o_o ‘)]]></content>
      <categories>
        <category>随笔杂谈</category>
      </categories>
      <tags>
        <tag>computer vision</tag>
        <tag>reflections</tag>
        <tag>job</tag>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[往者不谏，来者可追]]></title>
    <url>%2Fposts%2Fpersonalthoughts-1%2F</url>
    <content type="text"><![CDATA[要想得到某样东西，最可靠的办法先让自己配得上它前些日子无意间看到了一位A. J. Davison教授的新博士生在知乎上写的一篇回答，他在里面谈到了自己科研之路曲折受挫的经历，尤其是屡屡面对着与自己期望不符合的情况，让我感触很深，想起了自己去年准备国外博士申请失败的那段苦痛记忆。可能对于我来讲，自己对读博的认识和准备都还欠缺得很，既没有拿得出手的本领，技能和honor，也没有对未来研究方向的清楚认识，与另一位机器人大牛YY硕读博的初衷和认知相比，实在是汗颜。所谓人的成长，其实是“不断发现个人独特的经历原来都只是人类普遍经验的一部分”的过程​ —- 多丽丝 莱辛自己步入大学也快接近五年了，在这五年来的科研学习生涯上，没有出现一件让我满意的工作，甚至可以说连接触“像样的工作”的机会都没有。回想本科的生活，似乎陷入了一种想要寻求突破发展，却又每每哀叹碰壁于现实，最终困于浑浑噩噩的循环中。虽然高考成绩把我带到了这个所谓的“培优学院”中来，但是实际上鸡肋的培养模式和自己能力不足以及信息缺失等问题，让自己走了很多弯路。从大二上学期进入学院导师的实验室开始，就开始了漫长的专业方向调研和探索学习之旅：先是MEMS器件，再是小型固定翼无人机飞行控制系统，然后转到了飞控数据采集和处理硬件平台，后来又顺着跳到了四旋翼避障，然而结果最终都因为各种原因和变故而终止。现在磕磕碰碰转到了SLAM，从此开始接触计算机视觉，又加上人工智能大热，算是勉强把自己的研究定位在visual SLAM, Robotics和Machine Learning上，即使现在没有任何老师和同专业的师兄师姐指导，但是我心底里知道，这是自己好不容易觉得自己感兴趣的可以坚持做下去的方向，心里也十分珍惜，不愿轻易放弃，纵使单枪匹马很难在这个领域做出东西来。心里开始真正坚定了出国留学的想法是在保研后期的时候，那时通过自己的偶然探寻和师兄的推荐，先后联系了两位国外的教授，虽然他们对我的态度都很好，也愿意接收我，但是最终都因为CSC奖学金的问题而以失败告终（甚至连尝试申请CSC的机会都没有）。在这期间，我曾自信满满地以为自己一定能与过去失败的生活说再见，可以在新的教研室，友好的导师的帮助和指导下开启自己目前最感兴趣的课题，然后三四年读完博士，之后再去争取更好的平台继续研究。现在看来，我想得太过于理想化，现实是残酷的，会时不时让人痛苦，“而这种痛苦往往来自于人对于自己无能的愤怒”。在得知CSC奖学金不再对我申请的学校提供名额的那一刻起，就基本上宣判我大半年的准备都是白费的，毕竟自己和意向导师的实验室都缺钱，所以CSC几乎是唯一的funding。当时的我陷入了极大的消极之中，就像看到了希望，看到了黑暗生活中的一丝光亮，想要伸手去触碰，去争取，却又被黑暗中的种种阻碍和枷锁困住，动弹不得。后来我安慰自己，人是无法预测自己的命运的，我们可以做的就是不断地让自己变得更好，to be kind。其实我后来想想，这似乎也是天意，让我好好地去审视自己，看清楚自己身上到底出了什么问题，而不是就这么简单地给予我幸运的关照，让我顺顺利利地就能跑到国外读博，逃避现实。因为不论是从科研能力上，心理素质上，理性认知上，以及生活技能上我都还欠火候，还需要不断地修炼，毕竟选择科研这条路不是一句简单的承诺，不仅仅是付出就可以安然走下去的。让我欣慰的是，自己地沉沦与消极并没有持续很久，几天之后就慢慢放下了，可能自己心底里也并不是对那些学校和生活特别期待和憧憬，可能自己心底里也还是有个标准的。我一边开始继续自己的研究生工作学习和课题探寻，一边反思自己的生活和精神状态：那些让自己觉得失败的经历到底是如何发生的，为什么我早就认识到了却没有去很好地补救？我想，一方面是信息的缺失，身边没有一些志同道合的大佬级别的人之外，另一方面是自己持续不断的，反反复复的自怨自艾，想得太多而又做的太少，眼高手低。前者是没办法选择的，毕竟环境和出生不同，这是客观的因素，我能做的就是学会善用信息时代的网络技术，持续地阅读优质的内容，挖掘有效的有价值的信息，并且主动地结交那些志同道合的前辈；后者是主观因素，是内因，才是自己最应该去改变的地方。因为只有不断地去做，去尝试，机会和惊喜才会眷顾你。努力不一定有收获，但是起码会给你一些选择和机会，同时让人在这个过程中成长。Work cures everything.​ ——马蒂斯因此，我开始承认自己菜，而且承认自己是真的菜，那些优秀的人不仅在学习和科研上有很高的建树，在其他方面，诸如绘画，音乐，运动，哲学，文学等都有很高的领悟和施展技巧。我开始慢慢认识到自己的不足和平凡，开始努力地在各个方面去提升自己，当然也是自己一贯就感兴趣的地方，同时也想打开自己的眼界，愿意并持续地去尝试新事物，涉猎不同的领域，发展多种爱好。一言以蔽之，就是活在当下，持续工作，持续输入输出，以此提升自己，慢慢地体验生活，了解生活，享受生活。毕竟这才是人活于世的一项基本目的。写到这，我想起了英国演员本尼迪克特在节目letters live上朗读的一封书信，这是美国先驱艺术家索尔·勒维特写给他的好友伊娃·黑塞一封信，背景是1965 年，黑塞经历了一段自我怀疑的时期，她的创作遇到瓶颈，她迷茫、沮丧，不知道该怎么办，不知道未来在哪里，她向勒维特倾诉自己遇到的“心灵困境”。几周后，勒维特用以下这件作品回复了她：一封精妙、宝贵的建议信，让她不要再彷徨，而是”stop it and just Do “.信的内容如下：Dear Eva,It will be almost a month since you wrote to me and you have possibly forgotten your state of mind(I doubt it though).You seem the same as always, and being you, hate every minute of it.Don’t!Learn to say Fuck You to the world every once in a while. You have every right to.Just stop thinking, worrying, looking over your shoulder wondering, doubting, fearing, hurting, hoping for some easy way out, struggling, grasping, confusing, itching, scratching, mumbling, bumbling, grumbling, humbling, stumbling, rumbling, rambling, numbling, gambling, tumbling, scumbling, scrambling, hitching, hatching, bitching, moaning, groaning, honing, boning, horse-shitting, hair-splitting, nit-picking, piss-trickling, nose-sticking, ass-gouging, eyeball-poking, finger pointing, alleyway-sneaking, long waiting, small stepping, evil-eyeing, back scratching, searching, perching, besmirching, grinding, grinding away at yourself. Stop it and just DO.From your description, and from what I know of your previous work and your ability; the work you are doing sounds very good. Drawing-clean-clear but crazy like machines, larger and bolder…real nonsense. That sounds fine, wonderful-real nonsense. Do more, more nonsensical, more crazy, more machines, more breasts, penises, cunts, whatever-make them abound with nonsense. Try and tickle something inside you, your weird humor.You belong in the most secret part of you.Don’t worry about cool, make your own uncool.Make your own, your own world. If you fear, make it work for you-draw &amp; paint your fear and anxiety. And stop worrying about big, deep things such as to decide on a purpose and way of life, a consistent approach to even some impossible end or even an imagined end.You must practice being stupid, dumb, unthinking, empty. Then you will be able to DO.I have much confidence in you and even though you are tormenting yourself, the work you do is very good. Try to do some BAD work. The worst you can think of and see what happens, but mainly relax and let everything go to hell.You are not responsible for the world-you are only responsible for your work-so DO it. And don’t think that your work has to conform to any preconceived form, idea or flavor. It can be anything you want it to be. But if life would be easier for you if you stopped working-then stop. Don’t punish yourself.However, I think it is so deeply engrained in you that it would be better for you to DO. It seems I do understand your attitude somewhat, anyway, because I go through a similar process every now and again myself. I have an Agonizing Reappraisal of my work and change everything as much as possible-and hate everything I’ve done, and try to do something entirely different and better. Maybe that kind of process is necessary to me, pushing me on and on. The feeling that I that I can do better than that shit I just did. Maybe you need your agony to accomplish what you do. And maybe it goads you on to do better.But it is very painful I know.It would be better if you had the confidence just to do the stuff and not even think about it. Can’t you leave the world and ART alone and also quit fondling your ego. I know that you(or anyone) can only work so much and the rest of the time you are left with your thoughts. But when you work of before your work you have to empty you mind and concentrate on what you are doing. After you do something it is done and that’s that. After a while you can see some are better than others but also you can see what direction you are going.I’m sure you know all that.You also must know that you don’t have to justify your work-not even to yourself.Well, you know I admire your work greatly and can’t understand why you are so bothered by it. But you can see the next ones and I can’t. You also must believe in your ability. I think you do.So try the most outrageous things you can-shock yourself. You have at your power the ability to do anything.I would like to see your work and will have to content to wait until Aug or Sept. I have seen photos of some of Tom’s new things at Lucy’s. They are impressive-especially the ones with the more rigorous form: the simpler ones. I guess he’ll send some more later on.Let me know how the shows are going and that kind of stuff. My work had changed since you left and it is much better. I will be having a show May 4-29 at the Daniels Gallery 17 E 64th St(where Emmerich was), I wish you could be there.Much love to you both.Sol实际上，这段朗读视频和信的内容我在本科大二的时候就接触到了，可惜当时并没有对此有很深的认知，看来很多道理和改变还是经历过才会真正懂得和接受。现在重读这封信，突然觉得字字箴言。每个人或多或少都会遇到类似的情况，会消沉，会不自信，会怀疑人生，但是事实如此，且事出有因，我们唯一能做的就是调整自己的状态和方向，持续“做下去”，而不是想太多，束缚自己的手脚，正如Sol在信中说的 :Don’t worry about cool, make your own uncool.Make your own, your own world. If you fear, make it work for you-draw &amp; paint your fear and anxiety.After you do something it is done and that’s that. After a while you can see some are better than others but also you can see what direction you are going.“现在，我接受自己满意的作品，也接受不满意的作品，接受积极状态，也接受不积极状态，这是正常的生活，但我不会停止去做，在过程中体验其意义和价值。”自怨自艾，消沉停滞是没有意义的，起码对那时的自己没有帮助，不管是顺境还是逆境，都得持续做下去，因为只有不断地进行下去，最后的意义才会明了。从某种意义上说这似乎是一种”down-top”的思想，我不知道最后结果如何，或者说意义如何，但是我现在要做这件事。就像我身边很多人跟我说“你有没有觉得这一年你感觉天天都很忙，每天起床干活，晚上上床睡觉，日复一日，可是我回想却发现好像啥也没做成”，包括我也是这样。我还年轻，这个问题我没办法理解透彻，只能姑且认为这些都是一种积累，大部分的积累最后会形成质变，其他的一些则会在以后的某个阶段给予我帮助，提供给我一些机会。与“down-top”相反的则是”top-down”，拥有这些能力的估计应该都是比较厉害的人吧，从一开始就知道自己想要做什么，整个人生的大阶段和小阶段都有详细的目标和追求，然后对达到目标的过程又有很清晰的认识，有远见，胸有成竹，因此按照条件需求进行学习提升，后面根据成果和目标之间的差距进行微调，接着进行下一轮的提升。这样的人应当是具有很强的自制力的和自律性的，通常应该属于精英阶层，各方面条件都会不错。然而我只是一个普通人，在认识到自己的局限性后，希望能通过各方面的学习，交流，思考和输出来达到一个让自己满意的境界。“不丢脸是不可能变强的”。那么到底什么样的东西是值得做的，什么样的人生是值得过的呢？“just DO”之前，如何知道现在做的或者之后做的事是值得的呢？实际上，我认为我们可能不会知道，正是因为不知道，所以我们之前才可能会陷入怀疑，但是如果喜欢却不继续工作下去是件很可惜的事，就像Yan LeCun在上个世纪坚持做神经网络和你现在决定做神经网络的道理一样，你做是因为现在神经网络很火，工资高，而Yan LeCun那个时候做是因为他认为这是值得做的，是自己喜欢做的，觉得是可以引发革命的，所以即使受到怀疑，也还是坚持做了下去（举个例子，当然事实可能不一定是这样，另外SLAM领域的大牛Andrew. J. Davison也是花了十年的时间才让人们注意到他工作的价值）。所以做与思考（个体和团体）是一个交织的整体，不应该是看别人做什么就做什么。在不知道自己喜欢什么之前，可以先和别人交流，看看大概是什么样子，觉得还不错的情况下可以去试着深入了解下，至少在科研上是如此，我在走了很多弯路之后才发现视觉SLAM是个非常有挑战性和综合性的领域，充满着令人兴奋的点和创新式的解决办法，所以我才愿意花时间深入研究，虽然申请该专业的博士失败了，但并不代表着我对相关领域的学习研究就此结束，至少我明白了，科研是科研，它代表的是自己的一种兴趣和工作的结合，它不应该掺杂太多的功利性和急于求成的心思在里面，不应该老是渴望着被人认可，希望受到其他研究工作者的高评价，这样会扰乱自己的思绪，甚至阻碍新想法的出现，同样也会过得不自由。自由就是不再寻求认可。”你是这样年轻，一切都在开始，亲爱的先生，我要尽我所能请求你，对于你心里一切得疑难要多多忍耐，要去爱这些“问题得本身”，像是爱一间锁闭了的房屋，或是一本用别种文字写成的书。现在你不要去追求那些你还不能得到的答案，因为你还不能在生活里体验到它们，一切都要亲自生活“ ——-里尔克，《给青年人的十封信》还是从科研的功利性出发，对理工科学生来说，不一定非得以自己的大学专业谋生，虽然这有点站着说话不腰疼的感觉，但是如果觉得工作受限，或者有自己想法的话，不妨放下这种执念，虽然知识是财富，但是知识不等于金钱，这跟自己以后能赚大钱是没有必然的联系的（但是理工类学生的工资好像确实高点，而且学历和工资基本正相关）。这让我想起毕导公众号的一篇文章，叫理工科的硬核浪漫，他在里面说我们在科研，学习的过程中，更多的是训练了我们的一种独特的理工科思维，虽然有时候用这种思维看待问题会让人觉得有点蠢萌和直男，但更多的是会让我们发现生活中的闪光的地方，让我们不自觉地对自己的生活认真起来。因此在这里我想给大家传递一种观点：理工到现在已经成为我的思维方式，也许你觉得理工科男博士这个群体，他们秃头，他们穿衣很差，他们收入很低，有很多的缺点。但事实上，当他们把这种思维用在生活当中之后，在我们同样平凡无趣的生活当中，理工男也许能看到更多闪光的地方，看到更多精彩好玩的地方，他还可以把这个分享给你。之前有人问过，毕导你是清华大学的博士生，你从清华大学博士生从科研转向去做自媒体这件事，你觉得可惜不可惜？我觉得一点不可惜。你在从事这个专业之后，就一条路走到黑，一直从事这一个专业里面的事情，我反而觉得有点可惜。因为你把自己思维局限住了。所以到现在为止，我给自己一点要求是什么呢？我希望自己好好学习理工科知识，把自己的思维学到一个高度，达到一定的高度之后，怀揣着理工科的理想，去到我感兴趣的领域。写到这里，感觉也快差不多了，抱歉写得比较杂乱，似乎都是在说一些空洞而无味的东西。主要是最近一年自己身上确实发生了一些起起伏伏的事情，积压了太久的情绪和想法在沉淀了一段时间之后被知乎上的那个回答给带了出来，因此就想写点什么了。不过好久没写东西了，突然感觉想完全表达自己的想法变得费劲起来，以后还得多多练习才行。估计一年之后回过头来重新看这篇文章可能会觉得有点傻吧。&gt;_&lt;|||最后总结一下：不管现在状况如何，先找到自己喜欢的，或者认为值得自己做的，坚持做下去，并且keep working停止抱怨和自怨自艾，少说多做，大多数的不如意来自于自身的缺陷多阅读，多思考，多交流，尽量少看一些没有营养的东西，多多培养不同的兴趣学会“输出”，不能只是不停地看，否则很容易忘记，对那些有用的，有趣的，通过费曼学习法让其在脑子里变得更加深刻坚持写作，保持创作的热忱主动一点，遇到比较厉害的前辈多多请教，不怕丢脸，学习优秀的人的习惯和思维是一种又快又好的进步方式]]></content>
      <categories>
        <category>随笔杂谈</category>
      </categories>
      <tags>
        <tag>reflections</tag>
        <tag>thoughts</tag>
        <tag>feelings</tag>
        <tag>emotions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FutureMapping by A.J.Davison]]></title>
    <url>%2Fposts%2FFutureMappingofAJD-1%2F</url>
    <content type="text"><![CDATA[AboutIML的A.J.Davison教授是visual SLAM领域里的奠基人之一，近期抽空看了他在推特上置顶的有关SLAM未来的一些思考的论文： FutureMapping: The Computational Structure of Spatial AI Systems。对于做SLAM的同学，感觉这篇论文还是值得一看的，这里有个博主将该论文翻成了中文。实际上，通篇读下来我的感受是并没有发现Davison提出了比较吸引人眼球的见解，不过有不少亮点，也让我加深了对SLAM这个东西的理解。虽然他对未来visual SLAM的功能性估计也和综述Past, Present, and Future of Simultaneous Localization And Mapping: Towards the Robust-Perception Age 里描述得差不多，只不过后者说的比较“大而空”，都是一些常见的想法，什么动态啦，语义融合啦，模仿生物视觉啦，地图表征与更新等等，但是在Davison的这篇论文里，他以一个机器人学者的角度出发，试图从硬件和软件这两个方面去思考，未来的需求下机器人应该如何完成视觉任务，硬件应该如何发展去支持算法有效的计算，以及整个系统该有怎样的结构，才能使得机器人更好地在不同的场景下，甚至是大场景中完成不同的任务。作为一个入门SLAM不算太久的工科学生来说，虽然不少技术知识还未掌握，但是偶尔看看这样的文章和思考也不是未尝不可，至少能激发我思考什么样的东西是值得做的，哪一个技术是未来需求的？不过有一个疑问是一直存在我心中的，大家都谈到了未来的visual SLAM会结合机器学习或者模仿生物视觉机制和大脑存储记忆的机制，这个我是赞同的，但是对于三维地图而言，是否是有必要去重建的，除了它们在AR上的一些应用？大家都说想要融合语义标签，物体分类与识别融合到三维图里面，有的人可能还想让地图进行实时更新，容纳动态物体（至少我曾经是这样想的），但是这样的做的目的和意义到底是什么？单纯说目的是为了让机器进一步理解环境是无法让我满足的，所以我也试图在寻找和思考这个问题的答案。遗憾的是，Davison在这篇文章里面也没有提到此类问题，不过也没有夸大三维地图的作用，而是强调图模型的作用，这一点我是赞同的。也就是说，类似人一样，我们利用视觉和计算完成任务时，”graph”这个东西是肯定发挥了很大的作用，但是却没必要“事无巨细”的记下来，我们大多是提取重要的特征，压缩下来，然后进行推断，从而得出各种预测和结论，而且事后也可以在脑海中回忆重建出场景的三维模型，此外，这些压缩信息也会随时间及时进行更迭，经常重访的则会记得牢固一些，调取起来也很快，那些不常去的可能就会进一步压缩或者删除了。Davison在论文是这样描述地图表征的利用形式的：In real-time, the system must maintain and update a world model, with geometric and semantic information, and estimate its position within that model, from primarily or only measurements from its on-board sensors.The system should provide a wide variety of taskuseful information about ‘what’ is ‘where’ in the scene. Ideally, it will provide a full semantic level model of the identities, positions, shapes and motion of all of the objects and other entities in the surroundings.The representation of the world model will be close to metric, at least locally, to enable rapid reasoning about arbitrary predictions and measurements of interest to an AI or IA system.It will probably retain a maximum quality representation of geometry and semantics only in a focused manner; most obviously for the part of the scene currently observed and relevant for near-future interaction. The rest of the model will be stored at a hierarchy of residual quality levels, which can be rapidly upgraded when revisited.The system will be generally alert, in the sense that every incoming piece of visual data is checked against a forward predictive scene model: for tracking, and for detecting changes in the environment and independent motion. The system will be able to respond to changes in its environment.所以我的意思是，在进行视觉任务时，重建三维地图应该不是必要的，至少在实际任务上目前可能起不到很大的作用，可能需要的是一种更加简洁凝练的图表征模式，这种模式更适合机器去认识环境，去进行编码，解码，计算，存储以及维护，而不是像人一样以为这样看到的是环境的理解方式，毕竟我们看到的是已经经过大脑处理的“人机交互结果”，并不是最核心的表征方式。但是大家为什么现在都比较热衷与做3D视觉，3D重建，我想可能是计算机视觉的一个难题吧，毕竟计算机图形学还是很有魅力的，毕竟未来的应用谁也说不准，只希望最后不要让这些技术让人类迷失在虚拟世界里。。。在这个方面，还得多一些产品层面的思考。以上只是我的一点不成熟的想法，还需要多去阅读思考和交流。Content这篇的文章的摘要如下：We discuss and predict the evolution of Simultaneous Localization and Mapping (SLAM) into a general geometric and semantic ‘Spatial AI’ perception capability for intelligent embodied devices. A big gap remains between the visual perception performance that devices such as augmented reality eyewear or consumer robots will require and what is possible within the constraints imposed by real products. Co-design of algorithms, processors and sensors will be needed. We explore the computational structure of current and future Spatial AI algorithms and consider this within the landscape of ongoing hardware developments.可以看到Davison教授关注的是general geometric and semantic ‘Spatial AI’ perception capability for intelligent embodied devices。首先介绍了Spatial AI system的相关概念，the goal of a Spatial AI system is not abstract scene understanding, but continuously to capture the right information, and to build the right representations, to enable real-time interpretation and action. 然后分别从算法层面和硬件层面去探讨，什么样的元素应该具备，什么样的结构是合理的，什么样的计算方式和维护更新方式可能被采用，以及从被动的分析到主动的分析预测的思考（感觉这才是有点智能的味道），最后还批判现在的计算机视觉研究者都热衷于刷点，而不去思考架构本身的问题，这个吐槽很准了，毕竟听说今年CVPR2019刷点，刷速率的文章接受率都显著下降了，我们读者都疲劳了，更何况评委。当然教授最后吐槽的重点是为了思考Benchmark对visual SLAM的意义，因为visual SLAM是一个实践性很强的系统，是为了解决实际机器人问题而生的，因此在实际的实时实验中效果好才是真的好，一味地去比较各个指标没有太大的意义，而且也很难比较，指标又很多，比如最后文末列的：• Local pose accuracy in newly explored ares (visual odometry drift rate).• Long term metric pose repeatability in well mapped areas.• Tracking robustness percentage.• Relocalisation robustness percentage.• SLAM system latency.• Dense distance prediction accuracy at every pixel.• Object segmentation accuracy.• Object classification accuracy.• AR pixel registration accuracy.• Scene change detection accuracy.• Power usage.• Data movement (bits×millimetres).文中的具体内容不再一一讲了，这里主要讲几个文章中让我感兴趣的点。ML 或者 DL能为Spatial AI system做什么传统机器学习算法和深度学习中的神经网络擅长做分类和回归，它们在对图像的特征学习上有着得天独厚的优势。近些年也有好多工作是利用CNN和RNN，以及unsupervised learning等深度学习的方法来进行位姿估计和深度估计，也取得了不错的效果。不过有些人认为深度学习在已经研究差不多的3D Geometry上并没有什么意义，况且数学模型我们都知道，没必要去及蹭热度利用深度学习来做，相反那些现有的算法无法处理的图像问题，比如鲁棒性好的特征点提取，光照的变化，纹理的单一，场景的识别以及运动模糊等可以尝试利用深度学习隐式地解决。此外，深度学习在object detection，semantic segmentation等都有很好的成果，可以进行应用。These are learning architectures which use the designer’s knowledge of the structure of the underlying estimation problem to increase what can be gained from training data, and can be seen as hybrids between pure black box learning and hand-built estimation. … Why should a neural network have to use some of its capacity to learn a well understood and modelled concept like 3D geometry? Instead it can focus its learning on the harder to capture factors such as correspondence of surfaces under varying lighting.These insights support our first hypothesis that future Spatial AI systems will have recognisable and general map-ping capability which builds a close to metric 3D model. This ‘SLAM’ element may either be embedded within a specially architected neural network, or be more explicitly separated from machine learning in another module which stores and updates map properties using standard estimation methods (as in SemanticFusion for instance). In both cases, there should be an identifiable region of memory which contains a representation of space with some recognisable geometric structure.个人感觉机器学习以及现在，未来可能出现的一系列理论可能对Spatial AI system帮助最大地可能就是图像理解和环境表征方面了，另外长时间运行带来的认识融合和更新。以及压缩等，可能也会有帮助。有关这个方面的思考目前不是很深，因为我现在还没开始学习机器学习，所以对技术了解不深，但是我感觉这东西是个“万精油”，在SLAM上的应用很大程度上可能归功于设计者怎么用，用在哪里，也就是说怎么设计网络，然后通过什么去学习什么功能，而不是紧紧盯着传统的方法然后去想方设法实现它。硬件与云端硬件方面Davison教授主要探讨了装载该Spatial AI System的嵌入式硬件应该具有什么样的结构，而且还具有匹配视觉计算特点的算力，同时还得有一定的存储能力。他肯定了分割计算，并行计算，多核心，多线程，神经形态硬件架构的需求，也列出了一些正在研究的例子，具体的内容可以参见文章内容。实际上，硬件对算法的促进具有着决定性的作用，从Yann Lecun在2019年的ISSCC上做的报告就可以看出，没有良好的硬件支持，算法根本没办法进行实验验证，就很难进步。因此，硬件方面的迫切需求是现在整个智能行业的燃眉之急。另外，Davison教授也肯定了云端的重要性。因为云端相当于一个存储中心，可以存储环境表征这样的信息，而且可以同时对环境分布中的机器人进行通信和数据传输，这对机器人在大场景中，长时间执行任务起到“预热”等辅助性作用。Finally, when considering the evolution of the computing resources for Spatial AI, we should never forget that, cloud computing resources will continue to expand in capacity and reduce in cost. All future Spatial AI systems will likely be cloud-connected most of the time, and from their point of view the processing and memory resources of the cloud can be assumed to be close to infinite and free. What is not free is communication between an embedded device and the cloud, which can be expensive in power terms, particularly if high bandwidthdata such as video is transmitted. The other important consideration is the time delay, typically of significant fractions of a second, in sending data to the cloud for processing.The long term potential for cloud-connected Spatial AI is clearly enormous. The vision of Richard Newcombe, Director of Research Science at Oculus, is that all of these devices should communicate and collaborate to build and maintain shared a ‘machine perception map’ of the whole world. The master map will be stored in the cloud, and individual devices will interact with parts of it as needed. Ashared map can be much more complete and detailed than that build by any individual device, due to both sensor coverage and the computing resources which can be put into it. A particularly interesting point is that the Spatial AI work which each individual device needs to do in this setup can in theory be much reduced. Having estimated its location within the global map, it would not need to densely mapor semantically label its surrounding if other devices had already done that job and their maps could simply be projected into its field of view. It would only need to be alert for changes, and in turn play its part in returning updates.GraphsDavison在论文的第5节讲了很多有关”Graphs”的东西，我们知道，现在的visual SLAM框架都开始逐渐认同将图优化作为减小估计误差的手段要比滤波器估计的效果好得多，因为”graphs”本身就是视觉的一种表征方式，而且在约束上具有非线性性，能更好地模拟现实情况。在SLAM方面，教授主要提出了geometry和local appearance两者是否可以联系起来的观点：We have not yet discovered a suitable feature representation which describes both local appearance and geometry in such a way that a relatively sparse feature set can provide a dense scene prediction. We believe that learned features arising from ongoing geometric deep learning research will provide the path towards this.Some very promising recent work which we believe is heading in the right direction Bloesch et al.’s CodeSLAM. This method uses an image-conditioned autoencoder to discover an optimisable code with a small number of parameters which describes the dense depth map at a keyframe. In SLAM, camera poses and these depth codes can be jointly optimised to estimate dense scene shape which is represented by relatively few parameters. In this method, the scene geometryis stilllocked to keyframes, but we believe that the next step is to discover learned codes which can efficiently represent both appearance and 3D shape, and to make these the elements of a graph SLAM system.Davison教授另外一个观点是该实时系统中的”Computation Graph”，并且再次提出了”object-oriented SLAM”的概念。How can we get back to this ‘object-oriented SLAM’ capability in the much more general sense, where a wide range of object classes of varying style and details could be dealt with? As discussed before, SLAM maps of the future will probably be represented as multi-scale graphs of learned features which describe geometry, appearance and semantics. Some of these features will represent immediately recognised whole objects as in SLAM++. Others will represent generic semantic elements or geometric parts (planes, corners, legs, lids?) which are part of objects either already known or yet to be discovered. Others may approach surfels or other standard dense geometric elements in representing the geometry and appearance of pieces whose semantic identity is not yet known, or does not need to be known.Recognition, and unsupervised learning, will operate on these feature maps to cluster, label and segment them. The machine learning methods which do this job will themselves improve by selfsupervision during the SLAM process, taking advantage of dense SLAM’s properties as a “correspondence engine”.这个图基本上等于是把系统算法的框架给列出来了，可以看出，核心还是”定位“（camera state）和”建图“（world model）。只不过里面加入了深度学习来提高系统的性能。Most computation relates to the world model, which is a persistent, continuously changing and improving data store where the system’s generative representation of the important elements of the scene is held; and the input camera data stream. Some of the main computational elements are:• Empirical labelling of images to features (e.g. via a CNN).• Rendering: getting a dense prediction from the world map to image space.• Tracking: aligning a prediction with new image data, including finding outliers and detecting independent movement.• Fusion: fusing updated geometry and labels back into the map.• Map consolidation: fusing elements into objects, or imposing smoothing, regularisation.• Relocalisation/loop closure detection: detecting self similarity in the map.• Map consistency optimization, for instance after confirming a loop closure.• Self-supervised learning of correspondence information from the running system.这些都是当前比较主流的观点，而且里面涉及的知识体系比较庞大，因此大部分都是先针对一个来展开研究，不过我觉得要想对其进行突破，最大的，也是最有挑战性的问题应该就是世界模型表征问题了，对于机器来讲，这个应当是个非常简洁和高效的表征方式，同时也易于存储，调用，翻译和编码。地图的处理，表示，预测和更新其实这个部分前面已经提及了不少了，而Davison教授也单独在第6节讲了这个问题，对里面的几个关键问题进行了总结和思考：一个是硬件支持，一个是地图存储，一个是实时回环。地图表征方面：There is a large degreeof choice possible in the representation of a 3D scene, but as explained in Section 5.1.2, we envision maps which consist of graphs of learned features, which are linked in multi-scale patterns relating to camera motion. These features must represent geometry as well as appearance, such that they can be used to render a dense predicted view of the scene from a novel viewpoint. It may be that they do not need to represent full photometric appearance, and that a somewhat abstracted view is sufficient as long as it captures geometric detail.地图存储与维持方面（更新）：Within the main processor, a major area will be devoted to storing this map, in a manner which is distributed around potentially a large number of individual cores which are strongly connected in a topology to mirror the map graph topology. In SLAM, of course the map is defined and grown dynamically, so the graph within the processor must either be able to change dynamically as well, or must be initially defined with a large unused capacity which is filled as SLAM progresses.Importantly, a significant portion of the processing associated with large scale SLAM can be built directly into this graph. This is mainly the sort of ‘maintenance’ processing via which the map optimises and refines itself; including:• Feature clustering; object segmentation and identification.• Loop closure detection.• Loop closure optimization.• Map regularisation (smoothing).• Unsupervised clustering to discover new semantic categories.With time, data and processing, a map which starts off as dense geometry and low level features can be refined towards an efficient object level map. Some of these operations will run with very high parallelism, as each part of the map is refined on its local core(s), while other operations such as loop closure detection and optimisation will require message passing around large parts of the graph. Still, importantly, they can take place in a manner which is internal to the map store itself.实时回环方面，教授提出了地图的存储与场景识别方面的一些难点，即“翻译”和“融合”之间协作的问题。因为相机的运动会对地图进行实时更新，该模块的重心在于维持，而不是比较数据，因此可能会对场景识别造成一定的影响。教授在这里提出了可以利用节点（node），海马体结构，以及小世界拓扑结构地图等来解决。我想可能是模仿人的记忆功能。Instead, a possible solution is to define special interface nodes which sit between the real-time loop block and the map store. These are nodes focused on communication, which are connected to the relevant components of real-time loop processing and then also to various sites in the map graph, and may have some analogue in the hippocampus of mammal brains. If the map store is organised such that it has a ‘small world’ topology, meaning that any part is joined to any other part by a small number of edge hops, then the interface nodes should be able to access (copy) any relevant map data in a small number of operations and serve them up to the real-time loop.Each node in the map store will also have to play some part in this communication procedure, where it will sometimes beused as part of the route for copying map databackwards and forwards.注意力机制，主动视觉这里的主动视觉是指机器人主动移动相机去采集和任务有关的信息，是一种“top-down”的执行方式。The active vision paradigm advocates using sensing resources, such as the directions that a camera points towards or the processing applied to its feed, in a way which is controlled depending on the task at hand and prior knowledge available. This ‘top-down’ approach contrasts with ‘bottom-up’, blanket processing of all of the data received from a camera.Davison提到人的视觉机制是“bottom-up”和”top-down“并存的，而且现在的”bottom-up“的图像处理机制也有很不错的发展，而且在处理很多问题上都很有效，因此两者的结合应当也是一种必然，毕竟”top-down“的执行是需要信息和预测来作为先决条件的。主动视觉在系统的实时性上会有很大的帮助，因为减少了信息和数据处理的冗余度，只分析我需要的数据，因此会大大减小对算力的需求。It is important that when assessing the relative efficiency of bottom-up versus top-down vision, we take into account not just processing operations but also data transfer, and to what extent memory locality and graph-based computation can be achieved by each alternative. This will make certain possibilities in model-based prediction unattractive, such as searching large global maps or databases. The amazing advances in CNN-based vision means that we have to raise our sights when it comes to what we can expect from pure bottom-up image processing. But also, graph processing will surely permit new ways to store and retrieve model data efficiently, and will favour keeping and updating world models (such as graph SLAM maps) which have data locality.总结Davison这篇论文提出的思考和观点还是比较符合现在的主流认知的，而且在技术上，教授也给出了一些比较具体的方案。不过这个目标比较长远，目前其中的小环节可能都还没处理好，而且还需要硬件铺路，因此想要彻底实现难度还是有点大的。总之，这样的系统我估计未来都是模块化的，分布式的，并且是多协作的，以任务为中心的，毕竟现在的AI还没有大的突破，因此想要实现像人类那样的视觉机制还比较困难，得需要很多个学科的大佬共同研究努力才行。]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>mapping</tag>
        <tag>AI system</tag>
        <tag>computer vision</tag>
        <tag>hardware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[visual SLAM by Gaoxiang(3)]]></title>
    <url>%2Fposts%2FvisualSLAMbyGaoxiang-3%2F</url>
    <content type="text"><![CDATA[​本次课程主要研究李群和李代数(Lie Group, Lie Algebra)，主要的目的是为了能够相机得旋转和平移进行微调。因为相机的运动估计可能不准确，而无法对旋转矩阵加上微小量之后依然是旋转矩阵（旋转矩阵无法定义加法，如果用四元数，必须是单位四元数，那么也无法定义加法）。李群李代数与后面的优化，流形都会有很大的联系。在视觉SLAM中，相机的位姿是未知的，而我们需要解决什么样的相机位姿最符合当前观测数据这样的问题。一种典型的方式是把其构建成一个优化问题，求解最优的$R$和$t$，使得误差最小化。由于旋转矩阵自身带有约束，即必须正交且行列式为1，因此作为优化变量会引入额外的约束，使得优化变得困难。而通过李群李代数的转换关系，可以顺利求导，把位姿估计变成无约束的优化问题。群群(Group)是一种集合加上一种运算的代数结构，满足封闭性，结合律，幺元，逆。其中幺元可以认为是单位元，就是与其他元素作用不改变这个元素，逆是元素和和它的逆进行运算后得到了幺元。三维旋转矩阵构成了三维正交群(special orthogonal group)SO(3) = \left \{ R \in {\mathbb R}^{3 \times 3} | RR^{T} =I, \det (R)=1 \right \}三维变换矩阵构成了特殊欧式群(special euclidean group)SE(3) = \left \{ T= \begin{bmatrix} R & t\\ O^{T} & 1 \end{bmatrix} \in {\mathbb R}^{4 \times 4} | R \in SO(3), t \in {\mathbb R}^{3} \right \}旋转矩阵集合与矩阵乘法构成群，变换矩阵集合与矩阵乘法也构成了群，因此称它们为旋转矩阵群和变换矩阵群。群结构保证了在群上的运算具有良好的性质。李群与李代数李群具有连续（光滑）性质的群；既是群也是流形；直观上看，一个刚体能够连续地在空间中运动，因此$SO(3)$和$SE(3)$都是李群，然而，它们都没有定义加法，所以很难进行取极限和求导等操作；李代数与李代数对应的一种结构，位于向量空间（李群单位元处的正切空间）$\mathfrak so(3)$，$\mathfrak se(3)$从旋转矩阵引出旋转正交群的李代数：对于相机的连续运动，旋转矩阵也随时间变化，则有：\begin{align*} & R(t)R(t)^{T} = I \\ & \dot{R}(t)R(t)^{T}+R(t)\dot{R}(t)^{T} = 0 \quad \quad 对时间求导\\ & \dot{R}(t)R(t)^{T} = - (\dot{R}(t)R(t)^{T})^{T} \quad \quad 反对称矩阵\\ & 记\dot{R}(t)R(t)^{T} = \phi (t)^{\wedge} \implies \dot{R}(t) = \phi (t)^{\wedge} R(t) \end{align*}符号$\wedge$看作是反对称矩阵的符号，在这里是指将向量$\phi$变成了反对称矩阵，这是由叉乘引申而来，在第二讲有提过。反过来符号$\vee$代表反对称矩阵到向量的变换。上面的式子表示，对旋转矩阵求导，就是在其左侧乘以一个$\phi (t)$，类似于指数函数的求导。下面进行进一步地近似，假设在单位元附近，$t_{0}=0, R(0)=I$，则：R(t) \approx R(t_{0}) + \dot {R}(t_{0})(t-t_{0}) = I + \phi (t_{0})^{\wedge} (t) \quad \quad 将R在t_{0}进行泰勒展开，并忽略二次及以上高阶项进一步假设，在$t_{0}$附近，$\phi$不变，则$\dot {R} (t) = \phi (t_{0}) ^{\wedge} R(t) = \phi _{0} ^{\wedge} R(t)$，再根据初值条件，得出：R(t) = \exp( \phi _{0} ^{\wedge} t)在泰勒展开那一步可以看出，$\phi$反映的是一阶导数的性质，位于旋转正交群的正切空间上（tangent space，切平面上）。上述证明提供了一种思路，可能不太严谨。实际上可以证明最后得出的式子在任意时间都适用，且该关系称为指数映射（exponential map），$\phi$称为$SO(3)$对应的李代数$\mathfrak so(3)$。李群是高维空间的低维曲面，或者说低维流形，在流形原点附近的切空间上的任意一个点，是李代数，可以通过指数映射映回李群上。李代数描述了李群单位元附近的正切空间的性质。\begin{align*} & 李代数由一个集合\mathbb V，一个数域\mathbb F，和一个二元运算[,]（李括号，直观上说表示了两个元素的差异）组成。如果满足下面的四条性质，称\\ & (\mathbb V, \mathbb F, [,])为一个李代数，记作 \mathfrak g。\\ &1. 封闭性 \quad \quad \forall {\bf X, Y}\in \mathbb V, [{\bf X,Y}] \in \mathbb V\\ &2. 双线性 \quad \quad \forall {\bf X, Y}\in \mathbb V, a,b \in \mathbb F,有： [a {\bf X} + b {\bf Y}, {\bf Z}] =a[{\bf X,Z}]+b[{\bf Y, Z}],[{\bf Z},a{\bf X}+b{\bf Y}] =a[{\bf Z,X}]+b[{\bf Z,Y}] \\ &3. 自反性 \quad \quad \forall {\bf X} \in \mathbb V, [{\bf X,X}]={\bf 0}\\ &4. 雅可比等价 \quad \quad \forall {\bf X,Y,Z} \in \mathbb V,[{\bf X},[{\bf Y,Z}]]+[{\bf Z},[{\bf Y,X}]]+[{\bf Y},[{\bf Z,X}]]= {\bf 0} \end{align*}李代数$\mathfrak so(3)$可以看成是三维空间向量和叉积运算构成的，$so(3)=\left \{ \phi \in \mathbb R^{3}, \Phi = \phi ^{\wedge} \in \mathbb R^{3 \times 3} \right \}$，其中：\Phi = \phi ^{\wedge} = \begin{bmatrix} 0 & - \phi_{3} & \phi _{2}\\ \phi _{3} & 0 & -\phi _{1}\\ -\phi _{2} & \phi _{1} & 0 \end{bmatrix} \in \mathbb R^{3 \times 3}李括号$[\phi_{1},\phi_{2}] = (\Phi_{1} \Phi_{2} - \Phi_{2} \Phi_{1})^{\vee}$,容易验证此李括号满足上述四条性质。对于变换矩阵的特殊欧式群$SE(3)$，也有对应的李代数$\mathfrak se(3)$(6维的向量)\mathfrak se(3) = \left \{ \xi = \begin{bmatrix} \rho \\ \phi \end{bmatrix} \in \mathbb R^{6}, \rho \in \mathbb R^{3}, \phi \in \mathfrak se(3), \xi ^{\wedge} = \begin{bmatrix} \phi ^{\wedge} & \rho \\ {\bf 0}^{T} & 0 \end{bmatrix} \in \mathbb R^{4 \times 4} \right \}此时还是以用符号$\wedge$来表示向量到矩阵的变换，只不过不再是限制于反对称矩阵。\begin{align*} & 设变换矩阵g(t)= \begin{bmatrix} R & \alpha \\ {\bf 0}^{T} & 1 \end{bmatrix} ，则g(t)^{-1} = \begin{bmatrix} R^{T} & -R^{T}\alpha \\ {\bf 0}^{T} & 1 \end{bmatrix}\\ &有\dot{g}(t)g(t)^{-1}= \begin{bmatrix} \dot{R}R^{T} & \alpha- \dot{R}R^{T}\alpha \\ {\bf 0}^{T} & 0 \end{bmatrix} = \begin{bmatrix} \omega^{\wedge} & v\\ {\bf 0}^{T} &0 \end{bmatrix} ，其中，\omega^{\wedge} \in \mathbb R^{3 \times 3},v \in \mathbb R^{3},记 \xi^{\wedge}=\dot{g}(t)g(t)^{-1}\\ & (\xi^{\wedge})^{\vee}= \begin{bmatrix} v \\ \omega \end{bmatrix} \in \mathbb R^{6} \\ &\dot{g}(t)=(\dot{g}(t)g(t)^{-1})g(t)=\xi^{\wedge}g(t),则g(t)=\exp(\xi^{\wedge}),假设g(0)=I \end{align*}李括号$[\xi _{1}, \xi _{2}] = (\xi _{1} ^{\wedge} \xi_{2} ^{\wedge} - \xi _{2} ^{\wedge} \xi_{1} ^{\wedge}) ^{\vee}$指数映射和对数映射指数映射反映了李代数到李群的关系，对于旋转矩阵$R$，有$R=\exp (\phi ^{\wedge})=\sum_{n=0}^{\infty} \frac{1}{n!}(\phi ^{\wedge})^{n}$为了研究的方便，先将$\phi$写成旋转向量的形式，即设$\phi = \theta \vec{a}$,其中$\vec{a}$是单位向量，而且具有以下性质\begin{align*} &1.\vec{a}^{\wedge} \vec{a}^{\wedge} = \vec {a} \vec{a}^{T} - I \\ &2.\vec {a}^{\wedge} \vec {a}^{\wedge} \vec {a}^{\wedge} = -\vec {a}^{\wedge} \end{align*}下面利用上述性质对$\exp (\phi)^{\wedge}$进行Taylor展开\begin{align*} \exp (\phi)^{\wedge} & =\exp (\theta \vec{a}) = \sum _{n=0}^{\infty}\frac{1}{n!}(\theta \vec{a}^{\wedge})^{n}\\ & = I+\theta \vec{a}^{\wedge}+\frac{1}{2!}\theta ^{2} \vec{a}^{\wedge}\vec{a}^{\wedge}+\frac{1}{3!} \theta ^{3} \vec{a}^{\wedge}\vec{a}^{\wedge}\vec{a}^{\wedge}+\frac{1}{4!} \theta ^{4} \vec{a}^{\wedge}\vec{a}^{\wedge}\vec{a}^{\wedge}\vec{a}^{\wedge}+ \cdots\\ & = \vec{a}\vec{a}^{T}-\vec{a}^{\wedge}\vec{a}^{\wedge}+\theta \vec{a}^{\wedge}+\frac{1}{2!}\theta ^{2}\vec{a}^{\wedge}\vec{a}^{\wedge}-\frac{1}{3!} \theta^{3}\vec{a}^{\wedge}-\frac{1}{4!}\theta ^{4}\vec{a}^{\wedge}\vec{a}^{\wedge}+\cdots \\ & = \vec{a}\vec{a}^{T}+(\theta -\frac{1}{3!}\theta^{3}+\frac{1}{5!}\theta^{5}-\cdots)\vec{a}^{\wedge}-(1-\frac{1}{2!}\theta^{2}+\frac{1}{4!}\theta^{4}-\cdots)\vec{a}^{\wedge}\vec{a}^{\wedge}\\ & = \vec{a}^{\wedge}\vec{a}^{\wedge}+I+\sin \theta \vec{a}^{\wedge}-\cos \theta \vec{a}^{\wedge}\vec{a}^{\wedge}\\ & = (1-\cos \theta)\vec{a}^{\wedge}\vec{a}^{\wedge}+I+\sin \theta \vec{a}^{\wedge}\\ & = \cos \theta I+(1-\cos \theta)\vec{a}\vec{a}^{T}+\sin \theta \vec{a}^{\wedge} \end{align*}这进一步说明了李代数$\mathfrak so(3)$的物理意义确实就是旋转向量。反之，给定旋转矩阵亦可以求出对应的李代数，即对数映射$\phi = \ln(R)^{\vee}$。不过实际情况下可以通过旋转矩阵到向量的公式来得出李代数。同理，可以得到$\mathfrak se(3)$到$SE(3)$的指数映射（具体推导过程会在作业中展示）\begin{align*} \exp(\xi^{\wedge}) & = \begin{bmatrix} \sum _{n=0}^{\infty}\frac{1}{n!}(\phi^{\wedge})^{n} & \sum _{n=0}^{\infty} \frac{1}{(n+1)!}(\phi ^{\wedge})^{n} \rho \\ {\bf 0}^{T} & 1 \end{bmatrix} \\ & \triangleq \begin{bmatrix} R & J\rho \\ {\bf 0}^{T} & 1 \end{bmatrix} \\ & = T \end{align*}其中$J$为$SE(3)$的雅可比矩阵，$J=\frac{\sin \theta}{\theta} I + (1-\frac{\sin \theta} {\theta}) \vec{a} \vec{a}^{T} + \frac{1-\cos \theta} {\theta} \vec{a}^{\wedge}$注意，这里的平移部分与变换矩阵的平移部分不完全相同，可以看出，指数映射会对李代数中的平移部分进行线性变换后才得到了真正的平移部分。李代数求导与扰动模型前面说过，视觉SLAM应用李群李代数的最初目的就是为了对相机的位姿进行优化。因为相机在观测世界的时候，会不可避免地引入噪声，而我们优化的目的就是会取N个观测，然后对其进行误差最小化，得到一个在这么多N个观测的过程中最优的变换关系。因此，针对优化（一般是最小化问题）问题，我们常用的手段就是求导，此时李代数的功能就体现出来了，因为李代数具有良好的加法运算，可以进行无约束优化问题分析。不过问题是，李代数上的加法并不会对应李群上的乘法，即$\exp(\phi_{1}^{\wedge}) \exp(\phi_{2}^{\wedge}) \neq \exp ((\phi_{1}+\phi_{2})^{\wedge})$该关系由BCH公式（Baker-Campbell-Hausdorff）给出：\ln (\exp (A) \exp(B)) = A +B + \frac{1}{2} [A,B] + \frac{1}{12}[A,[A,B]] - \frac{1}{12}[B.[A,B]]+\cdots如果其中一个量为小量，则有下列的近似表达关系：\ln (\exp (\phi_{1}^{\wedge}) \exp (\phi_{2}^{\wedge}))^{\vee} \approx \begin{cases} J_{l} (\phi _{2})^{-1} \phi_{1}+\phi_{2} \quad \quad \text{if $\phi_{1}$is small}\\ J_{r}(\phi_{1})^{-1} \phi_{2} + \phi_{1} \quad \quad \text{if $\phi_{2}$is small} \end{cases}其中：\begin{align*} & J_{l}=J=\frac{\sin \theta}{\theta} I + (1-\frac{\sin \theta} {\theta}) \vec{a} \vec{a}^{T} + \frac{1-\cos \theta} {\theta} \vec{a}^{\wedge} \quad左雅可比\\ & J_{l}^{-1} = \frac{\theta}{2}\cot \frac{\theta}{2}I+(1-\frac{\theta}{2}\cot \frac{\theta}{2})\vec{a}\vec{a}^{T}-\frac{\theta}{2}\vec{a}^{\wedge}\\ & J_{r}(\phi) = J_{l}(-\phi) \quad 右雅可比 \end{align*}一般来说，利用$T_{cw}$时会进行左乘，利用$T_{wc}$时会进行右乘，以左乘为例，直观的写法是\begin{align*} & \exp (\Delta \phi ^{\wedge}) \exp(\phi ^{\wedge}) = \exp ((J_{l}(\phi)^{-1}\Delta \phi +\phi)^{\wedge}) \quad \quad 李群上的微小量乘法，李代数上的加法相差雅可比矩阵的逆\\ & \exp((\phi + \Delta \phi)^{\wedge})=\exp ((J_{l}\Delta \phi)^{\wedge})\exp(\phi^{\wedge})=\exp(\phi^{\wedge}) \exp((J_{r}\Delta \phi)^{\wedge}) \quad \quad 李代数上的微小量加法，李群上要乘上雅可比矩阵 \end{align*}对于$SE(3)$和$\mathfrak se(3)$，关系要复杂一些（雅可比矩阵较为复杂，是个$6 \times 6$矩阵，但在实际计算中不用到该雅可比）：\begin{align*} & \exp(\Delta \xi ^{\wedge}) \exp(\xi ^{\wedge}) \approx \exp ((\mathcal J_{l}^{-1}\Delta \xi +\xi)^{\wedge})\\ & \exp(\xi ^{\wedge}) \exp (\Delta \xi^{\wedge}) \approx \exp ((\mathcal J_{r}^{-1} \Delta \xi+\xi)^{\wedge}) \end{align*}有了上述公示后，开始对旋转矩阵进行求导，这里有两种方法，一种是导数定义求导，一种是通过扰动模型进行求导，实际中，扰动模型因为形式更加简单，因此采用的更多，先不严谨地记旋转后的点关于旋转矩阵的导数的求导式为 $\frac{\partial (Rp)}{\partial R}$导数模型：\begin{align*} \frac{\partial(\exp (\phi^{\wedge})p)}{\partial \phi} & = \lim_{\delta \phi \to 0} \frac{\exp((\phi+\delta \phi)^{\wedge})p-\exp(\phi^{\wedge})p}{\delta \phi} \\ & = \lim_{\delta \phi \to 0} \frac{\exp ((J_{l}\delta \phi)^{\wedge})\exp(\phi^{\wedge})p-\exp (\phi^{\wedge})p}{\delta \phi}\\ & \approx \lim_{\delta \phi \to 0} \frac{(I+(J_{l}\delta \phi)^{\wedge})\exp(\phi^{\wedge})p-\exp(\phi^{\wedge})p}{\delta \phi} \\ & = \lim_{\delta \phi \to 0} \frac{(J_{l}\delta \phi)^{\wedge}\exp(\phi^{\wedge})p}{\delta \phi}\\ & = \lim_{\delta \phi \to 0} \frac{-(\exp(\phi^{\wedge})p)^{\wedge} J_{l}\delta \phi}{\delta \phi} \\ & = -(Rp)^{\wedge}J_{l} \end{align*}扰动模型（左乘微小量）：\begin{align*} \frac{\partial(Rp)}{\partial R} & = \lim_{\delta \phi \to 0} \frac{\exp((\delta \phi)^{\wedge})\exp(\phi^{\wedge})p-\exp(\phi^{\wedge})p}{\delta \phi}\\ & \approx \lim_{\delta \phi \to 0} \frac{(I+(\delta \phi)^{\wedge})\exp(\phi^{\wedge})p-\exp(\phi^{\wedge})p}{\delta \phi}\\ & = \lim_{\delta \phi \to 0} \frac{(\delta \phi)^{\wedge}Rp}{\delta \phi} = -(Rp)^{\wedge} \end{align*}同理可得，$SE(3)$上的扰动模型（左乘微小量）为：\frac{\partial (Tp)}{\partial \delta \xi}= \begin{bmatrix} I & -(Rp+t)^{\wedge}\\ {\bf 0}^{T} & {\bf 0}^{T} \end{bmatrix} \triangleq (Tp)^{\odot}相似变换对于单目视觉，由于存在尺度不确定性，因此不能使用$SE(3)$来表达位姿变化，而是利用相似变换群$Sim(3)$，也就是说要加一个尺度因子$s$，这个尺度因子会同时作用在变换的点$p$上，对其进行缩放，也就是在相机坐标系下进行了一次相似变换，而不是欧式变换，即：$p^{‘} = sRp+t$Sim(3)=\left\{\left[ \begin{array}{lll}{\boldsymbol{S}=} & {\boldsymbol{s} \boldsymbol{R}} & {\boldsymbol{t}} \\ {\boldsymbol{0}^{T}} & {1}\end{array}\right] \in \mathbb{R}^{4 \times 4}\right\}\mathfrak sim(3)=\left\{\zeta | \zeta=\left[ \begin{array}{l}{\rho} \\ {\phi} \\ {\sigma}\end{array}\right] \in \mathbb{R}^{7}, \zeta^{\wedge}=\left[ \begin{array}{cc}{\sigma I+\phi^{\wedge}} & {\rho} \\ {0^{T}} & {0}\end{array}\right] \in \mathbb{R}^{4 \times 4}\right\}\exp \left(\zeta^{\wedge}\right)=\left[ \begin{array}{cc}{e^{\sigma} \exp \left(\phi^{\wedge}\right)} & {J_{s} \rho} \\ {0^{T}} & {1}\end{array}\right]\begin{aligned} J_{s}=& \frac{e^{\sigma}-1}{\sigma} I+\frac{\sigma e^{\sigma} \sin \theta+\left(1-e^{\sigma} \cos \theta\right) \theta}{\sigma^{2}+\theta^{2}} a^{\wedge} \\ &+\left(\frac{e^{\sigma}-1}{\sigma}-\frac{\left(e^{\sigma} \cos \theta-1\right) \sigma+\left(e^{\sigma} \sin \theta\right) \theta}{\sigma^{2}+\theta^{2}}\right) a^{\wedge} a^{\wedge} \end{aligned}s=e^{\sigma}, \boldsymbol{R}=\exp \left(\boldsymbol{\phi}^{\wedge}\right), \boldsymbol{t}=\boldsymbol{J}_{s} \boldsymbol{\rho}对于$Sim(3)$的求导，利用左扰动模型和BCH近似（这里的BCH近似与$SE(3)$公式不同）。假设点$p$经过相似变换$Sp$后，相对于$S$的导数为：\frac{\partial S p}{\partial \zeta}=\left[ \begin{array}{ccc}{\boldsymbol{I}} & {-\boldsymbol{q}^{\wedge}} & {\boldsymbol{q}} \\ {\mathbf{0}^{T}} & {\mathbf{0}^{T}} & {0}\end{array}\right]其中$q$是$Sp$的前三维向量，最后的形式应该是$4 \times 7$的雅可比矩阵。有关相似变换群的更为详细的理解和运用，等后面进行实际应用时再说，毕竟库已经提供好了，而且推导过程也与$SE(3)$类似。作业与实践群的性质群要满足封闭性，结合律，幺元和逆这四个性质。其中，满足前两个性质的叫半群，满足前三个性质的叫有单位元的半群，若满足了上述四个性质，还具有交换律的叫做阿贝尔群。对于$\left \{ \mathbb Z, + \right \}$封闭性和结合律显然满足，幺元是0，逆为自身的相反数，因此是群，而且是阿贝尔群。对于$\left \{ \mathbb N, +\right \}$，前三个性质都满足，幺元是0，但是除了0之外，其他的元素不存在逆，因此不是群，是有单位元的半群。验证向量叉乘的李代数性质设${\bf X}=a_{1}\vec{i}+b_{1}\vec{j}+c_{1}\vec{k}, {\bf Y}=a_{2}\vec{i}+b_{2}\vec{j}+c_{2}\vec{k}, {\bf Z}=a_{3}\vec{i}+b_{3}\vec{j}+z_{3}\vec{k}$封闭性：[{\bf X},{\bf Y}] = {\bf X} \times {\bf Y} \in \mathbb R^{3}双线性：\begin{align*} & [a{\bf X}+b{\bf Y},{\bf Z}]=(a{\bf X}+b{\bf Y}) \times {\bf Z}=a{\bf X}\times {\bf Z}+b{\bf Y} \times {\bf Z} = a[{\bf X,Z}]+b[{\bf Y,Z}]\\ & [{\bf Z},a{\bf X}+b{\bf Y}]={\bf Z} \times (a{\bf X}+b{\bf Y})={\bf Z}\times a {\bf X}+{\bf Z} \times b{\bf Y}=a[{\bf Z,X}]+b[{\bf Z,Y}] \end{align*}自反性：[{\bf X,X}]={\bf X} \times {\bf X}={\bf 0}雅可比等价：\begin{align*} &[{\bf X},[{\bf Y,Z}]]+[{\bf Y},[{\bf Z,X}]]+[{\bf Z},[{\bf X,Y}]]\\ & ={\bf X} \times {\bf Y} \times {\bf Z}+{\bf Y} \times {\bf Z} \times {\bf X}+{\bf Z} \times {\bf X} \times {\bf Y}\\ & = {\bf X}^{\wedge} {\bf Z}^{\wedge} {\bf Y}+{\bf Y}^{\wedge} {\bf X}^{\wedge} {\bf Z}+{\bf Z}^{\wedge} {\bf Y}^{\wedge} {\bf X}\\ & = \begin{bmatrix} 0 & -c_{1} & b_{1}\\ c_{1} & 0 & -a_{1}\\ -b_{1} & a_{1} &0 \end{bmatrix} \begin{bmatrix} 0 & -c_{3} & b_{3}\\ c_{3} & 0 & -a_{3}\\ -b_{3} & a_{3} & 0 \end{bmatrix} \begin{bmatrix} a_{2}\\ b_{2}\\ c_{2} \end{bmatrix} + \begin{bmatrix} 0 & -c_{2} & b_{2}\\ c_{2} & 0 & -a_{2}\\ -b_{2} & a_{2} &0 \end{bmatrix} \begin{bmatrix} 0 & -c_{1} & b_{1}\\ c_{1} & 0 & -a_{1}\\ -b_{1} & a_{1} & 0 \end{bmatrix} \begin{bmatrix} a_{3}\\ b_{3}\\ c_{3} \end{bmatrix} + \begin{bmatrix} 0 & -c_{3} & b_{3}\\ c_{3} & 0 & -a_{3}\\ -b_{3} & a_{3} &0 \end{bmatrix} \begin{bmatrix} 0 & -c_{2} & b_{2}\\ c_{2} & 0 & -a_{2}\\ -b_{2} & a_{2} & 0 \end{bmatrix} \begin{bmatrix} a_{1}\\ b_{1}\\ c_{1} \end{bmatrix} \\ & = \begin{bmatrix} a_{3}(b_{1}b_{2}+c_{1}c_{2})-a_{2}(b_{1}b_{3}+c_{1}c_{3})\\ b_{3}(a_{1}a_{2}+c_{1}c_{2})-b_{2}(a_{1}a_{3}+c_{1}c_{3})\\ c_{3}(a_{1}a_{2}+b_{1}b_{2})-c_{2}(b_{1}b_{3}+a_{1}a_{3}) \end{bmatrix} + \begin{bmatrix} a_{1}(b_{2}b_{3}+c_{2}c_{3})-a_{3}(b_{1}b_{2}+c_{1}c_{2})\\ b_{1}(a_{2}a_{3}+c_{2}c_{3})-b_{3}(a_{1}a_{2}+c_{1}c_{2})\\ c_{1}(a_{2}a_{3}+b_{2}b_{3})-c_{3}(b_{1}b_{2}+a_{1}a_{2}) \end{bmatrix} + \begin{bmatrix} a_{2}(b_{1}b_{3}+c_{1}c_{3})-a_{1}(b_{2}b_{3}+c_{1}c_{3})\\ b_{2}(a_{1}a_{3}+c_{1}c_{3})-b_{1}(a_{2}a_{3}+c_{1}c_{3})\\ c_{2}(a_{1}a_{3}+b_{1}b_{3})-c_{1}(b_{2}b_{3}+a_{1}a_{3}) \end{bmatrix} \\ & = \begin{bmatrix} 0\\ 0\\ 0 \end{bmatrix} ={\bf 0} \end{align*}则$\mathfrak g =(\mathbb R^{3}, \mathbb R, \times)$构成李代数。推导$SE(3)$的指数映射推导$SE(3)$指数映射部分左雅可比的形式：\begin{align*} J & \triangleq \sum_{n=0}^{\infty} \frac{1}{(n+1)!}(\phi ^{\wedge})^{n}=\sum_{n=0}^{\infty} \frac{1}{(n+1)!}(\theta a^{\wedge})^{n}\\ & =I+\frac{1}{2!}\theta a^{\wedge}+\frac{1}{3!} \theta^{2}a^{\wedge}a^{\wedge}-\frac{1}{4!}\theta^{3}a^{\wedge}a^{\wedge}a^{\wedge}+\frac{1}{5!}\theta^{4}a^{\wedge}a^{\wedge}a^{\wedge}a^{\wedge}+\cdots\\ & =aa^{T}-a^{\wedge}a^{\wedge}+\frac{1}{2!}\theta a^{\wedge}+\frac{1}{3!}\theta^{2}a^{\wedge}a^{\wedge}-\frac{1}{4!}\theta^{3}a^{\wedge}-\frac{1}{5!}\theta^{4}a^{\wedge}a^{\wedge}+\cdots \\ & = \frac{1}{\theta}\left \{ aa^{T}\theta-a^{\wedge}a^{\wedge}\theta+a^{\wedge}-a^{\wedge}+\frac{1}{2!}\theta^{2}a^{\wedge}+\frac{1}{3!}\theta^{3}a^{\wedge}a^{\wedge}-\frac{1}{4!}\theta^{4}a^{\wedge}-\frac{1}{5!}\theta^{5}a^{\wedge}a^{\wedge}+\cdots \right \} \\ & = \frac{1}{\theta} \left \{ aa^{T}\theta - a^{\wedge}a^{\wedge}(\theta-\frac{1}{3!}\theta^{3}+\frac{1}{5!}\theta^{5}+\cdots)-a^{\wedge}(1-\frac{1}{2!}\theta^{2}+\frac{1}{4!}\theta^{4}+\cdots)+a^{\wedge} \right\}\\ & = \frac{1}{\theta} \left \{ aa^{T}\theta - a^{\wedge}a^{\wedge}\sin \theta -a^{\wedge}\cos \theta +a^{\wedge} \right \}\\ & = \frac{1}{\theta} \left \{ aa^{T}\theta-\sin \theta (aa^{T}-I)+a^{\wedge}(1-\cos \theta) \right \} \\ & = \frac{1}{\theta} \left \{ \sin \theta I +(\theta-\sin \theta)aa^{T}+(1-\cos \theta)a^{\wedge} \right \} \\ & = \frac{\sin \theta}{\theta}I + (1-\frac{\sin \theta}{\theta})aa^{T}+\frac{1-\cos \theta}{\theta}a^{\wedge} \end{align*}至于为什么雅可比矩阵是这种形式，即$J=\sum_{n=0}^{\infty} \frac{1}{(n+1)!}(\phi ^{\wedge})^{n}$是从何而来的，这个在state estimation for robotics一书的223-226有讲到，但是写的很抽象，下面给出证明：\begin{align*} & \xi ^{\wedge} = \begin{bmatrix} \phi ^{\wedge} & \rho \\ {\bf 0}^{T} & 0 \end{bmatrix} \\ & \xi ^{\wedge} \xi^{\wedge}= \begin{bmatrix} \phi ^{\wedge} & \rho \\ {\bf 0}^{T} & 0 \end{bmatrix} \begin{bmatrix} \phi ^{\wedge} & \rho \\ {\bf 0}^{T} & 0 \end{bmatrix} =\phi ^{\wedge} \xi^{\wedge} \\ & \xi^{\wedge}\xi^{\wedge}\xi^{\wedge}=(\phi ^{\wedge})^{2}\xi^{\wedge} \end{align*}\begin{align*} \exp(\xi ^{\wedge}) & = \sum_{n=0}^{\infty}\frac{1}{n!}(\xi ^{\wedge})^{n}\\ & = I+\xi^{\wedge}+\frac{1}{2!}\xi^{\wedge}\xi^{\wedge}+\frac{1}{3!}\xi^{\wedge}\xi^{\wedge}\xi^{\wedge}+\cdots \\ & =I+\xi^{\wedge}+\frac{1}{2!}\phi^{\wedge}\xi^{\wedge}+\frac{1}{3!}(\phi^{\wedge})^{2}\xi^{\wedge}+\cdots \\ & = I+\sum_{n=0}^{\infty}\frac{1}{(n+1)!}(\phi^{\wedge})^{n}\xi^{\wedge}\\ & = \begin{bmatrix} I+\sum_{n=0}^{\infty}\frac{1}{(n+1)!}(\phi^{\wedge})^{n+1} & \sum_{n=0}^{\infty}\frac{1}{(n+1)!}(\phi^{\wedge})^{n}\rho \\ {\bf 0}^{T} & 1 \end{bmatrix} \\ & = \begin{bmatrix} \sum_{n=0}^{\infty}\frac{1}{n!}(\phi^{\wedge})^{n} & \sum_{n=0}^{\infty}\frac{1}{(n+1)!}(\phi^{\wedge})^{n}\rho \\ {\bf 0}^{T} & 1 \end{bmatrix} \end{align*}伴随先证明$\forall a \in \mathbb R^{3}, Ra^{\wedge}R^{T}=(Ra)^{\wedge}$,高翔提供的网址的证明不严谨，即(Ra)^{\wedge}v=(Ra)\times v =(Ra) \times (RR^{-1}v)=R(a \times R^{-1}v)=Ra^{\wedge}R^{-1}vAB=BC,不能推导出A \neq B \quad\text{A,B,C是矩阵}下面通过旋转矩阵正交的性质来证明该式成立。\begin{align*} & 设旋转矩阵R= \begin{bmatrix} {\bf r}_{1} & {\bf r}_{2} & {\bf r}_{3} \end{bmatrix} \quad \text{这里的${\bf r}_{1},{\bf r}_{2},{\bf r}_{3}$既可以看作是$1 \times 3$的单位向量，也可以看作是矩阵，因此下面不再进行区分}\\ & 对于Rp^{\wedge}R^{T} = (Rp)^{\wedge} \iff p^{\wedge}=R^{T}(Rp)^{\wedge}R，因此转为证明后式\\ \end{align*}在证明之前，有两个事项需要注意：1.${\bf r}_{i}^{T} {\bf r}_{j}={\bf r}_{i} \cdot {\bf r}_{j}$ 前面可以看作矩阵，后面看作向量点乘，${\bf r}$是列向量2.因为$R$是旋转矩阵，因此行向量和列向量都是单位向量且两两正交。为了后面叉乘运算的一致性，需要将${\bf r}_{1},{\bf r}_{2},{\bf r}_{3}$分别看成三维正交坐标系的$x,y,z$轴，即：\begin{cases} {\bf r}_{1} \times {\bf r}_{2} = {\bf r}_{1}^{\wedge}{\bf r}_{2}={\bf r}_{3}\\ {\bf r}_{2} \times {\bf r}_{3} = {\bf r}_{2}^{\wedge}{\bf r}_{3}={\bf r}_{1}\\ {\bf r}_{3} \times {\bf r}_{1} = {\bf r}_{3}^{\wedge}{\bf r}_{1}={\bf r}_{2} \end{cases}\begin{align*} p^{\wedge} & = R^{T}(Rp)^{\wedge}R \\ & = \begin{bmatrix} {\bf r}_{1}^{T}\\ {\bf r}_{2}^{T}\\ {\bf r}_{3}^{T} \end{bmatrix} (\begin{bmatrix} {\bf r}_{1} & {\bf r}_{2} & {\bf r}_{3} \end{bmatrix} \begin{bmatrix} p_{1}\\ p_{2}\\ p_{3} \end{bmatrix})^{\wedge} \begin{bmatrix} {\bf r}_{1} & {\bf r}_{2} & {\bf r}_{3} \end{bmatrix} \\ & = \begin{bmatrix} {\bf r}_{1}^{T}\\ {\bf r}_{2}^{T}\\ {\bf r}_{3}^{T} \end{bmatrix} ({\bf r}_{1}p_{1}+{\bf r}_{2}p_{2}+{\bf r}_{3}p_{3})^{\wedge} \begin{bmatrix} {\bf r}_{1} & {\bf r}_{2} & {\bf r}_{3} \end{bmatrix} \\ & = \begin{bmatrix} {\bf r}_{1}^{T}\\ {\bf r}_{2}^{T}\\ {\bf r}_{3}^{T} \end{bmatrix} ({\bf r}_{1}^{\wedge}p_{1}+{\bf r}_{2}^{\wedge}p_{2}+{\bf r}_{3}^{\wedge}p_{3}) \begin{bmatrix} {\bf r}_{1} & {\bf r}_{2} & {\bf r}_{3} \end{bmatrix} \\ & = p_{1} \begin{bmatrix} {\bf r}_{1}^{T}\\ {\bf r}_{2}^{T}\\ {\bf r}_{3}^{T} \end{bmatrix} {\bf r}_{1}^{\wedge} \begin{bmatrix} {\bf r}_{1} & {\bf r}_{2} & {\bf r}_{3} \end{bmatrix} + p_{2} \begin{bmatrix} {\bf r}_{1}^{T}\\ {\bf r}_{2}^{T}\\ {\bf r}_{3}^{T} \end{bmatrix} {\bf r}_{2}^{\wedge} \begin{bmatrix} {\bf r}_{1} & {\bf r}_{2} & {\bf r}_{3} \end{bmatrix} + p_{3} \begin{bmatrix} {\bf r}_{1}^{T}\\ {\bf r}_{2}^{T}\\ {\bf r}_{3}^{T} \end{bmatrix} {\bf r}_{3}^{\wedge} \begin{bmatrix} {\bf r}_{1} & {\bf r}_{2} & {\bf r}_{3} \end{bmatrix} \\ & = p_{1} \begin{bmatrix} {\bf r}_{1}^{T} {\bf r}_{1}^{\wedge} {\bf r}_{1} & {\bf r}_{1}^{T} {\bf r}_{1}^{\wedge} {\bf r}_{2} & {\bf r}_{1}^{T} {\bf r}_{1}^{\wedge} {\bf r}_{3}\\ {\bf r}_{2}^{T} {\bf r}_{1}^{\wedge} {\bf r}_{1} & {\bf r}_{2}^{T} {\bf r}_{1}^{\wedge} {\bf r}_{2} & {\bf r}_{2}^{T} {\bf r}_{1}^{\wedge} {\bf r}_{3}\\ {\bf r}_{3}^{T} {\bf r}_{1}^{\wedge} {\bf r}_{1} & {\bf r}_{3}^{T} {\bf r}_{1}^{\wedge} {\bf r}_{2} & {\bf r}_{3}^{T} {\bf r}_{1}^{\wedge} {\bf r}_{3}\\ \end{bmatrix} + p_{2} \begin{bmatrix} {\bf r}_{1}^{T} {\bf r}_{2}^{\wedge} {\bf r}_{1} & {\bf r}_{1}^{T} {\bf r}_{2}^{\wedge} {\bf r}_{2} & {\bf r}_{1}^{T} {\bf r}_{2}^{\wedge} {\bf r}_{3}\\ {\bf r}_{2}^{T} {\bf r}_{2}^{\wedge} {\bf r}_{1} & {\bf r}_{2}^{T} {\bf r}_{2}^{\wedge} {\bf r}_{2} & {\bf r}_{2}^{T} {\bf r}_{2}^{\wedge} {\bf r}_{3}\\ {\bf r}_{3}^{T} {\bf r}_{2}^{\wedge} {\bf r}_{1} & {\bf r}_{3}^{T} {\bf r}_{2}^{\wedge} {\bf r}_{2} & {\bf r}_{3}^{T} {\bf r}_{2}^{\wedge} {\bf r}_{3}\\ \end{bmatrix} + p_{3} \begin{bmatrix} {\bf r}_{1}^{T} {\bf r}_{3}^{\wedge} {\bf r}_{1} & {\bf r}_{1}^{T} {\bf r}_{3}^{\wedge} {\bf r}_{2} & {\bf r}_{1}^{T} {\bf r}_{3}^{\wedge} {\bf r}_{3}\\ {\bf r}_{2}^{T} {\bf r}_{3}^{\wedge} {\bf r}_{1} & {\bf r}_{2}^{T} {\bf r}_{3}^{\wedge} {\bf r}_{2} & {\bf r}_{2}^{T} {\bf r}_{3}^{\wedge} {\bf r}_{3}\\ {\bf r}_{3}^{T} {\bf r}_{3}^{\wedge} {\bf r}_{1} & {\bf r}_{3}^{T} {\bf r}_{3}^{\wedge} {\bf r}_{2} & {\bf r}_{3}^{T} {\bf r}_{3}^{\wedge} {\bf r}_{3}\\ \end{bmatrix} \\ & = p_{1} \begin{bmatrix} 0 & 0 & 0\\ 0 & 0 & -1\\ 0 & 1 & 0 \end{bmatrix} + p_{2} \begin{bmatrix} 0 & 0 & 1\\ 0 & 0 & 0\\ -1 & 0 & 0 \end{bmatrix} + p_{3} \begin{bmatrix} 0 & -1 & 0\\ 1 & 0 & 0\\ 0 & 0 & 0 \end{bmatrix} \\ & = \begin{bmatrix} 0 & -p_{3} & p_{2}\\ p_{3} & 0 & -p_{1}\\ -p_{2} & p_{1} & 0 \end{bmatrix} \end{align*}对于$SO(3)$上的伴随的证明只需进行泰勒展开即可，与上面的证明相同。\begin{align*} & \exp ((Ad(R)P)^{\wedge}) = \exp ((Rp)^{\wedge})=\exp (Rp^{\wedge}R^{T})=\exp (R\theta a^{\wedge}R^{T})=\sum _{n=0}^{\infty}\frac{1}{n!}(R\theta a^{\wedge}R^{T})^{n} \\ & 令p=\theta a,a是单位向量，\theta为模长\\ & Ra^{\wedge}R^{T} Ra^{\wedge}R^{T} =Ra^{\wedge}a^{\wedge}R^{T}=R(aa^{T}-I)R^{T}=Raa^{T}R^{T}-I\\ & Ra^{\wedge}R^{T} Ra^{\wedge}R^{T} Ra^{\wedge}R^{T} =Ra^{\wedge}a^{\wedge}a^{\wedge}R^{T}=-Ra^{\wedge}R^{T} \end{align*}泰勒展开后的式子利用正余弦函数表示，结果为：\begin{align*} \exp(Rp^{\wedge}R^{T}) & = \sum _{n=0}^{\infty}\frac{1}{n!}(\theta R a^{\wedge}R^{T})^{n}\\ & = (1-\cos \theta)Raa^{T}R^{T}+\cos \theta I+\sin \theta Ra^{\wedge}R^{T}\\ & =R((1-\cos \theta)aa^{T}+\cos \theta I+\sin \theta a^{\wedge})R^{T}\\ & =R \exp(p^{\wedge})R^{T} \end{align*}对于$SE(3)$的伴随$Ad(T)$有：\begin{align*} & T\exp (\xi ^{\wedge})T^{-1} = \exp((Ad(T)\xi )^{\wedge})\\ & Ad(T)= \begin{bmatrix} R & t^{\wedge}R\\ {\bf 0} & R \end{bmatrix} \end{align*}$SO(3)$和$SE(3)$的伴随将在后面的位姿图优化中用到。轨迹的描绘1.$T_{WC}$是相机坐标系到世界坐标系的变换矩阵，其平移部分就是相机的移动距离，我们在解算位姿的时候是计算两帧之间的位姿，因此平移部分连起来就是相机的轨迹，即机器人的轨迹。实际上，$T_{WC}$和$T_{CW}$之间只差了一个逆而已，都可以用来表示相机的位姿，但是实践当中使用$T_{CW}$更为常见，不过$T_{WC}$更为直观，因为$p_{W} =T_{WC}p_{C}=Rp_{C}+t_{WC}$对于相机原点来说，$p_{W}$就是在其对应于世界坐标系的点，而且正是$T_{WC}$的平移部分，那么连起来就可以看到相机的平移轨迹。2.仿照ORB-SLAM2里的CMakeLists.txt写的CMakeLists.txt123456789101112131415161718192021222324252627282930313233343536cmake_minimum_required(VERSION 2.8)project(trajectorydrawing)set(CMAKE_BUILD_TYPE &quot;Release&quot;)# check C++11 or C++0x supportinclude(CheckCCompilerFlag)include(CheckCXXCompilerFlag)CHECK_CXX_COMPILER_FLAG(&quot;-std=c++11&quot; COMPILER_SUPPORTS_CXX11)CHECK_CXX_COMPILER_FLAG(&quot;-std=c++0x&quot; COMPILER_SUPPORTS_CXX0X)if(COMPILER_SUPPORTS_CXX11) set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;) add_definitions(-DCOMPILEDWITHC11) message(STATUS &quot;Using flag -std=c++11.&quot;)elseif(COMPILER_SUPPORTS_CXX0X) set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++0x&quot;) add_definitions(-DCOMPILEDWITHC0X) message(STATUS &quot;Using flag -std=c++0x.&quot;)else() message(FATAL_ERROR &quot;The compiler $&#123;CMAKE_CXX_COMPILER&#125; has no C++11 support. Please use a different C++ compiler.&quot;)endif()find_package(Eigen3 REQUIRED)find_package(Pangolin REQUIRED)find_package(Sophus REQUIRED)include_directories( $&#123;EIGEN3_SOURCE_DIR&#125; $&#123;Pangolin_INCLUDE_DIR&#125; $&#123;Sophus_INCLUDE_DIR&#125;)add_executable(trajectorydrawing draw_trajectory.cpp)target_link_libraries(trajectorydrawing $&#123;EIGEN3_LIBRARIES&#125; $&#123;Pangolin_LIBRARIES&#125; $&#123;Sophus_LIBRARIES&#125;)读取数据的代码如下：12345678910111213141516171819202122232425262728293031323334353637383940// 第一种方法，用fstream的getline分行读取 ifstream fin(trajectory_file); //从文件中读取数据 if(!fin.is_open())&#123; cout&lt;&lt;&quot;No &quot;&lt;&lt;trajectory_file&lt;&lt;endl; return 0; &#125; double t,tx,ty,tz,qx,qy,qz,qw; string line; while(getline(fin,line)) &#123; istringstream record(line); //从string读取数据 record&gt;&gt;t&gt;&gt;tx&gt;&gt;ty&gt;&gt;tz&gt;&gt;qx&gt;&gt;qy&gt;&gt;qz&gt;&gt;qw; Eigen::Vector3d p(tx,ty,tz); Eigen::Quaterniond q = Eigen::Quaterniond(qw,qx,qy,qz).normalized(); Sophus::SE3 SE3_qp(q,p); poses.push_back(SE3_qp); &#125; //第二种方法 // ifstream in(trajectory_file);//创建输入流 // if(!in)&#123; // cout&lt;&lt;&quot;open posefile failture!!!&quot;&lt;&lt;endl; // return 0; // &#125; // for(int i=0; i&lt;620; i++)&#123; // double data[8]=&#123;0&#125;; // for(auto&amp; d:data) in&gt;&gt;d;//按行依次去除数组中的值 // Eigen::Quaterniond q(data[7], data[8], data[5], data[6]); // Eigen::Vector3d t(data[1], data[2], data[3]); // Sophus::SE3 SE3(q,t); // poses.push_back(SE3); // &#125; // end your code here生成的轨迹图如下：轨迹的误差CMakeLists.txt文件内容如下：123456789101112131415161718192021222324252627282930313233343536cmake_minimum_required(VERSION 2.8)project(trajectory_error)set(CMAKE_BUILD_TYPE &quot;Release&quot;)# check C++11 or C++0x supportinclude(CheckCCompilerFlag)include(CheckCXXCompilerFlag)CHECK_CXX_COMPILER_FLAG(&quot;-std=c++11&quot; COMPILER_SUPPORTS_CXX11)CHECK_CXX_COMPILER_FLAG(&quot;-std=c++0x&quot; COMPILER_SUPPORTS_CXX0X)if(COMPILER_SUPPORTS_CXX11) set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;) add_definitions(-DCOMPILEDWITHC11) message(STATUS &quot;Using flag -std=c++11.&quot;)elseif(COMPILER_SUPPORTS_CXX0X) set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++0x&quot;) add_definitions(-DCOMPILEDWITHC0X) message(STATUS &quot;Using flag -std=c++0x.&quot;)else() message(FATAL_ERROR &quot;The compiler $&#123;CMAKE_CXX_COMPILER&#125; has no C++11 support. Please use a different C++ compiler.&quot;)endif()find_package(Eigen3 REQUIRED)find_package(Pangolin REQUIRED)find_package(Sophus REQUIRED)include_directories( $&#123;EIGEN3_SOURCE_DIR&#125; $&#123;Pangolin_INCLUDE_DIR&#125; $&#123;Sophus_INCLUDE_DIR&#125;)add_executable(trajectory_error trajectory_error.cpp)target_link_libraries(trajectory_error $&#123;EIGEN3_LIBRARIES&#125; $&#123;Pangolin_LIBRARIES&#125; $&#123;Sophus_LIBRARIES&#125;)trajectory_error.cpp文件内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;sophus/se3.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cmath&gt;#include &lt;pangolin/pangolin.h&gt;#include &lt;Eigen/Core&gt;#include &lt;Eigen/Geometry&gt; using namespace std;using namespace Eigen; void ReadData(string FileName ,vector&lt;Sophus::SE3, Eigen::aligned_allocator&lt;Sophus::SE3&gt;&gt; &amp;poses);double ErrorTrajectory(vector&lt;Sophus::SE3, Eigen::aligned_allocator&lt;Sophus::SE3&gt;&gt; poses_g, vector&lt;Sophus::SE3, Eigen::aligned_allocator&lt;Sophus::SE3&gt;&gt; poses_e);void DrawTrajectory(vector&lt;Sophus::SE3, Eigen::aligned_allocator&lt;Sophus::SE3&gt;&gt; poses_g, vector&lt;Sophus::SE3, Eigen::aligned_allocator&lt;Sophus::SE3&gt;&gt; poses_e); int main(int argc, char **argv)&#123; string GroundFile = &quot;./groundtruth.txt&quot;; string ErrorFile = &quot;./estimated.txt&quot;; double trajectory_error_RMSE = 0; vector&lt;Sophus::SE3, Eigen::aligned_allocator&lt;Sophus::SE3&gt;&gt; poses_g; vector&lt;Sophus::SE3, Eigen::aligned_allocator&lt;Sophus::SE3&gt;&gt; poses_e; ReadData(GroundFile,poses_g); ReadData(ErrorFile,poses_e); trajectory_error_RMSE = ErrorTrajectory(poses_g, poses_e); cout&lt;&lt;&quot;trajectory_error_RMSE = &quot;&lt;&lt; trajectory_error_RMSE&lt;&lt;endl; DrawTrajectory(poses_g,poses_e); &#125; /***************************读取文件的数据，并存储到vector类型的pose中**************************************/void ReadData(string FileName ,vector&lt;Sophus::SE3, Eigen::aligned_allocator&lt;Sophus::SE3&gt;&gt; &amp;poses)&#123; ifstream fin(FileName); //从文件中读取数据 //这句话一定要加上，保证能够正确读取文件。如果没有正确读取，结果显示-nan if(!fin.is_open())&#123; cout&lt;&lt;&quot;No &quot;&lt;&lt;FileName&lt;&lt;endl; return; &#125; double t,tx,ty,tz,qx,qy,qz,qw; string line; while(getline(fin,line)) &#123; istringstream record(line); //从string读取数据 record &gt;&gt; t &gt;&gt; tx &gt;&gt; ty &gt;&gt; tz &gt;&gt; qx &gt;&gt; qy &gt;&gt; qz &gt;&gt; qw; Eigen::Vector3d p(tx, ty, tz); Eigen::Quaterniond q = Eigen::Quaterniond(qw, qx, qy, qz).normalized(); //四元数的顺序要注意 Sophus::SE3 SE3_qp(q, p); poses.push_back(SE3_qp); &#125; &#125; /*******************************计算轨迹误差*********************************************/double ErrorTrajectory(vector&lt;Sophus::SE3, Eigen::aligned_allocator&lt;Sophus::SE3&gt;&gt; poses_g, vector&lt;Sophus::SE3, Eigen::aligned_allocator&lt;Sophus::SE3&gt;&gt; poses_e )&#123; double RMSE = 0; Matrix&lt;double ,6,1&gt; se3; vector&lt;double&gt; error; for(int i=0;i&lt;poses_g.size();i++)&#123; se3=(poses_g[i].inverse()*poses_e[i]).log(); //这里的se3为向量形式，求log之后是向量形式 //cout&lt;&lt;se3.transpose()&lt;&lt;endl; error.push_back( se3.squaredNorm() ); //二范数 // cout&lt;&lt;error[i]&lt;&lt;endl; &#125; for(int i=0; i&lt;poses_g.size();i++)&#123; RMSE += error[i]; &#125; RMSE /= double(error.size()); RMSE = sqrt(RMSE); return RMSE;&#125;/*****************************绘制轨迹*******************************************/void DrawTrajectory(vector&lt;Sophus::SE3, Eigen::aligned_allocator&lt;Sophus::SE3&gt;&gt; poses_g, vector&lt;Sophus::SE3, Eigen::aligned_allocator&lt;Sophus::SE3&gt;&gt; poses_e) &#123; if (poses_g.empty() || poses_e.empty()) &#123; cerr &lt;&lt; &quot;Trajectory is empty!&quot; &lt;&lt; endl; return; &#125; // create pangolin window and plot the trajectory pangolin::CreateWindowAndBind(&quot;Trajectory Viewer&quot;, 1024, 768); //创建一个窗口 glEnable(GL_DEPTH_TEST); //启动深度测试 glEnable(GL_BLEND); //启动混合 glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);//混合函数glBlendFunc( GLenum sfactor , GLenum dfactor );sfactor 源混合因子dfactor 目标混合因子 pangolin::OpenGlRenderState s_cam( pangolin::ProjectionMatrix(1024, 768, 500, 500, 512, 389, 0.1, 1000), pangolin::ModelViewLookAt(0, -0.1, -1.8, 0, 0, 0, 0.0, -1.0, 0.0) //对应的是gluLookAt,摄像机位置,参考点位置,up vector(上向量) ); pangolin::View &amp;d_cam = pangolin::CreateDisplay() .SetBounds(0.0, 1.0, pangolin::Attach::Pix(175), 1.0, -1024.0f / 768.0f) .SetHandler(new pangolin::Handler3D(s_cam)); while (pangolin::ShouldQuit() == false) &#123; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); d_cam.Activate(s_cam); glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glLineWidth(2); for (size_t i = 0; i &lt; poses_g.size() - 1; i++) &#123; glColor3f(1 - (float) i / poses_g.size(), 0.0f, (float) i / poses_g.size()); glBegin(GL_LINES); auto p1 = poses_g[i], p2 = poses_g[i + 1]; glVertex3d(p1.translation()[0], p1.translation()[1], p1.translation()[2]); glVertex3d(p2.translation()[0], p2.translation()[1], p2.translation()[2]); glEnd(); &#125; for (size_t j = 0; j &lt; poses_e.size() - 1; j++) &#123; //glColor3f(1 - (float) j / poses_e.size(), 0.0f, (float) j / poses_e.size()); glColor3f(1.0f, 1.0f, 0.f);//为了区分第二条轨迹，用不同的颜色代替,黄色 glBegin(GL_LINES); auto p1 = poses_e[j], p2 = poses_e[j + 1]; glVertex3d(p1.translation()[0], p1.translation()[1], p1.translation()[2]); glVertex3d(p2.translation()[0], p2.translation()[1], p2.translation()[2]); glEnd(); &#125; pangolin::FinishFrame(); usleep(5000); // sleep 5 ms &#125; &#125;]]></content>
      <categories>
        <category>科研记录</category>
      </categories>
      <tags>
        <tag>visual SLAM</tag>
        <tag>Linux</tag>
        <tag>C++11</tag>
        <tag>Computer vision</tag>
        <tag>Sophus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[visual SLAM by Gaoxiang(2)]]></title>
    <url>%2Fposts%2FvisualSLAMbyGaoxiang-2%2F</url>
    <content type="text"><![CDATA[​本次课程主要研究三维空间刚体运动，即visual slam的运动方程中的$x_{k}$如何表达。点与坐标系在2D情况下，物体可以通过两个坐标和一个旋转角进行表达，即$(x,y,\theta)$。在3D情况下，物体是6自由度的，包括平移和旋转，每个都得用三个变量表达，可以认为3D情况是包含着3个2D的情况，旋转轴不同。理清坐标系（参考系），点，向量，向量的坐标，运动变换之间的关系。相机会有相机坐标系，机器人会有机体坐标系（通常是运动的），空间会有世界坐标系（通常是固定的），这都是为了研究问题的方便，通过变换进行运动的表述。熟悉向量的相关运算规则，比如，向量的加减法，向量的内积和外积。以及向量和矩阵的关系。\begin{align*} & 内积： \bf{a} \cdot \bf{b} =\bf{a^{T}} \bf{b}=\sum_{i=1}^{n}=|\bf{a}||\bf{b}| \cos \left< \bf{a}, \bf{b}\right> \\ &外积： \bf{a} \times \bf{b}= \begin{bmatrix} \bf{i} & \bf{j} & \bf{k} \\ a_{1} & a_{2} & a_{3} \\ b_{1} & b_{2} & b_{3} \end{bmatrix} = \begin{bmatrix} a_{2}b_{3}-a_{3}b_{2}\\ a_{3}b_{1}-a_{1}b_{3}\\ a_{1}b_{2}-a_{2}b_{1} \end{bmatrix} = \begin{bmatrix} 0 & -a_{3} & a_{2}\\ a_{3} & 0 & -a_{1} \\ -a_{2} & a_{1} & 0 \end{bmatrix} \bf{b} \triangleq \bf{a} ^{\wedge} \bf{b} \end{align*}建立了坐标系之后，如何表示同一个向量在不同坐标系之间的坐标，坐标系之间的变换关系又该如何描述。坐标系之间的变换可以分解成坐标系原点之间之间的平移和坐标轴之间的旋转，那么可以用一个平移向量和旋转矩阵来描述这样的变换。我们知道矩阵可以表述坐标系之间的变换，对于三维空间而言，可以用一个$4 \times 4$的矩阵来描述三维坐标系之间的变换，这也就是平移向量和旋转矩阵的合成矩阵，具体后面会细说。旋转矩阵一个向量在坐标系进行旋转后不变，因此可以通过此推导出旋转矩阵$R$的表达式（即用变换前后的坐标系的基向量进行表述）。\begin{bmatrix} a_{1}\\ a_{2}\\ a_{3} \end{bmatrix} = \begin{bmatrix} e_{1}^{T}e_{1}^{'} & e_{1}^{T}e_{2}^{'} & e_{1}^{T}e_{3}^{'}\\ e_{2}^{T}e_{1}^{'} & e_{2}^{T}e_{2}^{'} & e_{2}^{T}e_{3}^{'}\\ e_{3}^{T}e_{1}^{'} & e_{3}^{T}e_{2}^{'} & e_{3}^{T}e_{3}^{'} \end{bmatrix} \begin{bmatrix} a_{1}^{'}\\ a_{2}^{'}\\ a_{3}^{'} \end{bmatrix} \triangleq R {\bf a}^{'}旋转矩阵是正交矩阵（$RR^{T}=I$），且行列式为1（$\det (R)=1$）。旋转矩阵属于特殊正交群special orthogonal group，即：SO(n) = \lbrace R \in \mathbb{R}^{n \times n} | RR^{T}=I, \det(R)=1 \rbrace对一个旋转矩阵进行转置就描述了一个相反方向的旋转。欧拉旋转定理（Euler’s rotation theorem）：刚体在三维空间里的一般运动，可分解为刚体上方某一点的平移，以及绕经过此点的旋转轴的转动。{\bf a^{'}}= R \bf{a} + \bf{t}齐次形式（homogeneous）来更方便地表达变换，因为加上平移不满足线性性。定义变换矩阵$T$\begin{bmatrix} a^{'}\\ 1 \end{bmatrix} = \begin{bmatrix} R & \bf{t}\\ \bf{ 0^{T} } & 1 \end{bmatrix} \begin{bmatrix} a \\ 1 \end{bmatrix} \triangleq T \begin{bmatrix} a\\ 1 \end{bmatrix}齐次坐标认为其乘以任意非零常数时仍表达同一个坐标（归一化）。 变换矩阵的集合称为特殊欧式群special Euclidean Group:SE(3)=\lbrace T= \begin{bmatrix} R & \bf{t}\\ \bf{ 0^{T}} & 1 \end{bmatrix} \in \mathbb{R}^{4 \times 4} | R \in SO(3), \bf{t} \in \mathbb{R}^{3} \rbraceT^{-1}= \begin{bmatrix} R^{T} & -R^{T}{\bf t}\\ {\bf 0^{T}} & 1 \end{bmatrix}定义了变化矩阵后，多次变换可以直接对变换矩阵直接相乘即可。旋转向量与欧拉角一般来说视觉SLAM有旋转矩阵和平移向量就够了，一般也是用这样的方式表达。为了进行拓展，比如在航迹推算和组合导航中，通常用四元数来表述物体姿态。旋转矩阵有9个元素但仅表示三个自由度，比较冗余，因此引入旋转向量(rotation vector)，方向为旋转轴，长度为转过的角度，又称为角轴或轴角（angle axis）。旋转向量只有三个量，无约束，更加直观，但是旋转轴一般不容易得知，其中旋转向量和旋转矩阵的关系可以通过罗德里格斯公式得出（Rodrigues’ s Formula）：（假设旋转轴为$\bf{n}$，旋转角为$\theta$）\begin{align*} & R = \cos \theta {\bf I}+(1-\cos \theta){\bf n} {\bf n^{T}}+\sin \theta {\bf n^{\wedge}}\\ & \theta = \arccos(\frac{tr(R)-1}{2}) \\ & R{\bf n}=\bf{n} \quad特征值为1的特征向量 \end{align*}欧拉角（Euler Angles）将旋转分解成三个方向上的转动，最常见的是Z-Y-X，即yaw-pitch-roll（偏航-俯仰-横滚），不同领域习惯不同。但是欧拉角会有万向锁问题（gimbal lock)，会在特定值丢失一个自由度，存在奇异性问题，因此欧拉角不适合插值和迭代。实际上，仅用三个实数表达旋转时，会不可避免地存在奇异性问题。视觉SLAM中一般不用欧拉角表达姿态，主要在人机交互中用。四元数（Quaternion）2D情况下，可以用单位复数表达旋转，$z=x+iy=\rho e^{i \theta}$，乘$i$代表转转90度。3D情况下，类似地，四元数可作为复数地扩充。四元数有三个虚部和一个实部，${\bf q}=q_{0}+q_{1}i+q_{2}j+q_{3}k$，虚部之间满足关系（自己和自己运算像复数，自己和别人运算像叉乘）:\begin{cases} i^{2}=j^{2}=k^{2}=-1 \\ ij=k,jk=-k \\ jk=i.kj=-i \\ ki=j,ik=-j \end{cases}单位四元数可以表达旋转，${\bf q}=q_{0}+q_{1}i+q_{2}j+q_{3}k=[s, {\bf v}], s=q_{0}\in \mathbb{R}, {\bf v}=[q_{1}, q_{2}, q_{3}]^{T}\in \mathbb{R}^{3}$，四元数有以下地运算规则：{\bf q}_{a}+{\bf q}_{b}=[s_{a}\pm s_{b}, {\bf v}_{a}\pm {\bf v}_{b}]\\ \begin{align*} {\bf q}_{a}{\bf q}_{b}= &s_{a}s_{b}-x_{a}x_{b}-y_{a}y_{b}-z_{a}z_{b}\\ & +(s_{a}x_{b}+x_{a}s_{b}+y_{a}z_{b}-z_{a}y_{b})i\\ & +(s_{a}y_{b}-x_{a}z_{b}+y_{a}s_{b}+z_{a}x_{b})j\\ & +(s_{a}z_{b}+x_{a}y_{b}-y_{b}x_{a}+z_{a}s_{b})k \end{align*} \\ {\bf q}_{a}{\bf q}_{b}= [s_{a}s_{b}-{\bf v}_{a}^{T}{\bf v}_{b}, s_{a}{\bf v}_{b}+s_{b}{\bf v}_{a}+{\bf v}_{a} \times {\bf v}_{b}] \\ {\bf q}^{*}=s_{a}-x_{a}i-y_{a}j-z_{a}k=[s_{a}, -{\bf v}_{a}]\\ \left\| {\bf q}_{a} \right\|= \sqrt{s_{a}^{2}+x_{a}^{2}+y_{a}^{2}+z_{a}^{2}} \\ {\bf q}^{-1}={\bf q}^{*}/ \left\| {\bf q} \right\| ^{2}\\ k{\bf q}=[ks, k{\bf v}]\\ {\bf q}_{a} \cdot {\bf q}_{b}=s_{a}s_{b}+x_{a}x_{b}i+y_{a}y_{b}j+z_{a}z_{b}k四元数到角轴：${\bf q}=[\cos \frac{\theta}{2},n_{x}\sin \frac{\theta}{2}, n_{y}\sin \frac{\theta}{2}, n_{z}\sin \frac{\theta}{2}]^{T}$。角轴到四元数：$\theta =2 \arccos q_{0}, [n_{x}, n_{y}, n_{z}]^{T} = [q_{1}, q_{2}, q_{3}]^{T}/ \sin \frac{\theta}{2}$三维点$p(x,y,z)$经过一次以${\bf q}$表示的旋转后，得到了$p^{‘}$，${\bf p}=[0,x,y,z]=[0, {\bf v}]$，旋转之后的关系为${\bf p}^{‘}={\bf q} {\bf p} {\bf q}^{-1}$。四元数相比与角轴和欧拉角，形式上更加紧凑，也无奇异性。值得注意的是，${\bf q}$和$-{\bf q}$表示同一个旋转。学习四元数的一个最直观的问题就是为什么三个变量来描述三维旋转，诸如欧拉角会出现奇异性的情况，而用四个变量的四元数就不会？也就说用高维的东西描述低维的东西更加有效。知乎上有相关的回答，写得还算不错，比较直观。不过依旧没有解决为什么三个变量描述三维旋转会出现奇异性的现象。利用四元数来对三维点的旋转进行操作，是通过纯四元数来进行的，即变换后的点可以表示为${\bf qwq^{-1} }$，这里的问题是为什么这种形式。（注意，这里的四元数是单位四元数）汉密尔顿定义的性质：1.运算产生的结果也要是三维向量2.存在一个元运算，任何三维向量进行元运算的结果就是其本身3.对于任何一个运算，都存在一个逆运算，这两个运算的积是元运算4.运算满足结合律其实，四元数有四个变量，完全可以被看作一个四维向量。单位四元数（norm=1）则存在于四维空间的一个球面上。${\bf q}_{a} {\bf q}_{b}$，四元数${\bf q}_{a}$乘以四元数${\bf q}_{b}$其实看作（1）对${\bf q}_{a}$进行${\bf q}_{b}$左旋转，或者（2）对${\bf q}_{b}$进行${\bf q}_{a}$右旋转。所以从始至终，四元数定义的都是四维旋转，而不是三维旋转！任意的四维旋转都可以唯一的拆分为一个左旋转和一个右旋转，表达出来就是${\bf q}_{L}{\bf p}{\bf q}_{R}$。这里，我们对四元数（四维向量）${\bf p}$进行了一个${\bf q}_{L}$左旋转和一个${\bf q}_{R}$右旋转。结果当然是一个四元数，符合性质1。这个运算也同时符合性质2，3，4。为了进行三维旋转运算，汉密尔顿首先在四维空间里划出了一块三维空间。汉密尔顿定义了一种纯四元数（pure quaternion），其表达式为${\bf q}_{w}=(0,w_{x},w_{y},w_{z})$。纯四元数第一项为零，它存在于四维空间的三维超平面上，与三维空间中的三维向量一一对应。然后，就有了我们常见的${\bf q} {\bf q}_{w} {\bf q}^{*}$这种左乘单位四元数，右乘其共轭的表达式。这个运算形式是为了限制其运算结果所在的空间。简单的说，当对一个三维向量进行三维旋转后，我们希望得到的是一个三维向量，而不是四维向量。这也就解释了为什么四元数对应于角轴的关系式中是$\frac{\theta}{2}$，而不是$\theta$，这是因为${\bf q}$做的就是一个$\frac{\theta}{2}$的旋转，而${\bf q}^{-1}$也做了一个$\frac{\theta }{2}$的旋转。我们进行了两次旋转，而不是一次，这两次旋转的结果是一个旋转角为$\theta$的旋转。此外，还有一点是，四元数可以用2x2复数矩阵（特殊酉群）和4x4矩阵来描述，但是四元数之间不满足乘法交换律，即${\bf q}_{1} {\bf q}_{2} \ne {\bf q}_{2} {\bf q}_{1}$，但是二维平面里的复数相乘满足乘法交换律，这里我粗略地理解是，二维旋转只有角度，没有轴的概念，只有按照什么顺序旋转多少角度，因此先转$\theta$，再转$\alpha$，与先转$\alpha$，再转$\theta$的结果是一样的，但是四元数相乘不是，每次转都是有个旋转轴的，因此不可交换。有关四元数，旋转，群的理解和证明，可以参考这篇文章\begin {align*} {\bf v}^{'} & = {\bf v}_{||}^{'} + {\bf v}_{\bot}^{'}={\bf v}_{||} + {\bf q} {\bf v}_{\bot}\\ & = {\bf p} {\bf p}^{-1} {\bf v}_{\bot} + {\bf p} {\bf p} {\bf v}_{\bot}\\ & = {\bf p} {\bf p}^{*} {\bf v}_{\bot} + {\bf p} {\bf p} {\bf v}_{\bot}\\ & = {\bf p} {\bf v}_{||} {\bf p}^{*} + {\bf p} {\bf v}_{\bot} {\bf p}^{*}\\ & = {\bf p} ({\bf v}_{||}+{\bf v}_{\bot}) {\bf p}^{*}\\ & = {\bf p} {\bf v} {\bf p}^{*}\\ & = {\bf v}_{||} + {\bf p}^{2} {\bf v}_{\bot} \end{align*} \\ {\bf q}=[\cos \theta, \sin \theta ({\bf u})], {\bf p}=[\cos \frac{\theta}{2}, \sin \frac{\theta}{2} ({\bf u})],{\bf q}={\bf p}^{2}对于平行的分量，变换完全抵消，对于垂直的分量，施加两次变换，这也就是为什么是$\frac {\theta}{2}$。四元数与群：单位四元数与 3D 旋转有一个2对1满射同态关系，或者说单位四元数双倍覆盖了3D旋转。因为这个映射是满射，我们可以说所有的单位四元数都对应着一个 3D 旋转。或者说，一个四维单位超球面（也叫做$\mathbb S^{3}$）上任意一点所对应的四元数（$∥q∥ = 1$）都对应着一个 3D 旋转。四元数，旋转矩阵，群，geometric algebra都有着紧密的联系，因此可以先做好相关的功课，这里列出几篇阅读材料：Introduction to Lie GroupsGeometric Algebra Primeryoutube geometric algebraA Quaternion is a scalar plus a bivector.Apart from the fact that quaternions have four components, there is nothing four-dimensional or imaginary about a quaternion. The first component is a scalar, and the other three components form the bivector-plane relative to which the rotation is performed.这似乎解释了之前我的疑问，为什么要用四个变量来描述三维，就是用得用高维的解释低维的，这里指出了四元数拥有四个变量，但是不是指四维或者虚数，而是通过标量和bivector的组合来描述旋转，几何代数的这种形式统一了不同维度的旋转，因此比较优雅。不过更深层次的东西和理解涉及到比较多的数学知识和空间理解，我暂时还达不到。。。。作业与实践熟悉Eigen运算对于线性方程组$Ax=b$，其中$A$是方阵。1).什么条件下，$x$有解且唯一？当矩阵$A$可逆的时候，也就是此时矩阵满秩。2).高斯消元法原理高斯消元法其实就是对系数矩阵作初等行变换，这不改变方程的解，将系数矩阵化成上三角矩阵的形式，然后从下往上依次解出方程组的每个分量解（回代）。如果是针对列主元的高斯消元法，需要加入方程组的右侧值，与系数矩阵组成增广矩阵，进而求解。3). QR分解的原理任意的$A \in {\bf C}^{n \times n}$都可以进行$QR$分解，即$A=QR$，$Q$为n阶酉矩阵($QQ^{H}=I$)，$R$为n阶上三角矩阵。$QR$分解与Gram-Schmidt正交化有关，即将$A$进行Gram-Schmidt正交化，化为$Q$，然后求出R。Q的列向量是A的列空间的标准正交基，R是一个非奇异可逆的上三角矩阵，即将矩阵每个列作为一个基本单元，将其化为正交的基向量与在这个基向量上的投影长度的积。4).Cholesky分解的原理Cholesky分解其实是矩阵Doolittle分解(三角分解的特例)的特例。三角分解是是将方针分解成同阶的下三角阵和上三角阵，其中上三角阵的主对角线元素全为1则为Doolittle分解。如果矩阵$A$既是方阵又是Hermite正定阵时($A=A^{H}$,且特征值全为正数)，则存在唯一分解$A=LL^{H}$，其中$L$是具有主对角元素为正数的下三角矩阵。5).利用$QR$和Cholesky分解法分解随机矩阵$A \in {\bf C}^{100 \times 100}$求解$x$。主要思路就是先用定义动态大小的矩阵，之后进行调用相关的函数处理。其中需要注意的是，Cholesky分解需要矩阵为正定阵，因此在矩阵定义上需要进行一些处理。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;#include &lt;ctime&gt;// Eigen部分#include &lt;Eigen/Core&gt;//Eigen稠密矩阵的代数运算（逆和特征值等）#include &lt;Eigen/Dense&gt;int main (int argc, char** argv)&#123;Eigen::Matrix &lt;double,Eigen::Dynamic, Eigen::Dynamic&gt; matrix_dynamic; //Eigen固定大小矩阵最大支持到50Eigen::Matrix&lt;double,Eigen::Dynamic, Eigen::Dynamic&gt; matrix_A;Eigen::Matrix&lt;double,Eigen::Dynamic, 1&gt; x;Eigen::Matrix&lt;double,Eigen::Dynamic,1&gt; v_right;matrix_dynamic = Eigen::MatrixXd::Random(100,100); //随机化取值matrix_A = matrix_dynamic.transpose()*matrix_dynamic; //cholesky分解需要A为正定矩阵v_right = Eigen::MatrixXd::Random(100, 1); //方程右边的值随机取值//QR Decompositionclock_t time_stt = clock();x = matrix_A.colPivHouseholderQr().solve(v_right);cout&lt;&lt;&quot;the time used in QR decomposition is &quot;&lt;&lt; 1000* (clock() - time_stt)/(double) CLOCKS_PER_SEC&lt;&lt;&quot;ms&quot;&lt;&lt; endl;cout&lt;&lt;x&lt;&lt;endl;//Cholesky Decompositiontime_stt = clock();x = matrix_A.llt().solve(v_right);cout&lt;&lt;&quot;the time used in Cholesky decomposition is &quot;&lt;&lt; 1000* (clock() - time_stt)/(double) CLOCKS_PER_SEC&lt;&lt;&quot;ms&quot;&lt;&lt; endl;cout&lt;&lt;x&lt;&lt;endl;return 0;&#125;CMakeLists.txt文件内容如下：1234567891011cmake_minimum_required(VERSION 2.8)project(QR_cholesky)set(CMAKE_BUILD_TYPE &quot;Release&quot;)set(CMAKE_CXX_FLAGS &quot;-O3&quot;) #Debug版会使用参数-g；Release版使用-O3 –DNDEBUGinclude_directories(&quot;/usr/include/eigen3&quot;)add_executable(QR_cholesky QR_cholesky.cpp)#eigen3都是头文件，不需要target_link_libraries几何运算练习基本思想就是$T_{cw} p=p^{‘}$，或者$R p + t=p^{‘}$，注意这里是世界坐标系的点变换到相机坐标系。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;//Eigen几何模块#include &lt;Eigen/Core&gt;#include&lt;Eigen/Geometry&gt;int main(int argc, char** argv)&#123;Eigen::Quaterniond q1(0.55,0.3,0.2,0.2);q1 = q1.normalized();Eigen::Quaterniond q2(-0.1,0.3,-0.7,0.2);q2 = q2.normalized();Eigen::Matrix &lt;double, 3,1&gt; t1;t1 &lt;&lt; 0.7,1.1,0.2;Eigen::Matrix &lt;double, 3,1&gt; t2;t2 &lt;&lt; -0.1,0.4,0.8;Eigen::Matrix &lt;double, 3,1&gt; p1;p1 &lt;&lt; 0.5,-0.1,0.2;Eigen::Matrix &lt;double, 3,1&gt; p2;Eigen::Matrix &lt;double, 3,1&gt; p; //世界坐标系的点//利用变换矩阵的方法// Eigen::Isometry3d Tcw1 = Eigen::Isometry3d::Identity();//变换矩阵1// Tcw1.rotate(q1);// Tcw1.pretranslate(t1);// Eigen::Isometry3d Tcw2 = Eigen::Isometry3d::Identity();//变换矩阵2// Tcw2.rotate(q2);// Tcw2.pretranslate(t2);// p = Tcw1.inverse()*p1;// p2 = Tcw2*p;//直接利用旋转矩阵和平移向量进行组合运算Eigen::Matrix&lt;double,3,3&gt; R1_inverse;R1_inverse = q1.matrix().inverse();Eigen::Matrix&lt;double,3,3&gt; R2;R2 = q2.matrix();p2 = R2 * R1_inverse *(p1 - t1) + t2;cout &lt;&lt; &quot;p2 = &quot; &lt;&lt; p2.transpose() &lt;&lt; endl;return 0;&#125;CMakeLists.txt文件内容如下：123456789cmake_minimum_required(VERSION 2.8)set (CMAKE_BUILD_TYPE &quot;Release&quot;)set (CMAKE_CXX_FLAGS &quot;-O3&quot;)project(Geometryusing)include_directories(&quot;/usr/include/eigen3&quot;)add_executable(Geometryusing Geometryusing.cpp)#eigen3都是头文件，不需要target_link_libraries旋转的表达1).旋转矩阵的正交性坐标系中的某个单位正交基$(e_{1},e_{2},e_{3})$经过旋转变换后变为$(e^{‘}_{1},e^{‘}_{2},e^{‘}_{3})$，对于同一个向量在两个坐标系下的坐标分别为$a(a_{1},a_{2},a_{3})$和$(a^{‘}_{1},a^{‘}_{2},a^{‘}_{3})$，由于向量不会随着坐标系的旋转而发生变化，则有：\begin{bmatrix} e_{1} & e_{2} & e_{3} \end {bmatrix} \begin{bmatrix} a_{1} \\ a_{2} \\ a_{3} \end {bmatrix} = \begin{bmatrix} e^{'}_{1} & e^{'}_{2} & e^{'}_{3} \end {bmatrix} \begin{bmatrix} a^{'}_{1} \\ a^{'}_{2} \\ a^{'}_{3} \end {bmatrix}等式两边同时左乘$[e^{T}_{1} \quad e^{T}_{2} \quad e^{T}_{3}]$，则得出旋转矩阵$R$为R= \begin{bmatrix} e^{T}_{1}\\ e^{T}_{2} \\ e^{T}_{3} \end{bmatrix} \begin{bmatrix} e^{'}_{1} & e^{'}_{2} & e^{'}_{3} \end{bmatrix}则有：R^{T}R= \begin{bmatrix} e^{'}_{1}\\ e^{'}_{2}\\ e^{'}_{3} \end{bmatrix} \begin{bmatrix} e^{T}_{1} & e^{T}_{2} & e^{T}_{2} \end{bmatrix} \begin{bmatrix} e^{T}_{1}\\ e^{T}_{2} \\ e^{T}_{3} \end{bmatrix} \begin{bmatrix} e^{'}_{1} & e^{'}_{2} & e^{'}_{3} \end{bmatrix} =I\det R= \det( \begin{bmatrix} e^{T}_{1}\\ e^{T}_{2} \\ e^{T}_{3} \end{bmatrix} \begin{bmatrix} e^{'}_{1} & e^{'}_{2} & e^{'}_{3} \end{bmatrix} ) = det(\begin{bmatrix} e^{T}_{1}\\ e^{T}_{2} \\ e^{T}_{3} \end{bmatrix}) det(\begin{bmatrix} e^{'}_{1} & e^{'}_{2} & e^{'}_{3} \end{bmatrix}) =12).四元数的维度易知$\varepsilon$是三维，$\eta$是一维的。3).四元数相关证明(题目应该有错）符号$x$和$\wedge$代表着反对称矩阵，代表着向量到反对称矩阵的变换，这是从叉乘引申而来的。即a^{\times}= (\begin{bmatrix} a_{1}\\ a_{2}\\ a_{3} \end{bmatrix})^{\times} = \begin{bmatrix} 0 & -a_{3} & a_{2}\\ a_{3} & 0 &-a_{1}\\ -a_{2} & a_{1} & 0 \end{bmatrix}设$q_{1}=[x_{1},y_{1},z_{1},w_{1}]^{T}$,$q_{2}=[x_{2},y_{2},z_{2},w_{2}]^{T}$,\begin{align*} q_{1}q_{2} & = w_{1}w_{2}-x_{1}x_{2}-y_{1}y_{2}-z_{1}z_{2}\\ & + (w_{1}x_{2}+x_{1}w_{2}+y_{1}z_{2}-z_{1}y_{2})i\\ & + (w_{1}y_{2}-x_{1}z_{2}+y_{1}w_{2}+z_{1}x_{2})j\\ & + (w_{1}z_{2}+x_{1}y_{2}-y_{1}x_{2}+z_{1}w_{2})k \end{align*}q_{1}^{\bigoplus}q_{2}= \begin{bmatrix} w_{1} & -z_{1} & y_{1} & x_{1}\\ z_{1} & w_{1} & -x_{1} & y_{1}\\ -y_{1} & x_{1} & w_{1} & z_{1}\\ -x_{1} & -y_{1} & -z_{1} & w_{1} \end{bmatrix} \begin{bmatrix} x_{2}\\ y_{2}\\ z_{2}\\ w_{2} \end{bmatrix} = \begin{bmatrix} w_{1}x_{2}-z_{1}y_{2}+y_{1}z_{2}+x_{1}w_{2}\\ z_{1}x_{2}+w_{1}y_{2}-x_{1}z_{2}+y_{1}w_{2}\\ -x_{2}y_{1}+x_{1}y_{2}+w_{1}z_{2}+z_{1}w_{2}\\ w_{1}w_{2}-x_{1}x_{2}-y_{1}y_{2}-z_{1}z_{2} \end{bmatrix} \begin{align*} & = w_{1}w_{2}-x_{1}x_{2}-y_{1}y_{2}-z_{1}z_{2}\\ & + (w_{1}x_{2}+x_{1}w_{2}+y_{1}z_{2}-z_{1}y_{2})i\\ & + (w_{1}y_{2}-x_{1}z_{2}+y_{1}w_{2}+z_{1}x_{2})j\\ & + (w_{1}z_{2}+x_{1}y_{2}-y_{1}x_{2}+z_{1}w_{2})k \end{align*} =q_{1}q_{2}q_{2}^{+}q_{1}= \begin{bmatrix} w_{2} & z_{2} & -y_{2} & x_{2}\\ -z_{2} & w_{2} & x_{2} & y_{2}\\ y_{2} & -x_{2} & w_{2} & z_{2}\\ -x_{2} & -y_{2} & -z_{2} & w_{2} \end{bmatrix} \begin{bmatrix} x_{1}\\ y_{1}\\ z_{1}\\ w_{1} \end{bmatrix} = \begin{bmatrix} w_{2}x_{1}+y_{1}z_{2}-y_{2}z_{1}+w_{1}x_{2}\\ -x_{1}z_{2}+w_{2}y_{1}+x_{2}z_{1}+y_{2}w_{1}\\ x_{1}y_{2}-x_{2}y_{1}+w_{2}z_{1}+w_{1}z_{2}\\ w_{1}w_{2}-x_{1}x_{2}-y_{1}y_{2}-z_{1}z_{2} \end{bmatrix} \begin{align*} & = w_{1}w_{2}-x_{1}x_{2}-y_{1}y_{2}-z_{1}z_{2}\\ & + (w_{1}x_{2}+x_{1}w_{2}+y_{1}z_{2}-z_{1}y_{2})i\\ & + (w_{1}y_{2}-x_{1}z_{2}+y_{1}w_{2}+z_{1}x_{2})j\\ & + (w_{1}z_{2}+x_{1}y_{2}-y_{1}x_{2}+z_{1}w_{2})k \end{align*} =q_{1}q_{2}罗德里格斯公式证明如上图所示，向量${\bf v}$绕单位旋转轴${\bf k}$旋转$\theta$角后，变换成了${\bf v}_{rot}$，分别将向量${\bf v}$和${\bf v}_{rot}$沿${\bf k}$平行和垂直的方向分解。\begin{align*} &{\bf v}={\bf v}_{||}+{\bf v}_{\bot}\\ &{\bf v}_{||}=({\bf v} \cdot {\bf k}){\bf k}\\ & {\bf v}_{\bot}={\bf v}-{\bf v}_{||}=-{\bf k}\times({\bf k} \times {\bf v}) \end{align*}根据图像，我们知道，平行于旋转轴的分量没有变化，只有垂直于旋转轴的分量进行了旋转，而且它们的模长是一样的，这就说明${\bf v}_{\bot}$和${\bf v}_{rot \bot}$是在一个圆上，长度相等，而且，${\bf v}_{\bot}$和${\bf k} \times {\bf v}_{\bot}$构成了该圆的两个正交坐标轴，因此${\bf v}_{rot \bot}$的坐标可以用这个坐标轴表示，或者说该向量可以被这两个正交坐标基线性表示，即：\begin{align*} {\bf v}_{rot \bot}&=\cos \theta{\bf v}_{\bot}+\sin \theta({\bf k}\times {\bf v}_{\bot})\\ &=\cos \theta{\bf v}_{\bot}+\sin \theta({\bf k} \times {\bf v}-{\bf k} \times {\bf v}_{||})\\ &=\cos \theta{\bf v}_{\bot}+\sin \theta({\bf k}\times {\bf v}) \end{align*}\begin{align*} {\bf v}_{rot} & = {\bf v}_{rot ||}+{\bf v}_{rot \bot}\\ & = {\bf v}_{||}+\cos \theta {\bf v}_{\bot}+\sin \theta ({\bf k}\times{\bf v})\\ & = {\bf v}_{||}+\cos \theta({\bf v}-{\bf v}_{||}) +\sin \theta ({\bf k}\times{\bf v})\\ & = \cos \theta {\bf v}+(1-\cos \theta){\bf v}_{||}+\sin \theta ({\bf k}\times{\bf v})\\ & = \cos \theta {\bf v}+(1-\cos \theta)({\bf k}\cdot {\bf v}){\bf k}+\sin \theta ({\bf k}\times{\bf v}) \end{align*}下面将这些向量都看成矩阵的形式，将其运算化为矩阵的运算形式，假设${\bf k}$和${\bf v}$都是列向量的形式，则${\bf k}({\bf k}\cdot {\bf v})=kk^{T}v$，${\bf k}\times {\bf v}=k^{\wedge}v$，因此，得到了旋转矩阵的形式为：R=\cos \theta I+(1-\cos \theta)kk^{T}+\sin \theta k^{\wedge}将$k$换成$n$即得罗德里格斯公式。四元数运算性质的验证设单位四元数$q=[\varepsilon \quad \eta]$(虚部 实部），点$p=[\zeta \quad 0]$，$q=x_{1}i+y_{1}j+z_{1}k+w_{1}, w_{1}^{2}+x_{1}^{2}+y_{1}^{2}+z_{1}^{2}=1$则：\begin{align*} p^{'}=qpq^{-1} & = q^{\bigoplus}pq^{-1}\\ & = q^{\bigoplus}q^{-1+}p\\ & = \begin{bmatrix} \eta I+\varepsilon ^{\times} & \varepsilon \\ -\varepsilon^{T} & \eta \end{bmatrix} \begin{bmatrix} \eta I-(-\varepsilon )^{\times} & -\varepsilon \\ -(-\varepsilon)^{T} & \eta \end{bmatrix} \begin{bmatrix} \zeta\\ 0 \end{bmatrix} \\ & = \begin{bmatrix} w_{1} & -z_{1} & y_{1} & x_{1} \\ z_{1} & w_{1} & -x_{1} & y_{1} \\ -y_{1} & x_{1} & w_{1} & z_{1}\\ -x_{1} & -y_{1} & -z_{1} & w_{1} \end{bmatrix} \begin{bmatrix} w_{1} & -z_{1} & y_{1} & -x_{1} \\ z_{1} & w_{1} & -x_{1} & -y_{1} \\ -y_{1} & x_{1} & w_{1} & -z_{1}\\ x_{1} & y_{1} & z_{1} & w_{1} \end{bmatrix} \begin{bmatrix} \zeta \\ 0 \end{bmatrix} \\ & = \begin{bmatrix} R_{3 \times 3} & 0_{3 \times 1}\\ 0_{1 \times 3} & 1 \end{bmatrix} \begin{bmatrix} \zeta \\ 0 \end{bmatrix} \end{align*}易知$p^{‘}$的实部为0，也就是上述形式限制了点的变换维度，虽然四元数是四个变量，但是不会把三维点变到四维去。计算得出旋转矩阵$R$为:R= \begin{bmatrix} w_{1}^{2}+x_{1}^{2}-y_{1}^{2}-z_{1}^{2} & 2x_{1}y_{1}-2w_{1}z_{1} & 2x_{1}z_{1}+2y_{1}w_{1}\\ 2x_{1}y_{1}+2z_{1}w_{1} & w_{1}^{2}+y_{1}^{2}-x_{1}^{2}-z_{1}^{2} & 2y_{1}z_{1}-2x_{1}w_{1}\\ 2x_{1}z_{1}-2y_{1}w_{1} & 2y_{1}z_{1}+2x_{1}w_{1} & w_{1}^{2}+z_{1}^{2}-x_{1}^{2}y_{1}^{2} \end{bmatrix}C++11for(atuo&amp; a: avec)范围for循环，用a遍历avec中的每个量；基于范围的FOR循环的遍历是只读的遍历，除非将变量变量的类型声明为引用类型。for(atuo&amp; a: avec)自动类型推导，根据a获得的值，用auto自动推断出a的类型；{return a1.index&lt;a2.index;})运用了lambda表达式。begin()begin 返回首元素的地址，end 返回尾元素的下一个地址。]]></content>
      <categories>
        <category>科研记录</category>
      </categories>
      <tags>
        <tag>visual SLAM</tag>
        <tag>Linux</tag>
        <tag>C++11</tag>
        <tag>Computer vision</tag>
        <tag>Eigen</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[visual SLAM by Gaoxiang(1)]]></title>
    <url>%2Fposts%2FvisualSLAMbyGaoxiang-1%2F</url>
    <content type="text"><![CDATA[​视觉SLAM概述simultaneous localization and mapping仅使用相机进行室内/室外定位（有些情况下GPS会崩，IMU漂移随着时间误差增大）机器人在未知环境进行导航—-建图(sparse/semi-dense/dense)SLAM问题的本质是对运动主体自身和周围环境空间不确定性的估计（spatial uncertainty）为了解决SLAM问题，我们需要状态估计理论，把定位和建图的不确定性表达出来，然后采用滤波器或非线性优化，估计状态的均值和不确定性（方差）学术上研究视觉SLAM较多，尤其是monocular，但是应用上少了点，尤其是建图的作用目前很浅，而且很多人大部分现在在用深度学习搞3D重建。目前应用的地方有：手持设备定位自动驾驶定位—比GPS的定位信息要丰富，甚至精度更好(可以达到厘米级)AR 增强现实（定位，建图，深度学习结合）清洁机器人学习研究步骤第一部分是学习相关的数学知识，构建数学模型矩阵概率论李群李代数微分几何凸优化…第二部分是计算机视觉的代码实践openCVc++pythonLinux…教材：Multiple view Geometry in computer visionState estimation for robotics视觉SLAM十四讲-从理论到实践(作业代码)本教程内容提纲概述与预备知识三维空间的刚体运动李群李代数相机模型与非线性优化特征点法视觉里程计直接法视觉里程计后端优化回环检测视觉SLAM的基本框架和模型定位与建图是相互关联的，准确的定位需要精确的地图，精确的地图也来自准确的定位。为什么选择视觉传感器: 携带安装更加自由，成本更低，信息丰富，功能不单一，可开发性强，智能化程度高具有挑战性（单目monocular/双目stereo/深度相机RGB-D/鱼眼、全景、event-based相机等），而挑战是普通的相机会丢失世界的距离信息，因此需要从图像中进行恢复（相机运动，相机几何关系，物理测量等）。视觉SLAM框架前端：visual odometry(估计邻帧相机相机运动/feature-based/direct-based)后端：optimization(消除噪声，优化轨迹/最大后验概率估计/滤波器/图优化)回环：loop closing(相机回到之前相同的位置，优化约束，消除累计误差/图像相似性/词袋模型)建图：mapping(导航/路劲规划/人机交互/可视化/通讯/度量地图（稀疏地图/稠密地图）/拓扑地图)视觉SLAM的数学模型：\begin{align*} & 运动方程 x_{k} = f(x_{k-1}, u_{k},w_{k}) \\ & 观测方程 z_{k,j} = h(y_{j}, x_{k}, v_{k,j}) \end{align*}———-0——-1———2——-3——-4——-5——-6————-&gt; t———$x_{0}$—-$x_{1}$——$x_{2}$——$x_{3}$——$x_{4}$———- &gt;​ $\searrow $ $\searrow $ $\searrow $ $\searrow $​ $\bullet y_{1}$ $\bullet y_{2}$​ $\bullet y_{j}$​ $\cdots$假设一个机器人在实际场景中运动，$x_{k}$是此时刻k的位置，$x_{k-1}$是上一个时刻k-1的，在这之间有个输入，使得机器人运动，我们设其为$u_{k}$，而同时运动也包含着噪声，机器人的运动也不完全受精确控制，假设噪声为$w_{k}$。 现在，机器人携带了相机，相机会拍到一系列现实场景的标志，我们称其为路标点（landmark），假设此场景各个路标点为$y_{1}, y_{2}, \cdots, y_{j}, \cdots$。容易知道，机器人在每个时刻所在的位置都会观测到这些路标点中的一部分或者全部，假设在$x_{0}$位置看到路标点$y_{1}$，我们记为$z_{0,1}$，看到了路标点$y_{2}$，记为$z_{0,2}$，…以此类推，这会反映在图像像素上，因此称为观测方程，同样观测也会有噪声$v_{k,j}$。我们通过一系列运动方程和观测方程，利用已知的$u_{k}, z_{k,j}$来推断出$x_{k}, y_{j}$，也就是知道了机器人的位置，同时了解了环境的信息，因此也就是两大任务：定位和建图。本次作业与实践首先大致了解下Linux下编写C++源码以及利用cmake编译可执行文件的步骤工具g++, cmake, VS code(optional IDE)一个利用c++编写的简单工程包含着头文件文件夹incliude，源码文件夹src，cmake编译文件夹build，以及main.cpp和CMakeLists.txt等主要文件，其中CMakeLists.txt文件的语言格式要注意12345678910111213141516cmake_minimum_required(VERSION 2.8)project(HelloSLAM)#指定程序编译的模式set(CMAKE_BUILD_TYPE Debug)#claim the include files&apos; directoriesinclude_directories(&quot;include&quot;)# only src filesadd_library(libHello src/hello.cpp)add_executable(sayHello main.cpp)target_link_libraries(sayHello libHello)利用vs code配合cmake进行配置以进行代码的编写和调试，也可以选择KDEVELOP和其他的IDE。熟悉LIinux1.如何在 Ubuntu 中安装软件（命令⾏界⾯）？它们通常被安装在什么地⽅？apt-get 方式的安装；普通安装：sudo apt-get install XXX修复安装：sudo apt-get -f install XXX重新安装：sudo apt-get -f reinstall XXXdpkg方式的安装sudo dpkg -i package_name.deb安装的地方通常被安装在/usr/bin，/usr/local这个目录下系统安装软件一般在/usr/share，可执行的文件在/usr/bin，配置文件可能安装到了/etc下等。文档一般在 /usr/share，可执行文件 /usr/bin，配置文件 /etc，lib文件 /usr/lib。2.linux 的环境变量是什么？我如何定义新的环境变量？Environment variables defined in this chapter affect the operation of multiple utilities, functions, and applications.linux是一个多用户的操作系统。每个用户登录系统后，都会有一个专用的运行环境。通常每个用户默认的环境都是相同的，这个默认环境实际上就是一组环境变量的定义。用户可以对自己的运行环境进行定制，其方法就是修改相应的系统环境变量。环境变量是一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息常见的环境变量：PATH：决定了shell将到哪些目录中寻找命令或程序HOME：当前用户主目录MAIL：是指当前用户的邮件存放目录。SHELL：是指当前用户用的是哪种Shell。HISTSIZE：是指保存历史命令记录的条数LOGNAME：是指当前用户的登录名。HOSTNAME：是指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的。LANG/LANGUGE：是和语言相关的环境变量，使用多种语言的用户可以修改此环境变量。使用修改.bashrc文件进行环境变量的编辑，只对当前用户有用。使用修改/etc/profile文件进行环境变量的编辑，是对所有用户有用。关于环境变量命令介绍：echo显示某个环境变量值echo$PATHexport设置一个新的环境变量exportHELLO=”hello”(可以无引号)env显示所有环境变量set显示本地定义的shell变量unset清除环境变量unsetHELLOreadonly设置只读环境变量readonlyHELLO对所有用户生效的永久性变量（系统级）:这类变量对系统内的所有用户都生效，所有用户都可以使用这类变量。作用范围是整个系统。设置方式： 用vim在/etc/profile文件中添加我们想要的环境变量,用export指令添加环境变量当然，这个文件只有在root（超级用户）下才能修改。我们可以在etc目录下使用ls -l查看这个文件的用户及权限【注意】：添加完成后新的环境变量不会立即生效，除非你调用source /etc/profile 该文件才会生效。否则只能在下次重进此用户时才能生效。对单一用户生效的永久性变量（用户级）:只针对当前用户，和上面的一样，只不过不需要在etc下面进行添加，直接在.bash_profile文件最下面用export添加就好了。这里 .bashrc和.bash_profile原则上来说设置此类环境变量时在这两个文件任意一个里面添加都是可以的。~/.bash_profile是交互式login方式进入bash shell运行。~/ .bashrc是交互式non-login方式进入bash shell运行。二者设置大致相同。就是.bash_profile文件只会在用户登录的时候读取一次而.bashrc在每次打开终端进行一次新的会话时都会读取。临时有效的环境变量（只对当前shell有效）:此类环境变量只对当前的shell有效。当我们退出登录或者关闭终端再重新打开时，这个环境变量就会消失。是临时的。 直接使用export指令添加。3.linux 根⽬录下⾯的⽬录结构是什么样的？⾄少说出 3 个⽬录的⽤途。可通过终端查看/目录下的文件：12cd /ls/bin用户二进制文件包含二进制可执行文件，系统所有用户可执行文件都在这个文件夹里，例如：ls，cp，ping等。/sbin 系统二进制文件包含二进制可执行文件，但只能由系统管理员运行，对系统进行维护。/etc配置文件包含所有程序配置文件，也包含了用于启动/停止单个程序的启动和关闭shell脚本。/dev设备文件包含终端所有设备，USB或连接到系统的任何设备。例如：/dev/tty1、dev/usbmon0/proc进程信息包含系统进程的相关信息。这是一个虚拟的文件系统，包含有关正在运行的进程的信息。例如：/proc/{pid}目录中包含的与特定pid相关的信息。这是一个虚拟的文件系统，系统资源以文本信息形式存在。例如：/proc/uptime/var变量文件可以找到内容可能增长的文件。这包括 - 系统日志文件/var/log;包和数据库文件/var/lib;电子邮件/var/mail;打印队列/var/spool;锁文件/var/lock;多次重新启动需要的临时文件/var/tmp;/tmp临时文件包含系统和用户创建的临时文件。当系统重新启动时，这个目录下的文件都将被删除。/usr用户程序包含二进制文件、库文件、文档和二级程序的源代码。/usr/bin中包含用户程序的二进制文件。如果你在/bin中找不到用户二进制文件，到/usr/bin目录看看。例如：at、awk、cc、less、scp。/usr/sbin中包含系统管理员的二进制文件。如果你在/sbin中找不到系统二进制文件，到/usr/sbin目录看看。例如：atd、cron、sshd、useradd、userdel。/usr/lib中包含了/usr/bin和/usr/sbin用到的库。/usr/local中包含了从源安装的用户程序。例如，当你从源安装Apache，它会在/usr/local/apache2中。/home HOME目录所有用户用来存档他们的个人档案。/boot引导加载程序文件包含引导加载程序相关的文件。内核的initrd、vmlinux、grub文件位于/boot下。/lib系统库包含支持位于/bin和/sbin下的二进制文件的库文件.库文件名为 ld或lib.so.*/opt可选的附加应用程序opt代表opitional；包含从个别厂商的附加应用程序。附加应用程序应该安装在/opt/或者/opt/的子目录下。/mnt挂载目录临时安装目录，系统管理员可以挂载文件系统。/media 可移动媒体设备用于挂载可移动设备的临时目录。举例来说，挂载CD-ROM的/media/cdrom，挂载软盘驱动器的/media/floppy;/srv服务数据srv代表服务。包含服务器特定服务相关的数据。例如，/srv/cvs包含cvs相关的数据。4.假设我要给 a.sh 加上可执⾏权限，该输⼊什么命令？chmod 777 文件名 将文件设置成对拥有者、组成员、其他人可读、可写、可执行。chmod a+x 文件名将文件在原来的配置上增加可执行权限。5.假设我要将 a.sh ⽂件的所有者改成 xiang:xiang，该输⼊什么命令？chown xiang:xiang 文件名将文件的所有者改成xiang:xiangSLAM文献阅读1.SLAM 会在哪些场合中⽤到？⾄少列举三个⽅向。机器人定位导航、手持设备定位、增强现实、自动泊车、语义地图重建等2.SLAM中定位与建图是什么关系？为什么在定位的同时需要建图？定位需要精确的地图，详细的地图需要精确地定位，两者相辅相成，相互依存。重定位和局部建图是slam框架中很重要的两个线程。定位：机器人必须知道自己在环境中位置；建图：机器人必须记录环境中特征的位置（如果知道自己的位置）；机器人在未知环境中从一个未知位置开始移动,在移动过程中根据位置估计和地图进行自身定位,同时在自身定位的基础上建造增量式地图，实现机器人的自主定位和导航。3.SLAM发展历史如何？我们可以将它划分成哪⼏个阶段？1985-1990：, Chatila 和Laumond (1985) and Smith et al. (1990)提出以建图和定位同时进行；单传感器为外部传感器：早期：声呐(Tardós et al. 2002; Ribas et al. 2008)；后期：激光雷达(Nüchter etal. 2007; Thrun et al. 2006)；相机(Se et al. 2005; Lemaire et al. 2007; Davison 2003;Bogdan et al. 2009)；GPS(Thrun et al. 2005a)；多传感器融合三个发展阶段：初始阶段：二十世纪八十年代发展阶段：二十世纪九十年代快速发展阶段4.列举三篇在SLAM领域的经典⽂献。Smith, R.C. and P. Cheeseman, On the Representation and Estimation of Spatial Uncertainty. International Journal of Robotics Research, 1986. 5Se, S., D. Lowe and J. Little, Mobile robot localization and mapping with uncertainty using scale­invariant visual landmarks. The international Journal of robotics Research, 2002. 21Mullane, J., et al., A Random­Finite­Set Approach to Bayesian SLAM. IEEE Transactions on Robotics, 2011CMake练习1.程序代码由头文件和源文件组成；2.带有main函数的源文件编译成可执行程序，其他的编译成库文件；3.如果可执行程序想调用库文件中的函数，它需要参考该库提供的头文件，以明白调用的格式。同时要把可执行程序链接到库文件上；在自己的工程目录里面建立子目录build文件夹和src文件夹和libhello文件夹，hello.cpp,hello.h放入libhello中,useHello.cpp放入src中。同时在工程目录下创建一个顶层的CMakeLists.txt文件，内容如下：123456789101112project(sayHello)cmake_minimum_required(VERSION 2.8)#ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])#这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置add_subdirectory(src) #在 build 目录中将出现一个 src 目录，生成的目标代码 hello 将存放在 src 目录中add_subdirectory(libhello)set(CMAKE_BUILD_TYPE &quot;Release&quot;)在src文件夹下新建CMakeLists.txt文件，输入如下内容：12345678910111213141516cmake_minimum_required(VERSION 2.8)#头文件目录include_directories($&#123;PROJECT_SOURCE_DIR&#125;/libhello)set(APP_SRC useHello.cpp)#指定最终的目标二进制的位置#SET(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin)#SET(LIBRARY_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/lib)set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin)add_executable(sayHello $&#123;APP_SRC&#125;)#为 target 添加需要链接的库target_link_libraries(sayHello libhello)最后在libhello文件夹下新建CMakeLists.txt文件，输入如下内容：1234567891011121314151617cmake_minimum_required(VERSION 2.8)set(LIB_SRC hello.cpp)#向 C/C++编译器添加-D 定义add_definitions(&quot;-DLIBHELLO_BUILD&quot;)#添加动态库add_library(libhello SHARED $&#123;LIB_SRC&#125;)#设置动态库输出位置set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/lib)#SET_TARGET_PROPERTIES(target1 target2 ...#PROPERTIES prop1 value1 #prop2 value2 ...)#该指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本set_target_properties(libhello PROPERTIES OUTPUT_NAME &quot;sayhello&quot;)接着在build文件夹下cmake .., make即可，在biuld文件中的子问夹下的bin文件生成可执行文件sayHello;在lib中生成库文件libhello.so共享库文件。对于安装路径，可以使用CMAKE_INSTALL_PREFIX命令。理解ORBSLAM2框架1.git clone https://github.com/raulmur/ORB_SLAM22.(a) 6个可执行文件一个库文件 set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/lib)(b)include文件夹包含：对应src中程序的代码函数头文件；src文件夹包含：相应程序的代码函数的c++文件；Examples文件夹包含RGB-D文件夹，Stereo文件夹， Monocular文件夹，具体的内容在总目录下的CMakeLists.txt文件中有写：1234567891011121314151617181920212223242526272829303132# Build examplesset(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/Examples/RGB-D)add_executable(rgbd_tumExamples/RGB-D/rgbd_tum.cc)target_link_libraries(rgbd_tum $&#123;PROJECT_NAME&#125;)set(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/Examples/Stereo)add_executable(stereo_kittiExamples/Stereo/stereo_kitti.cc)target_link_libraries(stereo_kitti $&#123;PROJECT_NAME&#125;)add_executable(stereo_eurocExamples/Stereo/stereo_euroc.cc)target_link_libraries(stereo_euroc $&#123;PROJECT_NAME&#125;)set(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/Examples/Monocular)add_executable(mono_tumExamples/Monocular/mono_tum.cc)target_link_libraries(mono_tum $&#123;PROJECT_NAME&#125;)add_executable(mono_kittiExamples/Monocular/mono_kitti.cc)target_link_libraries(mono_kitti $&#123;PROJECT_NAME&#125;)add_executable(mono_eurocExamples/Monocular/mono_euroc.cc)target_link_libraries(mono_euroc $&#123;PROJECT_NAME&#125;)(c) OPENCV_LIBS、EIGEN3_LIBS、Pangolin_LIBRARIES、/ORB-SLAM2/Thirdparty/DBoW2/lib/libDBoW2.so、/ORB-SLAM2/Thirdparty/g2o/lib/libg2o.so运行ORB-SLAM21.编译安装依赖项，可以按照ORB-SLAM2源码的指导进行配置。其他依赖项按照高翔书中所说的安装1sudo apt-get install libopencv-dev libeigen3-dev libqt4-dev qt4-qmake libqglviewer-dev libsuitesparse-dev libcxsparse3.1.2 libcholmod[tab安装]其中需要注意Pangolin需要下载手动编译安装，步骤比较简单，不再赘述12345678910111213sudo apt-get install libglew-dev---sudo apt-get install libboost-dev libboost-thread-dev libboost-filesystem-dev---git clone https://github.com/stevenlovegrove/Pangolin Pangolin--cd Pangolinmkdir buildcd buildcmake ..make sudo make install---另外一个注意的点就是opencv库，我是手动下载编译安装的，网上的教程很多，主要是编译时注意cmake的设置，但是我在安装的时候无法被python链接，也就是没有生成cv2.so，导致没办法在Python2和python3中import cv2，估计可能是我之前先装了anaconda的原因，导致了opencv编译忽略了Python路径问题。。。尝试了几次，未果，等以后用到了python再解决这个问题（可以直接用sudo pip3 install opencv-python，如果不想麻烦的话，不过以后可能会出现一些问题）2.如何将 myslam.cpp或 myvideo.cpp 加⼊到 ORB-SLAM2 ⼯程中？请给出你的 CMakeLists.txt 修改⽅案。12345678#add myvideo.cpp and myslam.cppset(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;)add_executable(myvideo myvideo.cpp)target_link_libraries(myvideo $&#123;PROJECT_NAME&#125;)add_executable(myslam myslam.cpp)target_link_libraries(myslam $&#123;PROJECT_NAME&#125;)将myvideo.cpp、myslam.cpp、myvideo.yaml、myslam.yaml以及myvideo.mp4都放到ORB-SLAM2目录下，再次编译ORB-SLAM2后，就会生成可执行文件，然后终端输入./myvideo和./myslam就可以直接运行了。这里有个问题，一开始我是根据CMakeLits.txt中上面的语句来写的，也就是我把myvideo.cpp、myslam.cpp放在了、Examples/Monocular文件夹中，然后进行编译，结果虽然生成了可执行文件，但是程序无法运行，终端要么提示无法读取对应的.yaml的设置，要么出现segmentation fault错误，最后放到ORB-SLAM2总目录下就没问题了。。。目前不知道什么原因，等后面再看看。因为ORB-SLAM2开源的版本没有稠密建图功能，因此如果想尝试稠密建图功能，可以参考高翔博士的ORB-SLAM2_modofied，利用PCL工具实时拼接RGB-D图像，效果还可以，不过没有原作者视频中最后的那个效果好，安装步骤在这里。]]></content>
      <categories>
        <category>科研记录</category>
      </categories>
      <tags>
        <tag>visual SLAM</tag>
        <tag>Linux</tag>
        <tag>C++11</tag>
        <tag>Computer vision</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Beyond Supervised Learning-A Computer Vision Perspective]]></title>
    <url>%2Fposts%2Fbeyondsupervisedlearning%2F</url>
    <content type="text"><![CDATA[​About这篇论文（链接）是印度的几位教授写的，以计算机视觉的角度来阐述目前在全监督学习和无监督学习之间的几种训练方式，写得比较简略，但是适合我这种刚入门连名词都不是很清楚的人，可以让我用来梳理整个领域的技术发展脉络和现状。同时该论文也给出了大量的参考文献，也方便进行下一步的研究。实际上，严格地说，这篇文章不能算一篇合格的综述，只能说是那种“扫盲”的阅读材料。出现上述技术发展的主要原因是数据集比较庞大，但是完全被标注好的数据却很少，而训练好的网络在面对现实多变的复杂场景时依然会出现问题，因此这两者之间出现了合成数据（synthetic data)，迁移学习(transfer learning)，弱监督学习(weakly supervised learning)，少量学习（Few-shot learning/K-shot learning)以及自监督学习(self-supervised learning)，边界当然就是无监督学习了(unsupervised learning)。其中需要注意，self-supervised learning和unsupervised learning不是一回事，前者仍然是有监督学习的一种，正如Quora中的回答：Self-supervised, imposes classification by itself, derivative from the input data.Unsupervised, does not. At all.Meaning, that self-supervised, STILL has a measurement of terms of right contra wrong, as in, terms of classification.Unsupervised, does not.而目前，self-supervised learning正是Yann lecun在2019的ISSCC上所说的最新“蛋糕”组成成分。不过在阅读之前，首先解决一个问题是：什么是machine learning中的“label”和“feature”?简短地说，feature就是输入，label就是输出。一个feature就是我们输入网络数据中的一列，比如说，我们要分类猫和鸟，我们输入特征可能包括颜色，大小，重量等，label就是输出的结果，就是图片的动物是猫还是鸟。Quora上的一个回答比较系统点，这里直接贴出来：Imagine how a toddler might learn to recognize things in the world. The parent, often sits with her and they read a picture book, with photos of animals. The parent teaches the toddler but pointing to the pictures and labeling them: “this is a dog”, “this is a cat”, “this is a tree”, “this is a house”, …After she has learned enough examples, the toddler gets a grasp on what are the key features of a dog, vs these of a cat or of a house or of a tree. So when the toddler and her dad walk in the park, and the father points to a thing she has never seen before, and asks her “what’s that?“, she is capable of generalising her learning, and correctly answer “it’s a dog!“. What might have happened behind the scenes is that consciously or subconsciously, the toddler extracted and examined the features of the “thing” - four legs, fluffy white hair, sticking tounge, round black eyes, etc - which aligned nicely with her preception of a “dog”, and did not match any of the other entity types she knows.So labels were the ground truth categories provided explicitly by her father during learning. And features are what she inferred from these implicitly, and then extracted and examined at “run time” in the park.Similarly, in supervised learning, the NN learns by examples: an experts gives it many training examples, each example explicitly labled with the ground truth answer. The NN tries to predict these labels by modifying the values of the parameters of the NN. When an input comes, different areas of the network becomes active (I.e receive high value), depending on the input. These represent the features of the specific input. The output of the network (e.g classification decision) is a function of which of the parameters are active.So the labels are explicitly given by the trainer during the training, and the features is the configuration of the network - which is implicitly learned by the network, as guided by the labels.It’s these features that then define the output of the network for a given input in runtime.Want to learn more or see how these features are represented? See this great article: Feature Visualization整个supervised learning到unsupervised learning的发展就是人工标注的工作量太大，因为“label”这个东西需要人去手工注解，而且越精细，越准确就使训练结果越好，但是同时也会带来不适应现实数据变化的问题，鲁棒性不好。另外一方面，未标注的数据，“粗糙”的原始数据却很多，同时也比较容易抓取，所以慢慢地会向unsupervised learning发展。Structure该论文的整个写作框架如下：AbstractIntroductionNotations and DefinitionsSuccess of Supervised LearningEffectiveness of Synthetic DataDomain Adaption and Transfer LearningWeakly Supervised LearningIncomplete SupervisionInexact SupervisionInaccurate SupervisionK-Shot LearningSelf-Supervised LearningConclusion and Discussion从整体上看，文章按照监督强度来写的，然后介绍了一些方法出现的原因，同时提及了一些关键的技术，对于更深的探讨没有做进一步地表述，而是直接给出了参考文献。论文的内容：First, we summarize the relevant techniques that fall between the paradigm of supervised and unsupervised learning. Second, we take autonomous navigation as a running example to explain and compare different models. Finally, we highlight some shortcomings of current methods and suggest future directions.ContentReasonSupervised deep learning-based techniques require a large amount of human-annotated training data to learn an adequate model. It is not viable to do so for every domain and task. Particularly, for problems in health care and autonomous navigation, collecting an exhaustive data set is either very expensive or all but impossible. (训练数据集大)Even though supervised methods excel at learning from a large quantity of data, results show that they are particularly poor in generalizing the learned knowledge to new task or domain. This is because a majority of learning techniques assume that both the train and test data are sampled from the same distribution. (功能单一性太强)Two bottlenecks of fully supervised deep learning methods—(1) lack of labeled data in a particular domain; (2) unavailability of direct supervision for a particular task in a given domain.Categories of Methods1.Data-centric techniques which solve the problem by generating a large amount of data similar to the one present in the original data set.Data-centric techniques include data augmentation which involves tweaking the data samples with some pre-defined transformations to increase the overall size of the data set. Another method is to use techniques borrowed from computer graphics to generate synthetic data which is used along with the original data to train the model.2.Algorithm-centric techniques which tweak the learning method to harness the limited data efficiently through various techniques like on-demand human intervention, exploiting the inherent structure of data, capitalizing on freely available data on the web or solving for an easier but related surrogate task.Algorithm-centric techniques try to relax the need of perfectly labeled data by altering the model requirements to acquire supervision through inexact , inaccurate , and incomplete labels. Another set of methods exploit the knowledge gained while learning from a related domain or task by efficiently transferring it to the test environment.3.Hybrid techniques which combine ideas from both the data and algorithm-centric methods.Hybrid methods incorporate techniques which focus on improving the performance of the model at both the data and algorithm level. （比如自动驾驶中的城市道路场景理解任务中，先用合成数据进行训练，然后进行domain shift去适应真实的场景理解任务）Simple Math Definition假设${\cal X}$和${\cal Y}$分别是输入和标签空间（也就是输出了），在一般的机器学习问题中，我们假设要从数据集中学习N个objects。我们从这些objects提取特征去训练模型，即$X = ({\cal x}_{1}, {\cal x}_{2}, \cdots, {\cal x}_{N})$,$P(X)$是$X$上的边缘概率（marginal probability）。在fully supervised learning中，通常假设有相对应的标签$Y = ({\cal y}_{1}, {\cal y}_{2}, \cdots, {\cal y}_{N})$。学习算法就是在假设空间（hypothesis space）${\cal F}$中寻找函数$f: {\cal X} \rightarrow {\cal Y}$，同时在空间${\cal L}$定义了损失函数（loss function)​ $l: {\cal Y} \times {\cal Y} \rightarrow \mathbb {R}^{\geq 0}$来衡量函数的适用性。同时机器学习算法也会最小化误差函数（错误预测）$R$来提升函数的正确性：R = \frac{1}{N}\sum ^{N} _{n=0}l({\cal y}_{i}, f({\cal x}_{i}))对synthetic data来说，输入空间发生了变换，设为${\cal X}_{synth}$，标签空间不变，此外，由于输入特征空间个边缘概率分布都发生了变化，因此利用新的domain${\cal D}_{synth}=\lbrace {\cal X}_{synth}, P({\cal X}_{synth}) \rbrace$来代替原来的real domain${\cal D}=\lbrace {\cal X}, P({\cal X}) \rbrace$。因此，我们也不可能用之前的预测函数$f_{synth}: {\cal X}_{synth} \rightarrow {\cal Y}$ 来构建${\cal X}$到${\cal Y}$的映射。迁移学习（transfer learning）就是用于解决domain adaptation(DA)问题的技术，其不仅可以用于不同domain之间，也可以用于不同的task之间。根据input feature space 在source and target input distribution的分布是否相同，即 ${\cal X}_{s}$是否等于${\cal X}_{t}$，DA可以分为homogeneous DA和heterogeneous DA（同质和异质），显然heterogeneous DA问题要更为复杂些。通常情况下，训练时，supervised learning认为所有的feature sets ${\cal x}_{i}$会有相应的标签${\cal y}_{i}$与之对应，实际情况是，这些标签在实际场景中可能是 $ {\tt incomplete, inexact, inaccurate}$的，因此可能就要在weakly supervised learning技术框架下训练，比如说针对那些在网络抓取的数据而言。针对incomplete的标签场景而言，定义feature set $X = ({\cal x}_{1}, {\cal x}_{2}, \cdots, {\cal x}_{l}, {\cal x}_{l+1}, \cdots, {\cal x}_{n})$，其中$X_{labeled} = ({\cal x}_{1}, {\cal x}_{2}, \cdots, {\cal x}_{l})$会有对应的标签$Y_{labeled} = ({\cal y}_{1}, {\cal y}_{2}, \cdots, {\cal y}_{l})$供其训练，但是$X_{unlabeled} = ({\cal x}_{l+1} \cdots, {\cal x}_{n})$就没有任何对应的标签了。此外，一些其他的weakly supervised模型包含一些有着多种标签的单个实例或者多个实例共享一个标签（multiple-instace single-label)。这个时候会对feature set中的${\cal x}_{i}$进行打包处理，即${\cal x}_{i,j}, j=1,2,\cdots, m$。尽管上述技术框架对应着不同程度的supervision，但是都需要大量的实例instances $X$来训练模型。如果某些class没有足够的instances的话就会使得训练不理想，因此出现了Few-shot learning(少量学习)和Zero-shot learning(ZSL)。如果没有了监督信号（supervision signal），可以利用instances的内在结构（inherent structure）去训练模型。假设$X$和$Y$分别是feature set和label set，此时$P(Y|X)$无法得出，也无法确立任务${\cal T} = \lbrace {\cal Y}, P(Y|X) \rbrace$，不过我们可以定义一个proxy task${\cal T}_{proxy} = \lbrace Z, P(Z|X)\rbrace$，label set$Z$可以自己从数据中提取。For computer vision problems, proxy tasks have been defined based on spatial and temporal alignment, color, and motion cues.Effectiveness of Synthetic Data（个人感觉还是与RL相关的）supervised learning在很多方面都取得了成功，但是存在的问题是需要大量的标注数据进行训练，即使是训练好了，也难以适应现实环境。随着计算机图形学的发展，synthetic data十分易得，而且提供了精确的ground truth，同时数据的可操作性可以让其模拟任何真实的环境场景，甚至是真实环境下难以发生的。In the visual domain, synthetic data have been used mainly for two purposes: (1) evaluation of the generalizability of the model due to the large variability of synthetic test examples, and (2) aiding the training through data augmentation for tasks where it is difficult to obtain ground truth, e.g., optical flow or depth perception.(测试模型的普适性和增强训练过程)此外，还有直接在真实图像中加入synthetic data，比如在KITTI数据集中加入车辆3D模型，以辅助模型训练。One drawback of using syntheticdata for training a model is that it gives rise to “sim2real” domain gap. 这个sim2real是与RL相关的概念，我这里找了一个CMU的PPT，可以看下。Recently, a stream of works in domain randomization claims to generate synthetic data with sufficient variations, such that the model views real data as just another variation of the synthetic data set. 将真实的数据视为合成数据的一个变体。One of the major challenges in using synthetic data for training is the domain gap between real and synthetic data sets. 而迁移学习它提供了一些解决办法。Domain Adaptation and Transfer LearningA model trained on source domain does not perform well on a target domain with different distribution. Domain adaptation(DA) is a technique which addresses this issue by reusing the knowledge gained through the source domain for the target domain.DA techniques根据三个不同的标准进行分类，这三个标准（criteria）是：distance between domainspresence of supervision in the source and target domaintype of domain divergencesPrevalent literature also classifies DA in supervised, semi-supervised, and unsupervised setting according to the presence of labels in source and target domain.Earlier works categorized the domain adaptation problem into homogeneous and heterogeneous settings. 现在，随着深度学习的热度提高，DA开始引入DNN和GAN的思想。DA使用DNN 去learn representations invariant to the domain，Adversarial methods encompass a framework which consists of a label classifier trained adversarially to the domain classifier.Weakly Supervised LearningWeakly supervised learning is an umbrella term covering the predictive models which are trained under incomplete, inexact, or inaccurate labels. Apart from saving annotation cost and time, weakly supervised methods have proven to be robust to change in the domain during testing.Incomplete Supervision(标签不全)Weakly supervised techniques pertaining incomplete labels make use of either semi-supervised or active learning methods. The conventional semi-supervised approaches include self-training, co-training, and graph-based methods.Inexact Supervision(标签注解程度，比如一幅图像的bounding box标注和pixel-level标注)Apart from dealing with partially labeled data sets, weakly supervised techniques also help relax the degree of annotation needed to solve a structured prediction problem.A popular approach to harness inexact labels is to formulate the problem in multiple-instance learning (MIL) framework. In MIL, the image is interpreted as a bag of patches. If one of the patches within the image contains the object of interest, the image is labeled as a positive instance, otherwise negative. Learning scheme alternates between estimating object appearance model and predicting the patches within positive image.Inaccurate Supervision(策划大的数据集给模型训练成本昂贵，同时效果也不一定很好。如果采用从网站抓取数据的方式来给模型训练，可能比较实际，但是这些原始的数据集存在噪声，给训练算法提出了挑战。 “webly” supervised scenario)Broadly, we categorize the techniques into two sets—the first approach resorts to treating the noisy instances as outliers and discard them during training. Another stream of methods focus on building algorithms robust to noise by devising noise-tolerant loss functions or adding appropriate regularization terms.K-Shot Learning(样本少-Few-shot learning和Zero-shot learning)Few-shot learning techniques attempt to adapt the current machine learning methods to perform well under a scenario where only a few training instances are available per class. More recent efforts into a few-shot learning techniques can be broadly categorized into metric-learning and meta-learning-based methods.Metric-learning aims to design techniques forembedding the input instances to a feature space beneficial to few-shot settings. A common approach is to find a good similarity metric in the new feature space applicable to novel categories.Meta-learning entails a class of approaches which quickly adapt to a new task using only a few data instances and training iterations. To achieve this, the model is trained on a set of tasks, such that it transfers the “learning ability” to a novel task. In other words, meta-learners treat the tasks as training examples.Another set of methods for few-shot learning relies onefficient regularization techniques to avoid over-fitting on the small number ofinstances.Literature pertaining to Zero-Shot Learning (ZSL) focuses on finding the representation of a novel category without any instance. Methods used to address ZSL are distinct from few-shot learning. A major assumptiontaken in this setting is that the classes observed by model during training are semantically related to the unseen classes encountered during testing.This semantic relationship is often captured through class-attributes containing shape, color, pose, etc., of the object which are either labeled by experts or obtained through knowledge sources such as Wikipedia, Flickr, etc.In ZSL, a joint embedding space is learned during training where both the visual features and semantic vectors are projected. During testing on unseen classes, nearest-neighbor search is performed in this embedding space to match the projection of visual feature vector against a novel object type.Self-supervised Learning(without any external supervision)Explicit annotation pertaining to the main task is avoided bydefining an auxiliary task that provides a supervisory signal in self-supervised learning. The assumption is that successful training of the model on the auxiliary task will inherently make it learn semantic concepts such as object classes and boundaries. This makes it possible to share knowledge between two tasks.However, unlike transfer learning, it does not require a large amount of annotated data from another domain or task.The existing literature pertaining self-supervision relies on using the spatial and temporal context of an entity for “free” supervision signal.上图比较了supervised learning / weakly-supervised learning / self-supervised learning之间的区别，supervised learning需要bounding box作为label进行训练 ；weakly-supervised learning使用图像级别的标题，语义描述嵌入等进行神经网络预训练；self-supervised learning使用pretext task来学习物体的表示方法。Conclusion and DiscussionThe space between fully supervised and unsupervised learning can be qualitatively divided on the basis of the degree of supervision needed to learn the model.While synthetic data are cost effective and flexible alternative to real-world data sets, the models learned using it still need to be adapted to the real-world setting.Transfer learning techniques address this issue by explicitly aligning different domains through discrepancy-based or adversarial approaches. However, both of these techniques require “strict” annotation pertaining to the task which hinders the generalization capability of the model.Weakly supervised algorithms relax the need of exact supervision by making the learning model tolerant of incomplete, inexact, and inaccurate supervision. This helps the model to harness the huge amount of data available on the web.Even when a particular domain contains an insufficient number of instances, methods in k-shot learning try to build a reasonable model using parameter regularization or meta-learning techniques.Finally, self-supervised techniques completely eliminate the need of annotation as they define a proxy task for which annotation is implicit within the data instances.Despite their success, recent models weigh heavily on deep neural networks for their performance. Hence they carry both the pros and cons of using these models; cons being lack of interpretability and outcomes which largely depend on hyperparameters.]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>survey</tag>
        <tag>supervised learning</tag>
        <tag>domain adaptation</tag>
        <tag>deep neural network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A Brief Review of Object Detection and Semantic Segmentation]]></title>
    <url>%2Fposts%2FBriefreviewofObjectdetection%2F</url>
    <content type="text"><![CDATA[​About目标检测（object detection）和语义分割（semantic segmentation）是计算机视觉的两个重要研究内容，在人脸检测，视频监控和自动驾驶中都有很多的应用，它们对于机器理解环境也具有一定的作用。在视觉SLAM上，已经有科研工作者将这些研究成果加入到现有的SLAM系统中，以提高系统的鲁棒性，同时促进语义SLAM的发展。因此，需要对这些工作进行一些调研总结和学习理解。由于对深度学习不了解，还未系统地进行学习，所以写的内容可能幼稚了些，后续会再进行更新。值得注意的是，目标检测在经典计算机视觉中也已经提出了一些特征描述的方法，在此不涉及，只涉及基于深度学习的目标检测方法，毕竟神经网络在图片特征的学习上比较擅长。本博客将基于文末给出的参考文献来进行总结和学习，尽力把这些问题和技术梳理清楚，同时加入一些自己的思考和不成熟的想法。Task Definitionimage classification—multi level 图像分类，这个任务指的是给出一张图片，要识别出哪张图片属于哪个类别；object detection—what categories and location 物体检测，这个任务除了需要识别出图片属于哪个类别，还需要对相应的物体进行具体位置的定位，我们通常用矩形框来框出这个物体；semantic segmentation—pixel wise, but does not distinct everything in one category 语义分割，这个任务是指对图片中的每个 pixel 打上标签，比如这里要给它们打上 person、sheep、dog 的标签，需要进行非常精细的分类；instance segmentation—object detection+semantic segmentation 实例分割，可以理解为进行物体检测后，对每个矩形框中的物体进行语义分割，该任务除了需要找到物体的类别和位置之外，还需要分辨出不同物体的 pixel；Object DetectionProgress (一步法single-stage, 两步法two stage)最近有一篇很好的综述[5]详细地梳理了最近5年来的generic object detection技术发展和比较的综述。上图绿色的字体表示的是 Two-stage Detector 的发展历程，当然还有很多其他的方法，这里列出的是一些比较有代表性的方法。2014 年有一项很重要的工作是 R-CNN，它是将物体检测首次应用于深度学习中的一篇论文，它的主要思路是将物体检测转化为这么一个问题：首先找到一个 region（区域），然后对 region 做分类。之后作者又提出了 Fast R-CNN，它是一个基于 R-CNN 的算法，运算速度显著提高。2015 年，这一群人又提出了 Faster R-CNN，它在速度上相比 Fast R-CNN 有了更大的提高，主要是改进了怎样在 Fast R-CNN 和 R-CNN 中找 region 的过程，Faster R-CNN 也是用深度学习的方法得到一些 region（称之为 proposal），然后再用这些 proposal 来做分类。虽然距离 Faster R-CNN 的提出已经三年多了，但它依旧是使用非常广泛的一种算法。2016 年，代季峰等人提出了 R-FCN，它在 Faster R-CNN 的基础上进行了改进，当时它在性能和速度都有非常大的提高。2017 年有两篇影响力非常大的论文，FPN 和 Mask R-CNN。FPN 也就是 Feature Pyramid Network，何恺明大神的论文，它相当于生成了 feature pyramid，然后再用多个 level 的 feature 来做 prediction。Mask R-CNN 这篇论文获得了 ICCV 2017 的最佳论文，也是何恺明大神的作品，其在 Faster R-CNN 基础上增加了 mask branch，可以用来做实例分割，同时因为有 multi-task learning，因此它对物体框的性能也有很大的提高。（另外，今年年初，2019.1月，何恺明将自己的Mask R-CNN和FPN合在了一起，效果也不错）。2018 年，沿着 Faster R-CNN 这条路线提出的方法有 Cascade R-CNN，它将 cascade 结构用在了 Faster R-CNN 中，同时也解决了一些 training distribution 的一些问题，因此它的性能是比较高的。另外还有两篇比较重要的论文——Relaiton Network 和 SNIP。上图蓝色字体表示的 Single-stage Detector 的发展历程：2014 年的 MultiBox 是非常早期的工作；2016 年提出了 SSD 和 YOLO，这两篇论文是 Single-stage Detector 中的代表作；2017 年提出了 RetinaNet（当时 Single-stage Detector 中性能最高的方法）和 YOLO v2；2018 年有一个新的思路，提出了 CornerNet，把物体检测看成一堆点的检测，然后将这些点 group 起来。General Pipeline of Object Detection参考文献[2]很好地解释了深度学习进行object detection的思路是什么。如前所述，基于深度学习的Object Detection的方法主要有两条发展脉络，一个是single-stage detector，另一个是two-stage detector.Two-stage detector第一部分是 Feature generation：首先图片经过 backbone（分类网络）后，会生成 feature； 之后 feature 或者直接进行 prediction，或者再过一个 neck 进行修改或增强；第二部分是 Region proposal：这个部分是 Two-stage Detector 的第一个 stage，其中会有一堆 sliding window anchor（预先定义好大小的框），之后对这些框做 dense 的分类和回归；接着再筛除大部分 negative anchor，留出可能是物体的框，这些框称之为 proposal；第三个部分是 Region recognition：有了 proposal 后，在 feature map 上利用 Rol feature extractor 来提取出每一个 proposal 对应的 feature（Rol feature），最后会经过 task head；Single-stage detector图片首先经过 feature generation 模块，这里也有 sliding window anchor，但是它们不是用来生成 proposal 的，而是直接用于做最终的 prediction，通过 dense 的分类和回归，能直接生成最终的检测结果。一步法和两步法的区别到底在哪里？实际上，现在的二步法object detection的框架都是基于Faster R-CNN的，一步法中的比较全面的算法是SSD，这两个在后面我都会进行详细地阐述。对于两步法的基础Faster R-CNN，两个阶段分别在RPN和R-CNN中完成，第一阶段是预设一系列不同大小和比例的anchors，然后将整张图传入CNN提取特征，最后利用PRN对anchors进行分类和回归，得到候选区域（proposals）；第二阶段是利用RolPooling扣取每个候选区域的特征，接着把扣取特征的特征送入后续R-CNN网络，最后对候选区域进一步分类和回归，得到最终的检测结果。由上图也可以看出，两步法是相对于一步法多了二阶段的分类，回归和特征，因而精度会更好，但是会使得算法运行的时间加长。也就是说，一步法也就是类似于只有RPN阶段，而二步法多了R-CNN，使得分类更加精细，同时再对候选区域进行回归。那么一步法是否可以仿照这样的思路或者利用其他的方法达到二步法的精度，却又不损失运行效率？在参考文献[3]里面，张士峰博士分享了他们的工作Single-Shot Refinement Neural Network for Object Detection，在SSD中加入一些类似R-CNN作用的模块，来提高检测的精度，同时也保持了原有的运行效率。整个结构包含ARM模块，TCB连接和ODM模块，其中ARM模块和ODM模块分别对应二步法中的RPN和R-CNN的功能，TCB的主要作用是转换ARM特征，融合高层特征，因为两步法中的特征不相同，第二阶段会提取新的特征，因此需要转换和融合。该方法与二步法的区别在于没有RoIPooling，因此运行时间不会边长。该方法的精度大概较SSD提升了两个点，速度上会更快些，因为输入图像的分辨率可以是320x320的。具体的检测框架和测试结果可以看原论文。借此提下object detection近年来的发展趋势应当不再是该网络调参来刷速度和正确率，而是回归到框架本身的反思和设计上，毕竟现有的算法都是从Faster R-CNN来的，因此是否可以反思该框架的问题，然后对其进行改善，或者直接提出新的检测思路，比如说在前处理阶段的anchors和后处理阶段的NMS都是手动设置的，这个是否可以进行自动调节，也是一个值得研究的点。另外，在视觉SLAM和很多其他的应用场景上，输入的都是视频流的形式，而不是单个的图像，这一方面对算法的实时性，硬件的运算速度提出了要求，另一方面也对视频物体检测提出了要求，如何利用帧与帧之间的信息来加速物体检测，也是有待研究的。最后一点就是，视觉SLAM的最终梦想是能在现实大环境下进行运行，然后给出环境地图，以此与人进行交互。现实场景很复杂，充满动态的，不确定性的因素，因此这样的功能要想实现还有很长的路要走。不过可以预见的是，视觉SLAM需要结合这些新的，基于学习方法的计算机视觉的研究成果，以帮助机器人来理解环境，提高系统的鲁棒性，同时各个模块和任务之间也将是相互联系相互促进的，多任务联合（multi-task），以此提升系统的容错性 和运行时间。Faster R-CNNFaster R-CNN 是 Two-stage Detector 工作的基础，它主要提出了两个东西:RPN：即 Region Proposal Network，目前是生成 proposal 的一个标准方式;Traning pipeline：主要讲的是 Two-stage Detector 应该怎样 train，论文里给出的是一种交替(alternating training)的方法;因为深度学习的发展，大家都不想一步一步来回调参，因此会有了joint training这个东西。FPNFPN（Feature Pyramid Network）主要也是提出了两项重要的思路：Top-down pathway 和 Multi-level prediction。下图中的 4 张图代表了基于单个或多个 feature map 来做预测的 4 种不同的套路：具体实现如下图所示：MASK R-CNNMask R-CNN 主要也有两点贡献：RoIAlign和Mask branchRoIAlign：在 Mask R-CNN 之前，大家用得比较多的是 Rol Pooling，实现过程是：给出一个框，在 feature map 上 pool 出一个固定大小的 feature，比如要 pool 一个 2×2 的 feature，首先把这个框画出 2×2 的格子，每个格子映射到 feature map，看它覆盖了多少个点，之后对这些点做 max pooling，这样就能得出一个 2×2 的 feature。它的劣势是如果框稍微偏一点，得出的 feature 却可能是一样的，存在截断误差。RolAlign 就是为了解决这一问题提出的。Rol Align 并不是直接对框内的点做 max pooling，而是用双线性插值的方式得到 feature。其中还有一步是：在 2×2 的每个框中会选择多个点作为它的代表，这里选择了 4 个点，每个点分别做双线性插值，之后再让这 4 个点做 max/average poolingMask branch：它是一个非常精细的操作，也有额外的监督信息，对整个框架的性能都有所提高。它的操作过程如下图所示:Cascade R-CNNCascade R-CNN 是目前 Faster R-CNN 这条线中较新的方法。这个方法也提出了两点贡献：一是提出了使用 cascade architecture；二是提出了怎样来适应 training distribution。Cascade architecture ：这个框架不是特别新的东西，之前也有类似的结构。下图左边是 Faster R-CNN，右边是 Cascade R-CNN。其中 I 代表图像或者图像生成的 feature map，H0 是 RPN，B 是 bounding box regression，C 是 classification。经过 RPN 得到的 proposal 再做 pooling 后，会有分类和回归这两个 prediction。Cascade R-CNN 的结构是，在经过第一次分类和回归之后，会用得到 bounding box 再来做一次 pooling，然后对这些框做下一阶段的分类和回归，这个过程可以重复多次。但如果仅仅使用 Cascade R-CNN 而不做其他改变，Cascade R-CNN 带来的提高是非常有限的。 Cascade R-CNN 提出了一个很好的 motivation，这是它比较有意义的一个地方。它研究了一下采用不同的 IoU 阈值来进行 training 的情况下，Detector 和 Regressor 的性能分布。RetinaNetRetinaNet 是 Singe-stage Detector 目前比较重要的一项工作，它可以看做是由 FPN+Focal Loss 组成的，其中 FPN 只是该论文中用到的架构，而 Focal Loss 则是本论文主要提出的工作。RetinaNet 结构如下：RetinaNet 的结构 和 SSD 非常类似，只不过它用的是 ResNet，并在 ResNet 上加入了 FPN 的结构，每一层都有两个分支：一个用来做分类；另一个用来做框回归。此外它的每个 head 都比 SSD 和 Faster R-CNN 都要大一点，这样的话，它的参数量比较大，计算速度也比较慢。而 Focal Loss 试图解决的问题是 class imbalance。针对 class imbalance 的问题，Two-stage Detector 一般是通过 proposal、mini-batch sampaling 两种方式来解决的；SSD 是通过 hard negative mining 来解决的；而 RetinaNet 则通过 Focal Loss 来解决该问题。Focal loss 的核心思路是：对于 high confidence 的样本，给一个小的 loss——这是因为正负样本不平衡，或者说是由于 class imbalance 导致了这样的问题：比如说正负样本的比例是 1:1000，虽然负样本的 loss 都很小，但数目非常多，这些负样本的 loss 加起来的话，还是比正样本要多——这样的话，负样本就会主导整个框架。Relation Network在 Relation Network 之前的大部分 detectcor，在做 prediction 或 training 的时候通常只考虑到当前这一个框，而 Relation Network 提出还要考虑这个框周围的框，并基于此提出了一个 relation module，可以插在网络的任何位置，相当于是 feature refinement。Relation module 如下图所示：它的核心思想是：当前框的 feature 除了由当前框决定之外，还要考虑当前框和周围框及其它框的关系SNIPSNIP（Scale Normalization for Image Pyramids）另一篇比较有启发性的工作。它提出的问题是：在 train 分类器的时候，究竟是要 scale specific 还是 scale invariant。传统的 detector 通常会选择 scale invariant，但 SNIP 研究了一下之前的方法后，发现之前的训练方式得到的 feature 对 scale 并没不是很 robust，因而提出要尽量减少 scale 的 variance，让训练时的 scale 尽可能地相似。SNIP 结构图如下:CornerNetCornerNet，是 Singe-stage Detector 中比较新的方法，其与其他方法最不一样的地方是：之前的方法会在图像上选出框，再对框做分类的问题；CornerNet 则是在图中找到 pair 的关键点，这个点就代表物体。它的 pipeline 包括两步：第一步是检测到这样的 corner，即 keypoint；第二步是 group corner，就是说怎样将同一个物体的左上顶点和右下顶点框到一起。其算法结构如下：mmdetection港中文多媒体实验室的开源物体检测框架。References[1]. 物体检测算法的近期发展及开源框架介绍-陈恺[2]. 基于深度学习的目标检测技术演进：R-CNN、Fast R-CNN、Faster R-CNN[3]. 基于深度学习的物体检测算法对比探索 - 张士峰[4]. 基于深度学习的目标检测算法近5年发展历史（综述）[5]. Deep Learning for Generic Object Detection: A Survey[6]. 目标检测算法中检测框合并策略技术综述[7]. 综述 | CVPR2019目标检测方法进展]]></content>
      <categories>
        <category>科研记录</category>
      </categories>
      <tags>
        <tag>computer vision</tag>
        <tag>deep learning</tag>
        <tag>object detection</tag>
        <tag>semantic segmentation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04下安装NVIDIA最新驱动以及深度学习环境配置]]></title>
    <url>%2Fposts%2FbuildDLenvir%2F</url>
    <content type="text"><![CDATA[2019.3.8日来更，可以不用看以前下面写的内容了，因为不是很完整。。。如果按照之前说的通过官网下载的run文件来手动安装驱动，可能出现nvidia-settings打不开的情况，比如我就是输出信息：“ERROR: Unable to load info from any available system”，这样会导致我的电脑识别不了外接显示器。。。后来在网上看了一些人的回答，大致的原因是官网的run文件在安装时后会默认更改一些系统配置，因此可能会导致一些错误。。解决办法：通过Ubuntu自动的install功能进行安装1.先按照这个教程卸载驱动，然后禁用好nouveau；2.重启后确认nouveau已禁用，关闭图形界面，进入命令行界面；3.输入下面的命令：1234sudo add-apt-repository ppa:graphics-drivers/ppasudo apt-get updatesudo apt-get install nvidia- #这里选择你要安装的版本，最新的应该也没问题，我就是直接装的410，省得到时候又得重装CUDA和CUDNNreboot #重启4.再次开机后应该就没问题了，nvidia-smi, nvidia-settings都没问题了，外接显示器也正常了。写在前面本人电脑是战神神舟Z7M-KP5GZ，显卡是GTX1050TI，按照以前利用liveusb的方法安装了Ubuntu16.04双系统，然而第一次安装NVIDIA驱动的时候有些问题，直接是在软件更新里面安装的系统自带驱动，版本384。后来配置深度学习环境需要安装CUDA和CUDNN，由于安装最新版本的CUDA需要相应的驱动版本对应，因此需要对NVIDIA驱动进行更新。在安装过程中，遇到了一些问题，主要是：驱动安装后Ubuntu系统无法进入，卡在启动界面的5个原点；成功进入系统后，分辨率低；后来根据几篇博客解决了上述问题：博客1博客2博客3博客4后来总结了下，最主要的问题是一定要禁用nouveau，可以通过下面的命令看是否禁用，如果不输出信息则是成功禁用。。一定要注意，如果之前装过了NVIDIA驱动，然后卸载重装了一定要记得再次禁用！！！！1lsmod | grep nouveau利用run方式安装NVIDIA最新驱动1.验证nouveau是否已禁用1lsmod | grep nouveau2.如果没有输出信息，则说明已经禁用，如果没有，编辑文件blacklist.conf1sudo vim /etc/modprobe.d/blacklist.conf在文件最后部分插入以下两行内容(i插入，esc退出编辑，:wq退出并保存)12blacklist nouveauoptions nouveau modeset=0更新系统1sudo update-initramfs -u重启系统，再看看是不是禁用了nouveau3.在英伟达官网查找并下载自己对应的驱动(.run文件)4.ctrl+alt+F1进入命令行界面，登陆进入，并关闭图形界面1sudo service lightdm stop5.卸载原有的驱动123456apt-get purge nvidia-*nvidia-smi#如果还有信息，输入下面的代码sudo /usr/bin/nvidia-uninstallnvidia-smi#没有驱动信息则成功6.进入驱动文件夹12sudo chmod a+x NVIDIA-Linux-x86_64-xxx.x.run #这里版本号每个人可能不同(xxx.xx代表版本号)sudo ./NVIDIA-Linux-x86_64-xxx.xx.run -no-x-check -no-nouveau-check -no-opengl-files7.安装过程中的选项很重要，如果选错了，不要重启，重新安装就行了其中register the kernel module souces with DKMS选择NO，Nvidia’s 32-bit compatibility libraries也选NO，其他的YES或者正常就行。8.检查是否安装完成1234modprobe nvidia #挂载驱动nvidia-smi#如果出现驱动信息表示安装成功sudo service lightdm start #重新进入图形界面9.如果重启开机没问题，那么万事大吉，如果进不去，或者卡在启动界面，可以选择recovery mode进入系统，然后修改grub文件，我是依据博客3解决了我的问题，我看了下，应该还是nouveau的问题。每个电脑不一样，如果依据此博客还是解决不了，那么根据自己的问题去百度或者Google吧。。10.通过recovery mode进入了系统后，重新按照前述步骤卸载重装NVIDIA驱动，这说明了我之前卸载不干净或者卸载之后nouveau又被重新开启了。。。。11.之后重启后就能正常进入Ubuntu系统了，这说明应该已经成功了，之后再重新打开grub文件（博客3），把之前改过的再改回来，然后重启12.重启之后发现分辨率低而且无法在设置中心改，按照博客4的方法结果成功解决了问题，自此，NVIDIA驱动安装完成。安装CUDA和CUDNN安装好驱动后基本上等于深度学习环境配置进度完成了80%了，之后可以安装相应的CUDA和CUDNN了，安装过程比较简单，在此不再赘述，可以参照以下两篇博客，也可以自己重新定义版本关键词进行搜索。博客6博客7**2018.3.2踩坑来更**今天Ubuntu系统提示升级，结果升级了内核kernel，导致升级完成重启后出现ACPI ERROR之类的错误，看了一大推的博客总结后，发现问题是“升级之后的内核，是不会自动加载你的显卡驱动的，那就需要在这个心内核上手动重新安装NV驱动。” 所以，等装完了驱动后，最好禁止Ubuntu内核更新或者直接禁止Ubuntu更新。所以，升级内核后，需要重新安装NVIDIA驱动。。！！！！！！当然重装驱动的最重要步骤就是禁用nouveau,这里我看到了另一篇博客（博客8）讲得比较详细，基本上只看这一篇博客就可以安装并配置好深度学习环境了，要记得同时修改/etc/modprobe.d/disable-nouveau.conf和/etc/default/grub而且要特别注意，装完后要记得回来修改/etc/default/grub，否则修改分辨率后会发现没有作用。我今天安装时做了实验，我是按照博客3对/etc/default/grub进行修改的，也就是加了“nomodeset”，发现只有将它删除，博客4的修改方法才有用，另外注意博客4添加的Modes后面的分辨率要根据自己的电脑调整，否则可能出现登录界面比较小，没接到电脑边。英伟达的驱动真是一大堆破事，，看来是时候着手docker了。。]]></content>
      <categories>
        <category>深度学习环境配置</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
        <tag>linux</tag>
        <tag>nvidia driver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linear Algebra of MIT]]></title>
    <url>%2Fposts%2FnotesofLinearAlgebra%2F</url>
    <content type="text"><![CDATA[​ ​这是对MIT 18.06 open course— Linear Algebra—by Gilbert Strang 的课程总结。课程视频及主页资料由于计算机视觉以及机器学习中对矩阵的要求较高，而且本科阶段的高等代数学得不太行，故借此机会将这个著名的MIT线性代数公开课看了一遍，相关的课程视频和材料放在下面。lectures:readings:assignments:exams:tools:课程脉络Gilbert老爷子这门线代课应用性很强，在课堂上经常结合工程实际来探讨矩阵在其中的应用和联系，比如在对投影，最小二乘法原理以及求解矛盾方程组的三者之间用$A^{T}A$进行联系，这中“惊人”的发现也进一步加深了我对线性代数的通用性认识，所以这门课对搞了一些研究回过头来听的人来说很有启发，有时候没事可以时常翻翻这门课的教材。这门课的核心思想就是老爷子的那张著名的”four subspaces”图，如下图所示。整门课分为三个部分：$Ax=b$和四个子空间；最小二乘法，行列式和特征值；正定矩阵以及应用。Gilbert先从方程组入手，指出现实生活中的问题抽象成一系列方程，组成方程组，因此矩阵的出现是为了应对消元求解方程组，同时利用系数矩阵来从另一个层面认识这个系统的性质，比如可解性，稳定性等等，在这里，Gilbert将系数矩阵看成是向量的线性组合，从而直接转成空间的角度来看待“解”，这也是该部分的一个重要思想。矩阵也会表示空间，最基本的思想是把矩阵认为是n个列向量组成的，研究这些列向量彼此之间的关系来来研究矩阵代表的空间。求解问题也变成是列向量的线性组合。矩阵的行变换代表着消元法，同时也会引发矩阵的分解，求解Ax=b时转换成矩阵的列空间和零空间来二分，特定解和特殊解。之后引申出四个基本子空间：行空间，零空间，列空间，左零空间，进而指出空间的维数和基。第一部分的关键词就是消元，向量，线性组合和空间。矩阵，空间，方程组之间是等价的。到了第二部分，Gilbert开始引入行列式。他先从正交矩阵讲起，即$A^{T}A=I$，指出了它在投影，最小二乘，求解矛盾方程组之间的作用，并且利用它把这些问题都联系在了一起。其本质的原因可能是所谓的”空间度量，距离最小“，然后系数矩阵$A$恰好用这种方式呈现出来。之后引入行列式就很自然了，因为要求”大小“或者”长度“。Gilbert通过三个基本的性质定义了矩阵的行列式，并且推导出了其他几种性质，然后顺带着给出了行列式的计算公式和求解方程组的作用，及求逆公式，虽然他并不推崇这种死板的大计算量的方法来求解。最后，Gilbert借着行列式给出了矩阵的特征值，特征向量，以及特征值在对角化和其他工程中的应用（行列式的作用就是对角化）。不过比较可惜的一点是，教授并没有深层次探讨矩阵的特征值的意义，仅仅是从特征值公式上说”向量经过矩阵变换后方向不变“，虽然后来的例子又将特征值特征向量与主轴定理结合起来，但是依然没有一种很明晰的感觉。可能因为这是工科课程，重在讲解应用和联系。。希望我后面能在”linear algebra done right”这本书里找到答案。最后一部分的主题是正定性，这类似与函数当中的最小值对应条件问题。这一部分我看得比较乱，没看出什么真正的名堂出来，毕竟从内容上我没找出什么联系。我后来问了数学系的同学，他说正定矩阵是为了定义内积空间（又称希尔伯空间，量子力学就是定义在这个上面）。这里面涉及到多元函数最小值判定，酉矩阵，以及奇异值分解，因此还是比较重要的内容。实际上呢，教授是从多元线性方程组的角度来讲线性代数和矩阵的，因此并不像数学系那样从映射，集合、环、域，空间，然后到空间结构，代数，多元数组的关系来展开讲。因为是工科课程，所以第一关心的问题是怎么用，后面才会去进一步关注如何产生这种思想的问题，在这里，Gilbert教授关注的是矩阵角度解方程组，诸如矩阵分解、对角化，投影，正交矩阵，正定矩阵都是为了和工程中实际方法相联系和结合，因此可以看作是一种“top-down”的讲授思维。对于做SLAM和机器学习来讲，关注更多的好像还是数值矩阵求解，即如何利用数值计算工具，更有效，更准确的分解、求解矩阵，所以，我接下来还得继续看fast.ai的numerical linear algebra课了。。阅读材料这门课除了Gilbert Strang的那本教材，还有一些其他的资料，我把它们都托管到了我的Github上，有需要的请自取。清单如下：Introduction to Linear Algebra超详细MIT线性代数公开课笔记神奇的矩阵第一季神奇的矩阵第二季线性代数的几何意义Linear Algebra Done Right另外也有其他几本线性代数教材也不错：圣经 Linear Algebra-hoffmanLinear Algebra and Its Applications-David C. LayIntroduction to Applied Linear Algebra—Vectors, Matrices, and Least Squares看完《线性代数的几何意义》和《神奇的矩阵》来更线性代数的几何意义线性代数代数的功能是进行抽象，为了解决问题的方便，提高效率。线性代数里面的线性主要是指线性空间里面的线性变换（可加性和比例性），通过线性算子定义了线性变换，也就是变换满足可加性和比例性，实际上，差分，微分都是一种数学上的算子，代表一种运算关系。行列式行列式的几何意义具有深刻的含义。它是指行列式的行向量或列向量所构成的平行多面体的有向体积。这个有向体积是由许多块更小的有向面积或有向体积的累加。行列式的几何意义是什么呢？概括说来有两个解释：一个解释是行列式就是行列式中的行或列向量所构成的超平行多面体的 有向面积或有向体积；另一个解释是矩阵 $A$ 的行列式 $detA$ 就是线性变换 $A$ 下的图形面积或体积的伸缩因子。一个给定的行列式，它的行向量顺序也给定了，不能随意改变其顺序。一个行列式的整体几何意义是有向线段（一阶行列式）或有向面积（二阶行列式）或有向体积（三阶行列式及以上）。因此，行列式最基本的几何意义是由各个坐标轴上的有向线段所围起来的所有有向面积或有向体积的累加和。这个累加要注意每个面积或体积的方向或符号，方向相同的要加，方向相反的要减，因而，这个累加的和是代数和。行列式的乘积项及其逆序数的几何意义实际上是行列式最根本的几何意义，因而可以解释所有的行列式的定义及其性质。向量空间设$V$是非空的n维向量的集合(n=1,2,3…)，如果$V$中的向量对加法和数乘两种运算封闭，即：\begin{align*} & 1. 若\overrightarrow{a},\overrightarrow{b} \in V,则\overrightarrow{a}+\overrightarrow{b} \in V \\ & 2. \overrightarrow{a} \in V,则k\overrightarrow{a} \in V,k为任意实数 \end{align*}​ 则称$V$为向量空间。向量空间主要有两种：一种是由 V 中的一个向量组张成的空间（比如由特征向量张成的子空间等）。另外一种齐次线性方程组的解集组成的解空间。实际上，线性方程组的解空间也是解向量所张成，这两种空间里都包含有无穷多的向量。值得注意的是，所有的子空间一定要包含零空间在内。实际上，我们现在讨论的向量，不能称之为自由向量，因为所有的向量的尾巴都被拉到了原点上，或者说，所有向量空间里的向量都是从原点出发的，大家都有一个共同的零空间，这就是为什么所有的子空间一定要包含零空间的原因了。为什么要把向量的尾部都拉到原点是为了研究向量的方便，因为这样就可以把向量和空间中的点一一对应起来。空间中一旦建立起了坐标系，点有坐标值，那么我们就用点的坐标表示与点对应的向量，这样向量就有了解析式，就有了向量的坐标表达式，我们就可以方面的使用代数中的矩阵技术进行分析及计算了。如果一个子空间没有通过原点，那么从原点出发的向量必然首尾不顾，造成了向量头在子空间中尾在空间外（因为原点在空间外）。当然，向量的加法和数乘也都跑到子空间外面去了。内积的定义要解决空间中不同的基带来不同坐标度量带来向量长度和夹角的变化。可以通过内积度量矩阵$P^{T}P$来解决此问题，无论你变了多少次基，每变一次基同时就改变一次度量矩阵，从而来保证内积值的不变性，这样也就保证了向量空间度量的一致性，达到了度量值不随坐标改变而改变的目的。矩阵我们知道，在直角坐标系中，一个有序的实数数组$(a,b)$和$(a,b,c)$分别代表了平面上和空间上的一个点，这就是实数组的几何意义。类似的，在线性空间中如果确定了一个基，线性映射就可以用确定的矩阵来表示，这就是矩阵的几何意义：线性空间上的线性映射。矩阵独立的几何意义表现为对向量的作用结果。如果用数组来统一定义标量、向量和矩阵的话就是：标量是一维向量，向量是标量的数组，矩阵则是向量的数组。矩阵与向量乘积比如$Ax$表现为矩阵$A$对一个向量$x$作用的结果。其作用的主要过程是对一个向量进行旋转和缩放的综合过程（即线性变换的过程），一个向量就变换为另外一个向量。一个 m 行 n 列的实矩阵$A_{m \times n}$就是一个$R^{n} \rightarrow R^{m}$上的线性变换，或者说，矩阵$A_{m \times n}$把一个n维空间的 n 维向量变换为一个m维空间的m维向量。一个矩阵乘以一个向量，一般将会对向量的几何图形进行旋转和伸缩变化，而旋转矩阵只对向量进行旋转变化而没有伸缩变化，例如二阶旋转矩阵$A$：A= \begin{pmatrix} \cos \theta & -\sin \theta \\ \sin \theta & \cos \theta \end{pmatrix}如果将上面的旋转矩阵分别按行向量和列向量来看，随着角度的增大，行向量在顺时针旋转，而列向量在逆时针旋转，“这正是正交矩阵的特征”（然而这一结论的得出还不是很明了）。旋转矩阵为正交矩阵。矩阵与矩阵的相乘的几何意义，可以从矩阵与多个向量相乘的几何意义得到，只是多个向量被按照顺序组合成了另一个矩阵。实际上，从$R^{n} \rightarrow R^{m}$上的线性变换都可以表述为一个矩阵变换；反过来，一个矩阵变换也必然是一个线性变换。两者具有一一对应的关系。一个矩阵变换也必然是一个线性变换。这个对应关系笼统地表述如下：线性变换的和对应着矩阵的和；线性变换的乘积对应着矩阵的乘积；线性变换的数量乘积对应着矩阵的数量乘积；线性变换的逆对应着矩阵的逆；下面的定理给出了如何把一个$R^{2}$空间上的线性变换转换成一个对应的 2 阶矩阵的办法:定理：设T:R^{2} \rightarrow R^{2}是一个线性变换，那么T的矩阵的列向量为T(e_{1})和T(e_{2})由于线性变换与矩阵之间有一一对应（在给定基的前提下），而且保持线性运算关系不变（线性变换的加法和数乘分别对应于在某一个基下的矩阵的加法和数乘），因此，可以用矩阵来研究线性变换，也可以用线性变换来研究矩阵。常见的线性变换有初等变换、等价变换、相似变换、合同变换等。我们也常常听到正交变换的名字，但由于正交变换包括平移、旋转和镜像，我们知道平移变换不是线性变换，因此不是所有的正交变换是线性变换。一个矩阵就是把第一象限的单位立方体变换到其他象限的多面体，单位立方体由单位基向量张成，多面体由矩阵列向量张成；而列向量是由基向量变换得到的。对于n阶方阵，把列看作列向量，则行是每个列向量在列空间各个坐标轴上的投影（坐标），行的数量则是列空间坐标系的维数。特征值和特征向量的几何意义：$Ax=\lambda x$方阵乘以一个向量的结果仍然是一个同维向量，矩阵乘法对应了一个变换，把一个向量变成同维数的另一个向量。在这个变换的过程中，向量会发生旋转、伸缩或镜像的变化。矩阵不同，向量变化的结果也会不同。如果矩阵对某一个向量或者某些向量只发生伸缩变换，不对这些向量产生旋转效果，那么这些向量就是这个矩阵的特征向量，伸缩的比例就是特征值；如果伸缩的比例值是负值，原向量的方向改变为反方向，原向量仍然是这个矩阵的特征值。因此，从矩阵的几何意义上看，矩阵$A$的特征向量$\overrightarrow a$就是经过矩阵$A$变换后与自己平行的非零向量，矩阵$A$的特征值$\lambda$就是特征向量$\overrightarrow a$经变换后的伸缩系数（复特征值会使特征向量在复平面进行旋转，但在实轴上仍然是只进行伸缩变换）。特征值反映了特征向量在变换时的伸缩倍数。对一个变换而言。特征向量指明变换的方向，而特征值反映的是变换的剧烈程度！我们知道，一个矩阵，只要我们找到合适的坐标，它的全部信息就可以用坐标系和特征值表示。这里蕴含了一个哲理：我们从不同角度看问题，其难易程度是不一样的！而矩阵对角化为我们提供了一个很好的看问题的角度。矩阵的特征值之和等于矩阵的迹，特征值之积等于矩阵的行列式。这个由二阶矩阵推广而来。关于特征值和特征向量，一是注意线性不变量的含义，一个是振动的谱含义。特征向量是线性不变量，特征值是振动的谱。机械振动和电振动有频谱，振动的某个频率具有某个幅度，那么矩阵也有矩阵的谱，矩阵的谱就是矩阵特征值的概念，是矩阵所固有的属性，所有的特征值形成了矩阵的一个频谱，每个特征值是矩阵的一个“谐振频点”。矩阵的谱分解就是抓住了矩阵的主要矛盾，因此也是主成分分析（PCA），奇异值分解相关的内容。矩阵之所以能形成“频率的谱”，就是因为矩阵在特征向量所指的方向上具有对向量产生恒定的变换作用：周期性地增强或减弱特征向量的作用。进一步地，如果矩阵持续地叠代作用于向量，那么特征向量就会凸现出来。可类比与电路中的振荡器。几何重数与代数重数：一个特征值的求解因式的次数称为代数重数，特征值的特征子空间的维数称为几何重数。一般来说，特征值的代数重数大于或等于几何重数。相似矩阵：或矩阵$A$与矩阵$B$相似，一定存在一个非奇异矩阵$P$（基变换矩阵），有$A=PBP^{-1}$。核心的几何意义就是相似矩阵$A$和$B$是同一个线性变换在两个不同基下的表示矩阵。线性变换的相似对角化实质是寻找一个适当的坐标系，使得该变换对这个新的坐标系上的单位向量（或基向量）只做伸缩变换，不做旋转变换。不是任何矩阵都可以相似对角化，除非由n个线性无关的特征向量，但是实对称矩阵一定可以对角化。这里的证明涉及到一系列定理：\begin{align*} & 定理1： 实对称矩阵A的特征值都是实数 \\ & 定理2： 实对称矩阵A的不同特征值对应的特征向量一定是相互正交的（正交的向量组一定是线性无关向量组）\\ & 定理3： 实对称矩阵A的r重特征根\lambda一定有r个线性无关的特征向量 \end{align*}雅可比矩阵：雅可比矩阵是线性代数和微积分的纽带，是把非线性问题转换为线性问题的有力工具之一。一个函数方程组由n个函数构成，每个函数有n个自变量$x_{1},x_{2},x_{3},\cdots x_{n}$\begin{cases} y_{1}=f_{1}(x_{1},x_{2},\cdots x_{n}) \\ y_{2}=f_{2}(x_{1},x_{2},\cdots x_{n})\\ \vdots \\ y_{n}=f_{n}(x_{1},x_{2},\dots x_{n}) \end{cases}一般情况下，该函数方程组不是线性方程组，是多维曲线、曲面类的，通过微积分的思想化曲为直，将上述方程组化为超维切平面。先偏微分再写成矩阵的形式：\begin{pmatrix} dy_{1}\\ dy_{2}\\ \vdots\\ dy_{n} \end{pmatrix} = \begin{bmatrix} \frac{\partial f_{1}}{\partial x_{1}} & \frac{\partial f_{1}}{\partial x_{2}} & \cdots & \frac{\partial f_{1}}{\partial x_{n}}\\ \frac{\partial f_{2}}{\partial x_{1}} & \frac{\partial f_{2}}{\partial x_{2}} & \cdots & \frac{\partial f_{2}}{\partial x_{n}}\\ \vdots & \vdots & \cdots & \vdots \\ \frac{\partial f_{n}}{\partial x_{1}} & \frac{\partial f_{n}}{\partial x_{2}} & \cdots & \frac{\partial f_{n}}{\partial x_{n}} \end{bmatrix} \begin{pmatrix} dx_{1}\\ dx_{2}\\ \vdots\\ dx_{n} \end{pmatrix}其中，中间的方块矩阵就是雅可比矩阵$J$，里面的元素一般不是常数，而是变量或函数，说明雅可比矩阵包含着很多个具体的变换矩阵。雅可比矩阵把一个超平面的仿射坐标系变换成了一个超曲面坐标系；雅可比行列式就是曲面坐标系下单位微元和仿射坐标系下单位微元面积的比值。（雅可比矩阵把一个空间里的一个平面坐标系（基）变换成了无数个极小平面坐标系（基）；无数个极小平面就是曲面的切平面；雅可比行列式就是切平面上每个坐标系下极小单位元和原坐标系下极小单位元面积的比值。）整个线性代数里矩阵之间有三种典型的关系：矩阵相似（similar）、矩阵等价（equivalent）、矩阵合同（congruent）：\begin{align*} & (1) A和B等价 \Leftrightarrow 存在可逆矩阵P和Q，使得B=PAQ；\\ & (2) A和B相似 \Leftrightarrow 存在可逆矩阵P，使得B=P^{-1}AP;\\ & (3) A和B合同 \Leftrightarrow 存在可逆矩阵C，使得B=C^{T}AC. \end{align*}矩阵相似，矩阵合同一定说明矩阵等价，但是相似与等价之间没有必然的联系，除非是正交矩阵，则两个等价。它们的几何意义如下：两个有限维向量空间之间的同一个线性映射，其在这两个向量空间上的不同基下所对应的矩阵之间的关系就是等价关系。 就是说它们是同一种类型的子空间，变换的作用就是为了把元素之间相互干扰的矩阵化成能一眼看出维数的简单矩阵。因为$P$和$Q$对应行初等变换和列初等变换的叠加，这里只能反映空间的维数。然而，在一些实际工程中，这些信息对我们了解一个系统已经足够用了。一个有限维向量空间上的同一个线性变换（或称线性算子），其在不同基下所对应的矩阵之间的关系是相似关系。就是同一个线性变换的不同基的描述矩阵。矩阵的相似变换可以把一个比较丑的矩阵变成一个比较美的矩阵，而保证这两个矩阵都是描述了同一个线性变换。至于什么样的矩阵是“美”的，什么样的是“丑”的，我们说对角阵是美的。总而言之，相似变换是为了简化计算。一个有限维向量空间上的同一个双线性函数或内积，其在两个基下的度量矩阵是相合关系。矩阵$A$，$B$可以不是方阵，因为是不同空间之间的线性映射矩阵，而$P$ ，$Q$，$C$必须是方阵且可逆，因为是同一空间里的基过渡矩阵。矩阵既可以看作向量的变换也可以看作是基的变换，两者的表达式中自变向量和因变向量的位置相反。任一矩阵都可以通过一系列的初等变换化非对角线上的元素为0，从而成为对角阵，因此任一矩阵都等价于一个对角阵，其对角线上的非零元素的个数正好是原矩阵的秩。然而除了秩不变外，矩阵的其他性质在变换以后就很难反映出来了。同构：如果两个线性空间上的映射变换既是单射又是满射，就称这两个向量空间同构。两个向量空间同构，那么就有线性映射使这两个线性空间的向量（或点）一一对应，而且保持线性不变，这时往往将这两个向量空间看作同一个。对于向量空间，同构也是等价关系。所以说，相似变换是同一个向量空间的变换，是两个基上的同一个线性变换。相似矩阵描述的是在不同参照系的同一个变换，动作规则是相同的，类似地，合同矩阵描述的是在不同参照系下的同一个内积的度量矩阵。由前可知，内积的度量应该是不随着坐标系的选取而改变的，因此定义了度量矩阵这个东西。事实上，内积的推广式子为：(x,y)=x^{T}Sy, S=P^{T}P其中方阵$S$就是度量矩阵，度量矩阵是由基向量所构成的过渡方阵$P$与其转置的乘积得到的。因为度量矩阵$S$是由基的过渡矩阵所决定的，那么每更换一次基坐标系就会有一个新的度量矩阵$T$，它们对应着同一个内积，且$S$合同于$T$。正交变换是保持任意向量的长度不变或者保持度量不变的线性变换，其是欧式空间中的一类重要的变换。正交变换具有合同与相似变换共同的优点，前者仅适用于对称阵，保持了矩阵的对称性、正定性、秩等性质不变；后者适用于一般方阵，保持了矩阵的秩与特征值不变。因为正交变换的矩阵$P$满足$P^{-1} = P^{T}$，实际上是合同变换与相似变换的一种结合。正交变换的主要性质是它不改变几何图形的度量。正交变换对应的矩阵就是正交矩阵，简单地说，一个正交矩阵就是一个具有标准正交列（行）向量组的方阵。线性方程组四个正交子空间。线性方程组的研究，包含了对向量的线性组合和矩阵方程的研究。方程组可以写成矩阵方程和向量组和形式等不同的形式，也反映了研究内容的不同。即线性方程组、向量的线性组合和矩阵及其矩阵方程可作等价研究。二次型二次型的内容就是研究线性空间里的一个几何图形如何在不同的坐标基下的不同的矩阵表示，合同的矩阵表示的是同一个二次函数的几何图形。定义：\begin{align*} & 含有n个变量x_{1}，x_{2}，\cdots，x_{n}的二次齐次函数：\\ & f(x_{1}，x_{2}，\cdots，x_{n})=a_{11}x_{1}^{2}+a_{22}x_{2}^{2}+\cdots+a_{nn}x_{n}^{2}+2a_{12}x_{1}x_{2}+2a_{13}x_{1}x_{3}+\cdots+2a_{(n-1)n}x_{n-1}x_{n}\\ & 称为二次型。只含有平方项的二次型称为二次型的标准型：\\ & f(x_{1}，x_{2}，\cdots，x_{n})=a_{11}x_{1}^{2}+a_{22}x_{2}^{2}+\cdots+a_{nn}x_{n}^{2} \end{align*}二次型可以表示为变元向量和矩阵的乘积：f(x_{1}，x_{2}，\cdots，x_{n})= (x_{1}，x_{2}，\cdots，x_{n}) \begin{bmatrix} a_{11} & a_{12} & \cdots & a_{1n} \\ a_{12} & a_{22} & \cdots & a_{2n} \\ \vdots & \vdots & \cdots & \vdots \\ a_{1n} & a_{2n} & \cdots & a_{nn} \end{bmatrix} \begin{pmatrix} x_{1} \\ x_{2} \\ \vdots \\ x_{n} \end{pmatrix} =x^{T}Ax任意给一个二次型，就有唯一确定的对称矩阵，反之，任给一个对称矩阵，也就唯一确定一个二次型，其中，上式中间的方块矩阵称为二次型$f$的矩阵。二次型是向量长度的平方，这个平方值不随坐标基的变化而变化，是个不变量，是绝对性的，而二次型函数的数学表达式却随着坐标基的变化而变化。问题是，线性代数是研究”线性问题“的，比如线性变换、线性空间、线性方程组等，二次型却是非线性的，那为何能用矩阵等线性工具研究？一是二次曲线或曲面本身就具有线性的性质，比如直纹曲面，一个坐标方向是直线，一个坐标方向是二次的，就可以描绘出直纹曲面（比如马鞍面）；二是用向量研究一元多项式，是用多项式的系数构成向量来等价地替代研究，不是直接研究多项式本身，因此化非线性为线性；同样，用二次型的系数构建矩阵来等价地替代研究它，同样化非线性为线性了；三是对二次型的研究利用了双线性函数的概念。二次型本来就是一个对称的双线性函数。双线性函数就是定义了某维线性空间里的双向量的一个运算，运算结果是一个数，这个数属于某个数域。其中一个变元固定时是另一个变元的线性函数，两个向量互为线性，称为双线性。双线性函数的一般定义如下：\begin{align*} & 设P^{n}是数域P上n维列向量构成的线性空间，向量x,y \in P^{n}，再设A是P上的n阶方阵。令\\ & f(x,y)=x^{T}Ay \\ & 则f(x,y)是P^{n}上的一个双线性函数。 \end{align*}二次型对角化就是把二次型化简成标准型或者规范型。对角化二次型必须要是矩阵的合同变换，或者说度量矩阵和变换后的度量矩阵必须是合同的，只有这样才能使二次型的函数值保持不变，才能使向量长度保持不变，其他方法比如矩阵的相似对角化不能保证二次型的值不变。因为从几何意义上讲，相似对角化法是使矩阵本身所表示的某种线性变换不变进而对角化，而二次型对角化法是保证矩阵背后所代表二次型的值不变，它们所要求的不变量是不同的。f(x)=x^{T}Ax=(Cy)^{T}ACy=y^{T}(C^{T}AC)y对于一个正交矩阵$Q$，有向量替换关系$x=Qy$使：f(x)=x^{T}Ax=y^{T}(Q^{T}AQ)y=y^{T}(Q^ {-1}AQ)y正交变换既是相似变换同时又是合同变换。由于正交变换保持变换前后的向量内积不变，从而保持向量的长度与夹角不变，所以正交变换属于刚体变换，是代表空间的一个旋转/镜像变换。利用矩阵乘积分解的方法，这种变换的转轴、转角可以用矩阵的特征参数量化地表示出来。和其他合同变换（又称可逆线性替换）不保持图形的原有形状，如可以把椭圆变成圆的特点相比，正交变换则保持原图形的形状。用正交变换化二次型为标准型的定理也称为主轴定理，这同时也是主轴定理的几何意义。主轴定理：\begin {align*} & 对于任意一个n元二次型：\\ & f(x_{1}，x_{2}，\cdots，x_{n})=x^{T}Ax\\ & 存在正交变换x=Qy（Q为n元正交矩阵），使得\\ & x^{T}Ax=y^{T}(Q^{T}AQ)y=\lambda_{1}y_{1}^{2}+\lambda_{2}y_{2}^{2}+\cdots+\lambda_{n}y_{n}^{2} \end{align*}其中，$\lambda_{1}，\lambda_{2}，\cdots，\lambda_{n}$是实对称矩阵$A$的n个特征值；$Q$的n个列向量是对应于特征值$\lambda_{1}，\lambda_{2}，\cdots，\lambda_{n}$的标准正交特征向量。神奇的矩阵空间空间是现代数学的基础之一。线形空间其实还是比较初级的，如果在里面定义了范数，就成了赋范线性空间。赋范线性空间满足完备性，就成了巴那赫空间；赋范线性空间中定义角度，就有了内积空间，内积空间再满足完备性，就得到希尔伯特空间，如果空间里装载所有类型的函数，就叫泛函空间。容纳运动是空间的本质。不管是什么空间，都必须容纳和支持在其中发生的符合规则的运动（变换）。在某种空间中往往会存在一种相对应的变换，比如拓扑空间中有拓扑变换，线性空间中有线性变换，仿射空间中有仿射变换，其实这些变换都只不过是对应空间中允许的运动形式而已。因此只要知道， “空间”是容纳运动的一个对象集合，而变换则规定了对应空间的运动。矩阵的运动本质属性线性空间中的运动，被称为线性变换。也就是说，你从线性空间中的一个点运动到任意的另外一个点，都可以通过一个线性变化来完成。在线性空间中，当你选定一组基之后，不仅可以用一个向量来描述空间中的任何一个对象，而且可以用矩阵来描述该空间中的任何一个运动（变换）。而使某个对象发生对应运动的方法，就是用代表那个运动的矩阵，乘以代表那个对象的向量。简而言之，在线性空间中选定基之后，向量刻画对象，矩阵刻画对象的运动，用矩阵与向量的乘法施加运动。矩阵的本质是运动的描述。不过，这里“运动”的概念不是微积分中的连续性的运动，而是瞬间发生的变化，是物理当中“跃迁”的一种描述，在这里我们将其称为“变换”，也就是说，矩阵是线性空间里的变换的描述。“矩阵是线性空间中的线性变换的一个描述。在一个线性空间中，只要我们选定一组基，那么对于任何一个线性变换，都能够用一个确定的矩阵来加以描述”。矩阵与方程组老生常谈的列空间，秩，交点等问题了。矩阵与坐标系向量左乘矩阵将向量变换成另一个向量，一组基右乘一个方阵将其变换到另一组基，左乘一个方阵就是将一组基下的坐标变换到另一组基下的坐标，也就是说运动是相对的，而这个相对体现在左乘和右乘上。对于矩阵乘法，主要是考察一个矩阵对另一个矩阵所起的变换作用。其作用的矩阵看作是动作矩阵，被作用的矩阵可以看作是由行或列向量构成的几何图形。同样，如果一连串的矩阵相乘，就是多次变换的叠加。而矩阵左乘无非是把一个向量或一组向量（即另一个矩阵）进行伸缩或旋转。 乘积的效果就是多个伸缩和旋转的叠加。其中两类特殊的矩阵：旋转矩阵和对角矩阵，分别表示对向量的旋转和伸缩。矩阵与傅里叶变换1.分解与叠加的思想，以及完备性才会完全替代“棱角”的波形。在这里，基不再是向量，而是三角函数。2.为什么是选择三角函数？大自然中很多现象可以抽象成一个线性时不变系统来研究，无论你用微分方程还是传递函数或者状态空间描述。线性时不变系统可以这样理解： 输入输出信号满足线性关系，而且系统参数不随时间变换。对于大自然界的很多系统，一个正弦曲线信号输入后，输出的仍是正弦曲线，只有幅度和相位可能发生变化，但是频率和波的形状仍是一样的。也就是说正弦信号是系统的特征向量。当然，指数信号也是系统的特征向量，表示能量的衰减或积聚。自然界的衰减或者扩散现象大多是指数形式的，或者既有波动又有指数衰减（复指数$e^{\alpha+i \beta}$形式），因此具有特征的基函数就由三角函数变成复指数函数。但是，如果输入是方波、三角波或者其他什么波形，那输出就不一定是什么样子了。所以，除了指数信号和正弦信号以外的其他波形都不是线性系统的特征信号。用正弦曲线来代替原来的曲线而不用方波或三角波或者其他什么函数来表示的原因在于： 正弦信号恰好是很多线性时不变系统的特征向量。于是就有了傅里叶变换。对于更一般的线性时不变系统，复指数信号(表示耗散或衰减)是系统的“特征向量”。于是就有了拉普拉斯变换。z 变换也是同样的道理，这时$z^{n}$是离散系统的“特征向量”。 这里没有区分特征向量和特征函数的概念，主要想表达二者的思想是相同的，只不过一个是有限维向量，一个是无限维函数。傅里叶级数和傅里叶变换其实就是我们之前讨论的特征值与特征向量的问题。分解信号的方法是无穷的，但分解信号的目的是为了更加简单地处理原来的信号。这样，用正余弦来表示原信号会更加简单，因为正余弦拥有原信号所不具有的性质：正弦曲线保真度。且只有正弦曲线才拥有这样的性质。 这样做的好处就是知道输入，我们就能很简单乘一个系数写出输出。3.时域和频域以时间作为参照来观察动态世界的方法我们称其为时域分析，频域 (frequency domain) 是描述信号在频率方面特性时用到的一种坐标系。用线性代数的语言就是装着正弦函数的空间。频域最重要的性质是：它不是真实的，而是一个数学构造。频域是一个遵循特定规则的数学范畴。正弦波是频域中唯一存在的波形，这是频域中最重要的规则，即正弦波是对频域的描述，因为时域中的任何波形都可用正弦波合成。对于一个信号来说，信号强度随时间的变化规律就是时域特性，信号是由哪些单一频率的信号合成的就是频域特性。这里的核心就是一种信号可以用另一种信号作为基函数线性表示。而由于现实世界中正弦信号是系统的特征向量，所以我们就用傅里叶变换，将研究的信号在频域展开。总而言之， 不管是傅里叶级数，还是傅里叶变换、拉普拉斯变换、z 变换，本质上都是线性代数里面讲的求特征值和特征向量。4.傅里叶级数Strang老爷子在课上专门讲过通过投影和正交基求出傅里叶级数，正交基中的每个函数都可以看做是一条独立的坐标轴，从几何角度来看，傅里叶级数展开其实只是在做一个动作，那就是把函数“投影”到一系列由三角函数构成的“坐标轴”上。上面的系数则是函数在每条坐标轴上的坐标。注意，在有限维中，内积是点积的形式，而在无限维中则是积分的形式。这组正交基是：$\left\{1, \cos \frac {\pi x}{l}, \sin \frac{\pi x}{l}, \cos \frac{2 \pi x}{l}, \sin \frac {2\pi x}{l}, \cdots \right\}$\begin{align*} & a_{0}=\frac {\left\langle f,1 \right\rangle}{\left \langle 1,1 \right \rangle}=\frac{\int_{-l}^{l}f(x)\,dx}{\int_{-l}^{l}\,dx} =\frac{\int_{-l}^{l}f(x)\,dx}{2l} \\ & a_{n}=\frac {\left \langle f, \cos \frac {n \pi x}{l}\right \rangle}{\left \langle \cos \frac{n \pi x}{l}, \cos \frac{n \pi x}{l} \right \rangle} = \frac {\int_{-l}^{l}f(x)\cos \frac{n \pi x}{l} \,dx}{\int_{-l}^{l} \cos^2 \frac{n \pi x}{l}\,dx} = \frac {\int_{-l}^{l}f(x)\cos \frac{n \pi x}{l} \,dx}{l},n \ge 1 \\ & b_{n}=\frac {\left \langle f, \sin \frac {n \pi x}{l}\right \rangle}{\left \langle \sin \frac{n \pi x}{l}, \sin \frac{n \pi x}{l} \right \rangle} = \frac {\int_{-l}^{l}f(x)\sin \frac{n \pi x}{l} \,dx}{\int_{-l}^{l} \sin^2 \frac{n \pi x}{l}\,dx} = \frac {\int_{-l}^{l}f(x)\sin \frac{n \pi x}{l} \,dx}{l},n \ge 1 \\ \end{align*}同理，对于复数形式的傅里叶级数，也可以用几何投影的观点来写出所有的系数。矩阵的奇异值分解（SVD）$M=U \sum V^{T}$任意的矩阵$M$是可以分解成三个矩阵。 $V$表示了原始域的标准正交基，$ U$表示$M$经过变换后的 co-domain 的标准正交基，$\sum$表示了$V$中的向量与$U$中相对应向量之间的关系。事实上，我们可以找到任何矩阵的奇异值分解。如果把矩阵$U$用它的列向量表示出来，可以写成：U=(u_{1}, u_{2}, \cdots, u_{n})其中每一个$u_{i}$称为$M$的左奇异向量。类似地，对于$V$，有：V=(v_{1}, v_{2}, \cdots, v_{n})其中每一个$v_{i}$被称为$M$的右奇异向量。然后设矩阵$\sum$的对角线元素为$\sigma_{i}$并按降序排列，则$M$就可以表示为：M=\sigma_{1}u_{1}v_{1}^{T}+\sigma_{2}u_{2}v_{2}^{T}+\cdots+\sigma_{n}u_{n}v_{n}^{T} =\sum_{i=1}^{n}\sigma_{i}u_{i}v_{i}^{T}=\sum_{i=1}^{n}A_{i}其中$A_{i}=\sigma_{i}u_{i}v_{i}^{T}$是一个$m \times n$的矩阵，即把原来的矩阵表示成了n个矩阵的和。因此，可以根据$\sigma_{i}$的大小进行矩阵的近似表达，主成分分析的思想就是来源于此。奇异值分解在推荐系统，图像压缩，潜在语义索引，潜在数据表达，降噪，数据分析等有很重要的应用。]]></content>
      <categories>
        <category>基础数学</category>
      </categories>
      <tags>
        <tag>MIT</tag>
        <tag>mathematics</tag>
        <tag>linear algebra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github 博客搭建]]></title>
    <url>%2Fposts%2FHexoBlogBulid%2F</url>
    <content type="text"><![CDATA[完整搭建过程参考此系列博客（环境win10）我的写作编辑器用的是typoraNext主题配置Next主题是本人比较中意的hexo主题，所以在此只记录Next主题的配置过程下载建议安装6.0版本。利用git bash here,输入命令：git clone https://github.com/theme-next/hexo-theme-next themes/next配置与个性化1.添加作者头像并设置旋转效果注意：最新版本的next主题已经添加了头像动画功能，直接在主题的配置文件里面修改，因此头像添加（路径）也是在主题配置文件里面添加，而不是在根目录的配置文件添加123456789101112# Sidebar Avataravatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /uploads/header.jpg #/images/avatar.gif # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: true2.修改标签“#”符号和插入图片3.添加社交账号如果遇到没有的社交图标，可以在fontawesome中寻找添加。 ||后面的是图标名，建议不要找最新的。4.菜单设置本地搜索一旦开启会自动添加”搜索“菜单5.添加版权信息。参考该文章上面的链接是手动添加，现在可以在NEXT主题配置文件中进行修改12345creative_commons: license: by-nc-sa sidebar: true post: true language:6.利用leancloud加入阅读计数功能若页面LeanCloud访问统计提示’Counter not initialized! See more at console err msg.’参考该博客解决问题：安装hexo-leancloud-counter-security报错：npm WARN babel-eslint@10.0.1 requires a peer of eslint@&gt;= 4.12.1 but none is installed. You must install peer dependencies yourself.因此缺什么就安装什么，在这里我是安装：npm install eslint@&gt;= 4.12.1,之后再安装hexo-leancloud-counter-security就成功了。另外最后在修正deploy的时候注意tab的控制，不然编译会报错12345678910deploy: #type: git #repository: git@github.com:x695/thinkee.github.io.git #repository: https://github.com/x695/thinkee.github.io.git #branch: master - type: git #repository: git@e.coding.net:yangshixian/blog.git repository: git@git.coding.net:thinkee/blog.coding.me.git branch: master - type: leancloud_counter_security_sync然而，十分尴尬的是，阅读数依然没有显示，后来参考这篇博客得到了解决7.利用valine+leancloud添加评论功能参考8.网站背景动画如果修改主题配置文件之后不出现动画，建议下载主要的库到/source/lib中9.加入本地搜索功能10.加入Latex数学公式这个除了在主题配置文件修改mathjax: true之外，还需要在每个post的博客里的头代码里面加入mathjax: true才可以正常显示。如果嫌每次书写都得添加麻烦，可以直接在根目录的scaffolds文件夹里的post.m文件夹直接加入mathjax: true，之后每次新建都会自动添加了。不过再后续使用Latex语句的时候，发现博客上还是会显示源码，后来发现应该是渲染引擎的问题，根据这篇博客的指导修改后就好了。2019.3.5日来更新，写完一篇blog进行generate时候出现了错误：123Template render error: (unknown path) [Line 62, Column 32] expected variable end at Object.exports.prettifyError出现的原因要么是主题配置文件忘了打空格，要么就是自己写的blog文件里面用的符号与其他hexo配置文件语法有冲突，后来发现原因是我打公式时出现了两个“}}”，前面一个”}”是latex语法，后面是”\}”，目的是为了输出括号“}”，之后参照latex的另一种打法“\lbrace \rbrace”就好了2019.4.17日来更公式直接用Mathpix进行LaTex命令复制吧，非常方便，也几乎没出现什么错误，还省时间。11.博客图片点击放大在NEXT主题的配置文件里面有fancybox选项，直接改为true就好了，不过在这之前要下载fancybox包到next/source/lib文件夹里面，即：12cd next/source/libgit clone https://github.com/theme-next/theme-next-fancybox3 fancybox12.并排插入两张图片1234&lt;figure class=&quot;half&quot;&gt; &lt;img src=&quot;xxx.jpg&quot; width=&quot;400&quot;/&gt; &lt;img src=&quot;xxx.jpg&quot; width=&quot;400&quot;/&gt;&lt;/figure&gt;不过这只能在.md文件中实现，博客中还是上下各一张。13.NEXT主题内置标签（包括引用文本居中，图片最大化引用等），更详细的标签见hexo官网。注意在本地利用这些标签不会出现相应的结果，只有上传到博客上才能看到。14.添加emoji表情功能emoji大全关于加入表情的功能，我一共找到了两种方法，一种是基于修改渲染引擎的，然后加入twemoji插件，但是我在之前为了支持mathjax已经更换了渲染引擎，结果导致我在按照博客1和博客2的操作进行时出现了fancybox图片放大和图片内部插入的问题，有时候甚至会影响到html语句，后来倒退删除渲染引擎和插件的时候，想要恢复到原来的状态，结果hexo g可以成功，本地却无法显示不出内容，结果只好重装。。目前原因未知。此外，第二种方法是安装hexo-filter-github-emojis插件，可参考博客3和博客4，但是我看博客中也提到了图片干扰的问题，就没再继续试下去了。。。下次看到更好的解决办法再来更新。15.加入RSS订阅直接在NEXT主题配置文件里面更改，在这之前先在博客站点目录下安装npm install hexo-generator-feed --save123456feed: type: rss2 path: rss2.xml limit: 5 hub: content: &apos;true&apos;16.博客被谷歌和百度收录参考这个博客的做法17.购买自己的阿里云域名并设置参考出现问题：leancloud阅读统计和评论系统出现问题，在安全中心更换了域名之后，deploy时出现Error，too much request，得知时免费版的限制导致错误，按照此博客修改并重新配置了一个leancloud Counter应用未能解决问题。此博客 通过加入lean-analytics.swig文件也未能解决问题。偶然通过换回valine+leancloud评论系统出现code 403问题进行改正时也顺便解决了这个问题。个人GitHub博客的settings页面的Github Pages有个Enforce HTTPS选项，我没勾，所以http://或者https://都可以访问我的域名，而我的leancloud`安全中心`中的安全域名只加了https://的，在加一个http://就好了。。但是deploy时依然会有些莫名其妙的错误，比如ERROR Password must be string，但是既然正常显示了，我就没再管了。。18.更换评论Gitalk系统由于leancloud经常出现问题，不易维护，所以可以考虑更换评论系统为Gitalk，虽然评论必须登陆GitHub账号，但是可以接受，毕竟现在理工科都有Github账号，此外还加了字数统计和阅读时长等信息。具体操作参见链接。需要注意，使用Gitalk评论系统时，每次deploy都需要在博客下登陆自己的账号初始化下19.对博客进行代码压缩（加快访问速度）和备份（便于更换设备时进行迁移），另外更改文章链接失败。参考：https://indexmoon.com/articles/1153730074/ （其中，.gitignore文件可通过在git bash中利用touch .gitignore命令创建）20.插入GIF图片，利用html语法，直接上img标签：&lt;img src=&quot;图片地址&quot; style=&quot;zoom: 100%&quot; /&gt;21.优化文章链接，使得post的url可以成为定制链接，做法见此如果你用的hexo-asset-image版本较低，可能会出现图片无法显示的情况，因为两个插件冲突导致最后的图片路径不对。新版的hexo-asset-image已经解决了这个问题，但是我自己的实验情况下是在abbrlink后加.html，否则还是无法显示，只能用abbrlink/. 此外必须用![](pic.jpg)这样的方式插入图片。如果你用的是typora编辑器，可以使用默认根目录显示图片。具体做法可以见这个issue.此外由于abbrlink改变了原来的文章链接，所以leancloud的计数和评论都会消失。由于我的文章不多，所以我就自己改了过来。你也参考这篇文章的解决办法。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>leancloud</tag>
        <tag>next</tag>
      </tags>
  </entry>
</search>
